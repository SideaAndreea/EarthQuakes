{"ast":null,"code":"import { getTransferList } from '../worker-utils/get-transfer-list';\n\nfunction getParentPort() {\n  let parentPort;\n\n  try {\n    eval('globalThis.parentPort = require(\\'worker_threads\\').parentPort');\n    parentPort = globalThis.parentPort;\n  } catch {}\n\n  return parentPort;\n}\n\nconst onMessageWrapperMap = new Map();\nexport default class WorkerBody {\n  static inWorkerThread() {\n    return typeof self !== 'undefined' || Boolean(getParentPort());\n  }\n\n  static set onmessage(onMessage) {\n    function handleMessage(message) {\n      const parentPort = getParentPort();\n      const {\n        type,\n        payload\n      } = parentPort ? message : message.data;\n      onMessage(type, payload);\n    }\n\n    const parentPort = getParentPort();\n\n    if (parentPort) {\n      parentPort.on('message', handleMessage);\n      parentPort.on('exit', () => console.debug('Node worker closing'));\n    } else {\n      globalThis.onmessage = handleMessage;\n    }\n  }\n\n  static addEventListener(onMessage) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = message => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        const parentPort = getParentPort();\n        const {\n          type,\n          payload\n        } = parentPort ? message : message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    const parentPort = getParentPort();\n\n    if (parentPort) {\n      console.error('not implemented');\n    } else {\n      globalThis.addEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static removeEventListener(onMessage) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    const parentPort = getParentPort();\n\n    if (parentPort) {\n      console.error('not implemented');\n    } else {\n      globalThis.removeEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static postMessage(type, payload) {\n    const data = {\n      source: 'loaders.gl',\n      type,\n      payload\n    };\n    const transferList = getTransferList(payload);\n    const parentPort = getParentPort();\n\n    if (parentPort) {\n      parentPort.postMessage(data, transferList);\n    } else {\n      globalThis.postMessage(data, transferList);\n    }\n  }\n\n}\n\nfunction isKnownMessage(message) {\n  const {\n    type,\n    data\n  } = message;\n  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');\n}","map":{"version":3,"mappings":"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","names":["getTransferList","getParentPort","parentPort","eval","globalThis","onMessageWrapperMap","Map","WorkerBody","inWorkerThread","self","Boolean","onmessage","onMessage","handleMessage","message","type","payload","data","on","console","debug","addEventListener","onMessageWrapper","get","isKnownMessage","error","removeEventListener","delete","postMessage","source","transferList","startsWith"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\AplicaÈ›ii\\earthquakes\\node_modules\\@loaders.gl\\worker-utils\\src\\lib\\worker-farm\\worker-body.ts"],"sourcesContent":["import type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\n/** Vile hack to defeat over-zealous bundlers from stripping out the require */\nfunction getParentPort() {\n  // const isNode = globalThis.process;\n  let parentPort;\n  try {\n    // prettier-ignore\n    eval('globalThis.parentPort = require(\\'worker_threads\\').parentPort'); // eslint-disable-line no-eval\n    parentPort = globalThis.parentPort;\n    // eslint-disable-next-line no-empty\n  } catch {}\n  return parentPort;\n}\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /** Check that we are actually in a worker thread */\n  static inWorkerThread(): boolean {\n    return typeof self !== 'undefined' || Boolean(getParentPort());\n  }\n\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    function handleMessage(message) {\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const parentPort = getParentPort();\n      const {type, payload} = parentPort ? message : message.data;\n      // if (!isKnownMessage(message)) {\n      //   return;\n      // }\n      onMessage(type, payload);\n    }\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      parentPort.on('message', handleMessage);\n      // if (message == 'exit') { parentPort.unref(); }\n      // eslint-disable-next-line\n      parentPort.on('exit', () => console.debug('Node worker closing'));\n    } else {\n      // eslint-disable-next-line no-restricted-globals\n      globalThis.onmessage = handleMessage;\n    }\n  }\n\n  static addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = (message: MessageEvent<any>) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        // Confusingly in the browser, the message itself also has a 'type' field which is always set to 'message'\n        const parentPort = getParentPort();\n        const {type, payload} = parentPort ? message : message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.addEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    const parentPort = getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.removeEventListener('message', onMessageWrapper);\n    }\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n    // console.log('posting message', data);\n    const transferList = getTransferList(payload);\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      parentPort.postMessage(data, transferList);\n      // console.log('posted message', data);\n    } else {\n      // @ts-ignore\n      globalThis.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message: MessageEvent<any>) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n"]},"metadata":{},"sourceType":"module"}