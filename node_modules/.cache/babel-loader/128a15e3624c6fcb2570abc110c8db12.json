{"ast":null,"code":"import { Tile3DSubtreeLoader } from '../../tile-3d-subtree-loader';\nimport { load } from '@loaders.gl/core';\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nimport { parseImplicitTiles, replaceContentUrlTemplate } from './helpers/parse-3d-implicit-tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  const contentUrl = tile.contentUrl;\n  const fileExtension = contentUrl.split('.').pop();\n\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n\n    default:\n      return refine;\n  }\n}\n\nfunction resolveUri(uri, basePath) {\n  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;\n\n  if (urlSchemeRegex.test(basePath)) {\n    const url = new URL(uri, \"\".concat(basePath, \"/\"));\n    return decodeURI(url.toString());\n  } else if (uri.startsWith('/')) {\n    return uri;\n  }\n\n  return \"\".concat(basePath, \"/\").concat(uri);\n}\n\nexport function normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = resolveUri(contentUri, options.basePath);\n  }\n\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n  return tile;\n}\nexport function normalizeTileHeaders(tileset) {\n  const basePath = tileset.basePath;\n  const root = normalizeTileData(tileset.root, tileset);\n  const stack = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n\n    for (const childHeader of children) {\n      normalizeTileData(childHeader, {\n        basePath\n      });\n      stack.push(childHeader);\n    }\n  }\n\n  return root;\n}\nexport async function normalizeImplicitTileHeaders(tileset) {\n  if (!tileset.root) {\n    return null;\n  }\n\n  const basePath = tileset.basePath;\n  const implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    subtreeLevels,\n    subtrees: {\n      uri: subtreesUriTemplate\n    }\n  } = implicitTilingExtension;\n  const subtreeUrl = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const rootSubtreeUrl = resolveUri(subtreeUrl, basePath);\n  const rootSubtree = await load(rootSubtreeUrl, Tile3DSubtreeLoader);\n  const contentUrlTemplate = resolveUri(tileset.root.content.uri, basePath);\n  const refine = tileset.root.refine;\n  const rootLodMetricValue = tileset.root.geometricError;\n  const rootBoundingVolume = tileset.root.boundingVolume;\n  const options = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n  return await normalizeImplicitTileData(tileset.root, rootSubtree, options);\n}\nexport async function normalizeImplicitTileData(tile, rootSubtree, options) {\n  if (!tile) {\n    return null;\n  }\n\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  const {\n    children,\n    contentUrl\n  } = await parseImplicitTiles({\n    subtree: rootSubtree,\n    options\n  });\n\n  if (contentUrl) {\n    tile.contentUrl = contentUrl;\n    tile.content = {\n      uri: contentUrl.replace(\"\".concat(options.basePath, \"/\"), '')\n    };\n  }\n\n  tile.refine = getRefine(tile.refine);\n  tile.type = getTileType(tile);\n  tile.children = children;\n  tile.id = tile.contentUrl;\n  return tile;\n}","map":{"version":3,"mappings":"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","names":["Tile3DSubtreeLoader","load","LOD_METRIC_TYPE","TILE_REFINEMENT","TILE_TYPE","parseImplicitTiles","replaceContentUrlTemplate","getTileType","tile","contentUrl","EMPTY","fileExtension","split","pop","POINTCLOUD","SCENEGRAPH","getRefine","refine","REPLACE","ADD","resolveUri","uri","basePath","urlSchemeRegex","test","url","URL","decodeURI","toString","startsWith","normalizeTileData","options","content","contentUri","id","lodMetricType","GEOMETRIC_ERROR","lodMetricValue","geometricError","transformMatrix","transform","type","normalizeTileHeaders","tileset","root","stack","push","length","children","childHeader","normalizeImplicitTileHeaders","implicitTilingExtension","extensions","subdivisionScheme","maximumLevel","subtreeLevels","subtrees","subtreesUriTemplate","subtreeUrl","rootSubtreeUrl","rootSubtree","contentUrlTemplate","rootLodMetricValue","rootBoundingVolume","boundingVolume","normalizeImplicitTileData","subtree","replace"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@loaders.gl\\3d-tiles\\src\\lib\\parsers\\parse-3d-tile-header.ts"],"sourcesContent":["import {Tile3DSubtreeLoader} from '../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Subtree} from '../../types';\nimport {parseImplicitTiles, replaceContentUrlTemplate} from './helpers/parse-3d-implicit-tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  const contentUrl = tile.contentUrl;\n  const fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\n\nfunction resolveUri(uri, basePath) {\n  // url scheme per RFC3986\n  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;\n\n  if (urlSchemeRegex.test(basePath)) {\n    const url = new URL(uri, `${basePath}/`);\n    return decodeURI(url.toString());\n  } else if (uri.startsWith('/')) {\n    return uri;\n  }\n\n  return `${basePath}/${uri}`;\n}\n\nexport function normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = resolveUri(contentUri, options.basePath);\n  }\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n\n  return tile;\n}\n\n// normalize tile headers\nexport function normalizeTileHeaders(tileset) {\n  const basePath = tileset.basePath;\n  const root = normalizeTileData(tileset.root, tileset);\n\n  const stack: any[] = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n    for (const childHeader of children) {\n      normalizeTileData(childHeader, {basePath});\n      stack.push(childHeader);\n    }\n  }\n\n  return root;\n}\n\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(tileset: Tileset3D) {\n  if (!tileset.root) {\n    return null;\n  }\n\n  const basePath = tileset.basePath;\n  const implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    subtreeLevels,\n    subtrees: {uri: subtreesUriTemplate}\n  } = implicitTilingExtension;\n  const subtreeUrl = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const rootSubtreeUrl = resolveUri(subtreeUrl, basePath);\n  const rootSubtree = await load(rootSubtreeUrl, Tile3DSubtreeLoader);\n  const contentUrlTemplate = resolveUri(tileset.root.content.uri, basePath);\n  const refine = tileset.root.refine;\n  // @ts-ignore\n  const rootLodMetricValue = tileset.root.geometricError;\n  const rootBoundingVolume = tileset.root.boundingVolume;\n\n  const options = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n\n  return await normalizeImplicitTileData(tileset.root, rootSubtree, options);\n}\n\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, rootSubtree: Subtree, options: any) {\n  if (!tile) {\n    return null;\n  }\n\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n\n  const {children, contentUrl} = await parseImplicitTiles({subtree: rootSubtree, options});\n\n  if (contentUrl) {\n    tile.contentUrl = contentUrl;\n    tile.content = {uri: contentUrl.replace(`${options.basePath}/`, '')};\n  }\n\n  tile.refine = getRefine(tile.refine);\n  tile.type = getTileType(tile);\n  tile.children = children;\n  tile.id = tile.contentUrl;\n\n  return tile;\n}\n"]},"metadata":{},"sourceType":"module"}