{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\nexport function getFrameState(viewport, frameNumber) {\n  const {\n    cameraDirection,\n    cameraUp,\n    height\n  } = viewport;\n  const {\n    metersPerUnit\n  } = viewport.distanceScales;\n  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  const cameraDirectionCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n  const cameraUpCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n  commonSpacePlanesToWGS84(viewport);\n  const ViewportClass = viewport.constructor;\n  const {\n    longitude,\n    latitude,\n    width,\n    bearing,\n    zoom\n  } = viewport;\n  const topDownViewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    topDownViewport,\n    height,\n    cullingVolume,\n    frameNumber,\n    sseDenominator: 1.15\n  };\n}\nexport function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n\n  const tuples = [];\n  const {\n    longitude: viewportLongitude,\n    latitude: viewportLatitude\n  } = frameState.viewport;\n\n  for (const [index, tile] of tiles.entries()) {\n    const [longitude, latitude] = tile.header.mbs;\n    const deltaLon = Math.abs(viewportLongitude - longitude);\n    const deltaLat = Math.abs(viewportLatitude - latitude);\n    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n    tuples.push([index, distance]);\n  }\n\n  const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n  const selectedTiles = [];\n\n  for (let i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n\n  const unselectedTiles = [];\n\n  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n    unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n\n  return [selectedTiles, unselectedTiles];\n}\n\nfunction commonSpacePlanesToWGS84(viewport) {\n  const frustumPlanes = viewport.getFrustumPlanes();\n  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n  let i = 0;\n  cullingVolume.planes[i++].fromPointNormal(nearCenterCartesian, scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian));\n\n  for (const dir in frustumPlanes) {\n    if (dir === 'near') {\n      continue;\n    }\n\n    const plane = frustumPlanes[dir];\n    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n    cullingVolume.planes[i++].fromPointNormal(cartesianPos, scratchVector.copy(nearCenterCartesian).subtract(cartesianPos));\n  }\n}\n\nfunction closestPointOnPlane(plane, refPoint) {\n  let out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n  const distanceToRef = plane.normal.dot(refPoint);\n  out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);\n  return out;\n}\n\nfunction worldToCartesian(viewport, point) {\n  let out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n  const cartographicPos = viewport.unprojectPosition(point);\n  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}","map":{"version":3,"mappings":"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","names":["Vector3","CullingVolume","Plane","Ellipsoid","scratchVector","scratchPosition","cullingVolume","getFrameState","viewport","frameNumber","cameraDirection","cameraUp","height","metersPerUnit","distanceScales","viewportCenterCartesian","worldToCartesian","center","enuToFixedTransform","WGS84","eastNorthUpToFixedFrame","cameraPositionCartographic","unprojectPosition","cameraPosition","cameraPositionCartesian","cartographicToCartesian","cameraDirectionCartesian","transformAsVector","scale","normalize","cameraUpCartesian","commonSpacePlanesToWGS84","ViewportClass","constructor","longitude","latitude","width","bearing","zoom","topDownViewport","pitch","camera","position","direction","up","sseDenominator","limitSelectedTiles","tiles","frameState","maximumTilesSelected","length","tuples","viewportLongitude","viewportLatitude","index","tile","entries","header","mbs","deltaLon","Math","abs","deltaLat","distance","sqrt","push","tuplesSorted","sort","a","b","selectedTiles","i","unselectedTiles","frustumPlanes","getFrustumPlanes","nearCenterCommon","closestPointOnPlane","near","nearCenterCartesian","cameraCartesian","planes","fromPointNormal","copy","subtract","dir","plane","posCommon","cartesianPos","refPoint","out","distanceToRef","normal","dot","add","point","cartographicPos"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@loaders.gl\\tiles\\src\\tileset\\helpers\\frame-state.ts"],"sourcesContent":["import {Tile3D} from '@loaders.gl/tiles';\nimport {Vector3} from '@math.gl/core';\nimport {CullingVolume, Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {Viewport} from '../../types';\n\nexport type FrameState = {\n  camera: {\n    position: number[];\n    direction: number[];\n    up: number[];\n  };\n  viewport: Viewport;\n  topDownViewport: Viewport; // Use it to calculate projected radius for a tile\n  height: number;\n  cullingVolume: CullingVolume;\n  frameNumber: number; // TODO: This can be the same between updates, what number is unique for between updates?\n  sseDenominator: number; // Assumes fovy = 60 degrees\n};\n\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane()\n]);\n\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport: Viewport, frameNumber: number): FrameState {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {cameraDirection, cameraUp, height} = viewport;\n  const {metersPerUnit} = viewport.distanceScales;\n\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))\n  ).normalize();\n  const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))\n  ).normalize();\n\n  commonSpacePlanesToWGS84(viewport);\n\n  const ViewportClass = viewport.constructor;\n  const {longitude, latitude, width, bearing, zoom} = viewport;\n  // @ts-ignore\n  const topDownViewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    topDownViewport,\n    height,\n    cullingVolume,\n    frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(\n  tiles: Tile3D[],\n  frameState: FrameState,\n  maximumTilesSelected: number\n): [Tile3D[], Tile3D[]] {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n  // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n  const tuples: [number, number][] = [];\n  const {longitude: viewportLongitude, latitude: viewportLatitude} = frameState.viewport;\n  for (const [index, tile] of tiles.entries()) {\n    const [longitude, latitude] = tile.header.mbs;\n    const deltaLon = Math.abs(viewportLongitude - longitude);\n    const deltaLat = Math.abs(viewportLatitude - latitude);\n    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n    tuples.push([index, distance]);\n  }\n  const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n  const selectedTiles: Tile3D[] = [];\n  for (let i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  const unselectedTiles: Tile3D[] = [];\n  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n    unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n\n  return [selectedTiles, unselectedTiles];\n}\n\nfunction commonSpacePlanesToWGS84(viewport) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n\n  // Get the near/far plane centers\n  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n\n  let i = 0;\n  cullingVolume.planes[i++].fromPointNormal(\n    nearCenterCartesian,\n    scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian)\n  );\n\n  for (const dir in frustumPlanes) {\n    if (dir === 'near') {\n      continue;\n    }\n    const plane = frustumPlanes[dir];\n    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n\n    cullingVolume.planes[i++].fromPointNormal(\n      cartesianPos,\n      // Want the normal to point into the frustum since that's what culling expects\n      scratchVector.copy(nearCenterCartesian).subtract(cartesianPos)\n    );\n  }\n}\n\nfunction closestPointOnPlane(\n  plane: {distance: number; normal: Vector3},\n  refPoint: [number, number, number] | Vector3,\n  out: Vector3 = new Vector3()\n): Vector3 {\n  const distanceToRef = plane.normal.dot(refPoint);\n  out\n    .copy(plane.normal)\n    .scale(plane.distance - distanceToRef)\n    .add(refPoint);\n  return out;\n}\n\nfunction worldToCartesian(\n  viewport: Viewport,\n  point: [number, number, number] | Vector3,\n  out: Vector3 = new Vector3()\n): Vector3 {\n  const cartographicPos = viewport.unprojectPosition(point);\n  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}\n"]},"metadata":{},"sourceType":"module"}