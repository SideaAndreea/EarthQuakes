{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer } from '@deck.gl/core';\nimport { replaceInRange } from '../utils';\nimport { binaryToFeatureForAccesor } from './geojson-binary';\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from './sub-layer-map';\nimport { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from './geojson-layer-props';\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\nconst defaultProps = { ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: f => f.properties.icon\n  },\n  getText: {\n    type: 'accessor',\n    value: f => f.properties.text\n  },\n  pointType: 'circle',\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n};\nexport default class GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState(_ref) {\n    let {\n      props,\n      changeFlags\n    } = _ref;\n\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n\n    const {\n      data\n    } = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n    this.setState({\n      binary\n    });\n\n    if (binary) {\n      this._updateStateBinary({\n        props,\n        changeFlags\n      });\n    } else {\n      this._updateStateJSON({\n        props,\n        changeFlags\n      });\n    }\n  }\n\n  _updateStateBinary(_ref2) {\n    let {\n      props,\n      changeFlags\n    } = _ref2;\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({\n      layerProps\n    });\n  }\n\n  _updateStateJSON(_ref3) {\n    let {\n      props,\n      changeFlags\n    } = _ref3;\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(replaceInRange({\n            data: newFeatures[key],\n            getIndex: f => f.__source.index,\n            dataRange,\n            replace: partialFeatures[key]\n          }));\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index,\n      sourceLayer\n    } = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(\"\".concat(this.id, \"-\").concat(ft, \"-\")));\n\n    if (index >= 0 && sourceLayer.id.startsWith(\"\".concat(this.id, \"-points-text\")) && this.state.binary) {\n      info.index = this.props.data.points.globalFeatureIds.value[index];\n    }\n\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    const pointLayerIdPrefix = \"\".concat(this.id, \"-points-\");\n    const sourceIsPoints = info.featureType === 'points';\n\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  _renderPolygonLayer() {\n    const {\n      extruded,\n      wireframe\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const id = 'polygons-fill';\n    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      const useLineColor = extruded && wireframe;\n\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n        id,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygons);\n    }\n\n    return null;\n  }\n\n  _renderLineLayers() {\n    const {\n      extruded,\n      stroked\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n        id: polygonStrokeLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n        id: lineStringsLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.lines)];\n    }\n\n    return null;\n  }\n\n  _renderPointLayers() {\n    const {\n      pointType\n    } = this.props;\n    const {\n      layerProps,\n      binary\n    } = this.state;\n    let {\n      highlightedObjectIndex\n    } = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);\n    }\n\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n\n    for (const type of types) {\n      const id = \"points-\".concat(type);\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          const {\n            instancePickingColors,\n            ...rest\n          } = pointsLayerProps.data.attributes;\n          pointsLayerProps = { ...pointsLayerProps,\n            data: { ...pointsLayerProps.data,\n              attributes: rest\n            }\n          };\n        }\n\n        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers,\n          highlightedObjectIndex\n        }), pointsLayerProps));\n      }\n    }\n\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {\n      extruded\n    } = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n\n    const lineLayers = this._renderLineLayers();\n\n    const pointLayers = this._renderPointLayers();\n\n    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];\n  }\n\n  getSubLayerAccessor(accessor) {\n    const {\n      binary\n    } = this.state;\n\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {\n        data,\n        index\n      } = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      return accessor(feature, info);\n    };\n  }\n\n}\n\n_defineProperty(GeoJsonLayer, \"layerName\", 'GeoJsonLayer');\n\n_defineProperty(GeoJsonLayer, \"defaultProps\", defaultProps);","map":{"version":3,"mappings":"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","names":["CompositeLayer","replaceInRange","binaryToFeatureForAccesor","POINT_LAYER","LINE_LAYER","POLYGON_LAYER","getDefaultProps","forwardProps","getGeojsonFeatures","separateGeojsonFeatures","createLayerPropsFromFeatures","createLayerPropsFromBinary","FEATURE_TYPES","defaultProps","circle","icon","text","stroked","filled","extruded","wireframe","iconAtlas","type","value","iconMapping","getIcon","f","properties","getText","pointType","getRadius","deprecatedFor","GeoJsonLayer","initializeState","state","layerProps","features","updateState","props","changeFlags","dataChanged","data","binary","setState","_updateStateBinary","_updateStateJSON","encodePickingColor","wrapFeature","getSubLayerRow","bind","newFeatures","featuresDiff","Array","isArray","oldFeatures","key","slice","dataRange","partialFeatures","push","getIndex","__source","index","replace","getPickingInfo","params","info","sourceLayer","featureType","find","ft","id","startsWith","points","globalFeatureIds","_updateAutoHighlight","pointLayerIdPrefix","sourceIsPoints","layer","getSubLayers","updateAutoHighlight","_renderPolygonLayer","PolygonFillLayer","shouldRenderSubLayer","polygons","getSubLayerClass","forwardedProps","useLineColor","getLineColor","updateTriggers","lineColors","getSubLayerProps","_renderLineLayers","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","polygonsOutline","LineStringsLayer","lines","_renderPointLayers","highlightedObjectIndex","Number","isFinite","findIndex","d","types","Set","split","pointLayers","PointLayerMapping","PointsLayer","pointsLayerProps","instancePickingColors","rest","attributes","renderLayers","polygonFillLayer","lineLayers","getSubLayerAccessor","accessor","object","feature"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplica»õii\\earthquakes\\node_modules\\@deck.gl\\layers\\src\\geojson-layer\\geojson-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  PickingInfo,\n  Unit,\n  Material,\n  UpdateParameters,\n  _ConstructorOf,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport type {BinaryFeatures} from '@loaders.gl/schema';\nimport type {Feature} from 'geojson';\n\nimport {replaceInRange} from '../utils';\nimport {BinaryFeatureTypes, binaryToFeatureForAccesor} from './geojson-binary';\nimport {\n  POINT_LAYER,\n  LINE_LAYER,\n  POLYGON_LAYER,\n  getDefaultProps,\n  forwardProps\n} from './sub-layer-map';\n\nimport {getGeojsonFeatures, SeparatedGeometries, separateGeojsonFeatures} from './geojson';\nimport {createLayerPropsFromFeatures, createLayerPropsFromBinary} from './geojson-layer-props';\n\n/** All properties supported by GeoJsonLayer */\nexport type GeoJsonLayerProps<DataT extends Feature = Feature> = _GeoJsonLayerProps<DataT> &\n  CompositeLayerProps<DataT>;\n\n/** Properties added by GeoJsonLayer */\nexport type _GeoJsonLayerProps<DataT extends Feature = Feature> = {\n  /**\n   * How to render Point and MultiPoint features in the data.\n   *\n   * Supported types are:\n   *  * `'circle'`\n   *  * `'icon'`\n   *  * `'text'`\n   *\n   * @default 'circle'\n   */\n  pointType?: string;\n} & _GeoJsonLayerFillProps<DataT> &\n  _GeoJsonLayerStrokeProps<DataT> &\n  _GeoJsonLayer3DProps<DataT> &\n  _GeoJsonLayerPointCircleProps<DataT> &\n  _GeojsonLayerIconPointProps<DataT> &\n  _GeojsonLayerTextPointProps<DataT>;\n\n/** GeoJsonLayer fill options. */\ntype _GeoJsonLayerFillProps<DataT> = {\n  /**\n   * Whether to draw a filled polygon (solid fill).\n   *\n   * Note that only the area between the outer polygon and any holes will be filled.\n   *\n   * @default true\n   */\n  filled?: boolean;\n\n  /**\n   * Fill collor value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n};\n\n/** GeoJsonLayer stroke options. */\ntype _GeoJsonLayerStrokeProps<DataT> = {\n  /**\n   * Whether to draw an outline around the polygon (solid fill).\n   *\n   * Note that both the outer polygon as well the outlines of any holes will be drawn.\n   *\n   * @default true\n   */\n  stroked?: boolean;\n\n  /**\n   * Line color value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * Line width value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineWidth?: Accessor<DataT, number>;\n\n  /**\n   * The units of the line width, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'meters'\n   * @see Unit.\n   */\n  lineWidthUnits?: Unit;\n\n  /**\n   * A multiplier that is applied to all line widths\n   *\n   * @default 1\n   */\n  lineWidthScale?: number;\n\n  /**\n   * The minimum line width in pixels.\n   *\n   * @default 0\n   */\n  lineWidthMinPixels?: number;\n\n  /**\n   * The maximum line width in pixels\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  lineWidthMaxPixels?: number;\n\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   *\n   * @default false\n   */\n  lineJointRounded?: boolean;\n\n  /**\n   * The maximum extent of a joint in ratio to the stroke width.\n   *\n   * Only works if `lineJointRounded` is false.\n   *\n   * @default 4\n   */\n  lineMiterLimit?: number;\n\n  /**\n   * Type of line caps.\n   *\n   * If `true`, draw round caps. Otherwise draw square caps.\n   *\n   * @default false\n   */\n  lineCapRounded?: boolean;\n\n  /**\n   * If `true`, extrude the line in screen space (width always faces the camera).\n   * If `false`, the width always faces up.\n   *\n   * @default false\n   */\n  lineBillboard?: boolean;\n};\n\n/** GeoJsonLayer 3D options. */\ntype _GeoJsonLayer3DProps<DataT> = {\n  /**\n   * Extrude Polygon and MultiPolygon features along the z-axis if set to true\n   *\n   * Based on the elevations provided by the `getElevation` accessor.\n   *\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Whether to generate a line wireframe of the hexagon.\n   *\n   * @default false\n   */\n  wireframe?: boolean;\n\n  /**\n   * Elevation valur or accessor.\n   *\n   * Only used if `extruded: true`.\n   *\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n\n  /**\n   * Elevation multiplier.\n   *\n   * The final elevation is calculated by `elevationScale * getElevation(d)`.\n   * `elevationScale` is a handy property to scale all elevation without updating the data.\n   *\n   * @default 1\n   */\n  elevationScale?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies to extruded polgons.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** GeoJsonLayer Properties forwarded to `ScatterPlotLayer` if `pointType` is `'circle'` */\nexport type _GeoJsonLayerPointCircleProps<DataT> = {\n  getPointRadius?: Accessor<DataT, number>;\n  pointRadiusUnits?: Unit;\n  pointRadiusScale?: number;\n  pointRadiusMinPixels?: number;\n  pointRadiusMaxPixels?: number;\n  pointAntialiasing?: boolean;\n  pointBillboard?: boolean;\n\n  /** @deprecated use getPointRadius */\n  getRadius?: Accessor<DataT, number>;\n};\n\n/** GeoJsonLayer properties forwarded to `IconLayer` if `pointType` is `'icon'` */\ntype _GeojsonLayerIconPointProps<DataT> = {\n  iconAtlas?: any;\n  iconMapping?: any;\n  getIcon?: Accessor<DataT, any>;\n  getIconSize?: Accessor<DataT, number>;\n  getIconColor?: Accessor<DataT, Color>;\n  getIconAngle?: Accessor<DataT, number>;\n  getIconPixelOffset?: Accessor<DataT, number[]>;\n  iconSizeUnits?: Unit;\n  iconSizeScale?: number;\n  iconSizeMinPixels?: number;\n  iconSizeMaxPixels?: number;\n  iconBillboard?: boolean;\n  iconAlphaCutoff?: number;\n};\n\n/** GeoJsonLayer properties forwarded to `TextLayer` if `pointType` is `'text'` */\ntype _GeojsonLayerTextPointProps<DataT> = {\n  getText?: Accessor<DataT, any>;\n  getTextColor?: Accessor<DataT, Color>;\n  getTextAngle?: Accessor<DataT, number>;\n  getTextSize?: Accessor<DataT, number>;\n  getTextAnchor?: Accessor<DataT, string>;\n  getTextAlignmentBaseline?: Accessor<DataT, string>;\n  getTextPixelOffset?: Accessor<DataT, number[]>;\n  getTextBackgroundColor?: Accessor<DataT, Color>;\n  getTextBorderColor?: Accessor<DataT, Color>;\n  getTextBorderWidth?: Accessor<DataT, number>;\n  textSizeUnits?: Unit;\n  textSizeScale?: number;\n  textSizeMinPixels?: number;\n  textSizeMaxPixels?: number;\n  textCharacterSet?: any;\n  textFontFamily?: string;\n  textFontWeight?: number;\n  textLineHeight?: number;\n  textMaxWidth?: number;\n  textWordBreak?: string; // TODO\n  textBackground?: boolean;\n  textBackgroundPadding?: number[];\n  textOutlineColor?: Color;\n  textOutlineWidth?: number;\n  textBillboard?: boolean;\n  textFontSettings?: any;\n};\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nconst defaultProps: DefaultProps<GeoJsonLayerProps> = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {type: 'object', value: null},\n  iconMapping: {type: 'object', value: {}},\n  getIcon: {type: 'accessor', value: f => f.properties.icon},\n  getText: {type: 'accessor', value: f => f.properties.text},\n\n  // Self props\n  pointType: 'circle',\n\n  // TODO: deprecated, remove in v9\n  getRadius: {deprecatedFor: 'getPointRadius'}\n};\n\ntype GeoJsonPickingInfo = PickingInfo & {\n  featureType?: string | null;\n  info?: any;\n};\n\n/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */\nexport default class GeoJsonLayer<\n  DataT extends Feature = Feature,\n  ExtraProps = {}\n> extends CompositeLayer<Required<GeoJsonLayerProps<DataT>> & ExtraProps> {\n  static layerName = 'GeoJsonLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary =\n      data && 'points' in (data as {}) && 'polygons' in (data as {}) && 'lines' in (data as {});\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  private _updateStateBinary({props, changeFlags}): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  private _updateStateJSON({props, changeFlags}): void {\n    const features: Feature[] = getGeojsonFeatures(props.data) as any;\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures: SeparatedGeometries = {} as SeparatedGeometries;\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params): GeoJsonPickingInfo {\n    const info = super.getPickingInfo(params) as GeoJsonPickingInfo;\n    const {index, sourceLayer} = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer!.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer!.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = (this.props.data as BinaryFeatures).points!.globalFeatureIds.value[index];\n    }\n    return info;\n  }\n\n  _updateAutoHighlight(info: GeoJsonPickingInfo): void {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  private _renderPolygonLayer(): Layer | null {\n    const {extruded, wireframe} = this.props;\n    const {layerProps} = this.state;\n    const id = 'polygons-fill';\n\n    const PolygonFillLayer =\n      this.shouldRenderSubLayer(id, layerProps.polygons.data) &&\n      this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n\n      return new PolygonFillLayer(\n        forwardedProps,\n        this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers\n        }),\n        layerProps.polygons\n      );\n    }\n    return null;\n  }\n\n  private _renderLineLayers(): (Layer | false)[] | null {\n    const {extruded, stroked} = this.props;\n    const {layerProps} = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.lines\n          )\n      ];\n    }\n    return null;\n  }\n\n  private _renderPointLayers(): Layer[] | null {\n    const {pointType} = this.props;\n    const {layerProps, binary} = this.state;\n    let {highlightedObjectIndex} = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(\n        d => d.__source.index === highlightedObjectIndex\n      );\n    }\n\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers: Layer[] = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer: _ConstructorOf<Layer> =\n        PointLayerMapping &&\n        this.shouldRenderSubLayer(id, layerProps.points.data) &&\n        this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const {instancePickingColors, ...rest} = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            data: {...pointsLayerProps.data, attributes: rest}\n          };\n        }\n\n        pointLayers.push(\n          new PointsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex\n            }),\n            pointsLayerProps\n          )\n        );\n      }\n    }\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {extruded} = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      lineLayers,\n      pointLayers,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data as unknown as BinaryFeatureTypes, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor(feature, info);\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}