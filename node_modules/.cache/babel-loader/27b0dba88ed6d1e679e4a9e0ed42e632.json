{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { hasFeature, FEATURES, Buffer } from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport { glArrayFromType } from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport { toDoublePrecisionArray } from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  const stride = getStride(baseAccessor);\n  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);\n  return { ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: { ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport default class DataColumn {\n  constructor(gl, opts, state) {\n    _defineProperty(this, \"gl\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"size\", void 0);\n\n    _defineProperty(this, \"settings\", void 0);\n\n    _defineProperty(this, \"value\", void 0);\n\n    _defineProperty(this, \"doublePrecision\", void 0);\n\n    _defineProperty(this, \"_buffer\", void 0);\n\n    _defineProperty(this, \"state\", void 0);\n\n    this.gl = gl;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === 5130;\n    let {\n      defaultValue\n    } = opts;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    let bufferType;\n\n    if (doublePrecision) {\n      bufferType = 5126;\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;\n    } else {\n      bufferType = logicalType || 5126;\n    }\n\n    let defaultType = glArrayFromType(logicalType || bufferType || 5126);\n    this.doublePrecision = doublePrecision;\n\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    this.value = null;\n    this.settings = { ...opts,\n      defaultType,\n      defaultValue: defaultValue,\n      logicalType,\n      type: bufferType,\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = { ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n    this._buffer = null;\n  }\n\n  get isConstant() {\n    return this.state.constant;\n  }\n\n  get buffer() {\n    if (!this._buffer) {\n      const {\n        isIndexed,\n        type\n      } = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? 34963 : 34962,\n        accessor: {\n          type\n        }\n      });\n    }\n\n    return this._buffer;\n  }\n\n  get byteOffset() {\n    const accessor = this.getAccessor();\n\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n\n    return 0;\n  }\n\n  get numInstances() {\n    return this.state.numInstances;\n  }\n\n  set numInstances(n) {\n    this.state.numInstances = n;\n  }\n\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n\n      this._buffer = null;\n    }\n\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(id, options) {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[\"\".concat(id, \"64Low\")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);\n      return shaderAttributes;\n    }\n\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {\n        [id]: new ShaderAttribute(this, shaderAttributeDef)\n      };\n    }\n\n    return {\n      [id]: this\n    };\n  }\n\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue() {\n    if (this.state.constant) {\n      return this.value;\n    }\n\n    return [this.getBuffer(), this.getAccessor()];\n  }\n\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n\n  getBounds() {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n\n    let result = null;\n\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {\n        value,\n        numInstances,\n        size\n      } = this;\n      const len = numInstances * size;\n\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n\n        for (let i = 0; i < len;) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n\n        result = [min, max];\n      }\n    }\n\n    this.state.bounds = result;\n    return result;\n  }\n\n  setData(data) {\n    const {\n      state\n    } = this;\n    let opts;\n\n    if (ArrayBuffer.isView(data)) {\n      opts = {\n        value: data\n      };\n    } else if (data instanceof Buffer) {\n      opts = {\n        buffer: data\n      };\n    } else {\n      opts = data;\n    }\n\n    const accessor = { ...this.settings,\n      ...opts\n    };\n    state.bufferAccessor = accessor;\n    state.bounds = null;\n\n    if (opts.constant) {\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n      accessor.type = opts.type || buffer.accessor.type;\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n      const {\n        buffer,\n        byteOffset\n      } = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n\n      buffer.setAccessor(null);\n      buffer.subData({\n        data: value,\n        offset: byteOffset\n      });\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.state.bounds = null;\n    const value = this.value;\n    const {\n      startOffset = 0,\n      endOffset\n    } = opts;\n    this.buffer.subData({\n      data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n        size: this.size,\n        startIndex: startOffset,\n        endIndex: endOffset\n      }) : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate(numInstances) {\n    let copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      state\n    } = this;\n    const oldValue = state.allocatedValue;\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n    this.value = value;\n    const {\n      buffer,\n      byteOffset\n    } = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        buffer.subData({\n          data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  _checkExternalBuffer(opts) {\n    const {\n      value\n    } = opts;\n\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(\"Attribute \".concat(this.id, \" value is not TypedArray\"));\n    }\n\n    const ArrayType = this.settings.defaultType;\n    let illegalArrayType = false;\n\n    if (this.doublePrecision) {\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n\n    if (illegalArrayType) {\n      throw new Error(\"Attribute \".concat(this.id, \" does not support \").concat(value.constructor.name));\n    }\n\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(\"Attribute \".concat(this.id, \" is normalized\"))();\n    }\n  }\n\n  normalizeConstant(value) {\n    switch (this.settings.type) {\n      case 5120:\n        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);\n\n      case 5122:\n        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);\n\n      case 5121:\n        return new Float32Array(value).map(x => x / 255);\n\n      case 5123:\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        return value;\n    }\n  }\n\n  _normalizeValue(value, out, start) {\n    const {\n      defaultValue,\n      size\n    } = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        let i = size;\n\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n\n    }\n\n    return out;\n  }\n\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    const {\n      size\n    } = this;\n\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["hasFeature","FEATURES","Buffer","ShaderAttribute","glArrayFromType","typedArrayManager","toDoublePrecisionArray","log","getStride","accessor","stride","size","bytesPerElement","resolveShaderAttribute","baseAccessor","shaderAttributeOptions","offset","removed","vertexOffset","undefined","elementOffset","resolveDoublePrecisionShaderAttributes","resolvedOptions","high","low","DataColumn","constructor","gl","opts","state","_defineProperty","id","logicalType","type","doublePrecision","defaultValue","Number","isFinite","Array","fill","bufferType","isIndexed","ELEMENT_INDEX_UINT32","defaultType","fp64","Float32Array","value","settings","BYTES_PER_ELEMENT","externalBuffer","bufferAccessor","allocatedValue","numInstances","bounds","constant","_buffer","isConstant","buffer","target","byteOffset","getAccessor","n","delete","release","getShaderAttributes","options","shaderAttributes","isBuffer64Bit","Float64Array","doubleShaderAttributeDefs","shaderAttributeDef","getBuffer","getValue","getBounds","result","min","from","len","length","Infinity","max","i","j","v","setData","data","ArrayBuffer","isView","_normalizeValue","normalized","normalizeConstant","hasChanged","_areValuesEqual","_checkExternalBuffer","requiredBufferSize","byteLength","reallocate","setAccessor","subData","updateSubBuffer","startOffset","endOffset","startIndex","endIndex","subarray","allocate","copy","oldValue","Error","ArrayType","illegalArrayType","name","warn","map","x","out","start","value1","value2"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@deck.gl\\core\\src\\lib\\attribute\\data-column.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport GL from '@luma.gl/constants';\nimport {hasFeature, FEATURES, Buffer} from '@luma.gl/core';\nimport ShaderAttribute, {IShaderAttribute} from './shader-attribute';\nimport {glArrayFromType} from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport {toDoublePrecisionArray} from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nimport type {Buffer as LumaBuffer} from '@luma.gl/webgl';\nimport type {TypedArray, NumericArray, TypedArrayConstructor} from '../../types/types';\n\nexport type BufferAccessor = {\n  /** A WebGL data type, see [vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer#parameters). */\n  type?: number;\n  /** The number of elements per vertex attribute. */\n  size?: number;\n  /** 1 if instanced. */\n  divisor?: number;\n  /** Offset of the first vertex attribute into the buffer, in bytes. */\n  offset?: number;\n  /** The offset between the beginning of consecutive vertex attributes, in bytes. */\n  stride?: number;\n  /** Whether data values should be normalized. Note that all color attributes in deck.gl layers are normalized by default. */\n  normalized?: boolean;\n  integer?: boolean;\n};\n\nexport type ShaderAttributeOptions = Partial<BufferAccessor> & {\n  offset: number;\n  stride: number;\n  vertexOffset?: number;\n  elementOffset?: number;\n};\n\nfunction getStride(accessor: DataColumnSettings<any>): number {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): ShaderAttributeOptions {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset =\n    shaderAttributeOptions.vertexOffset !== undefined\n      ? shaderAttributeOptions.vertexOffset\n      : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n    // offsets defined by the attribute\n    vertexOffset * stride +\n    elementOffset * baseAccessor.bytesPerElement +\n    // offsets defined by external buffers if any\n    (baseAccessor.offset || 0);\n\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): {\n  high: ShaderAttributeOptions;\n  low: ShaderAttributeOptions;\n} {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport type DataColumnOptions<Options> = Options &\n  BufferAccessor & {\n    id?: string;\n    vertexOffset?: number;\n    fp64?: boolean;\n    logicalType?: number;\n    isIndexed?: boolean;\n    defaultValue?: number | number[];\n  };\n\ntype DataColumnSettings<Options> = DataColumnOptions<Options> & {\n  type: number;\n  size: number;\n  logicalType?: number;\n  bytesPerElement: number;\n  defaultValue: number[];\n  defaultType: TypedArrayConstructor;\n};\n\ntype DataColumnInternalState<Options, State> = State & {\n  externalBuffer: LumaBuffer | null;\n  bufferAccessor: DataColumnSettings<Options>;\n  allocatedValue: TypedArray | null;\n  numInstances: number;\n  bounds: [number[], number[]] | null;\n  constant: boolean;\n};\n\nexport default class DataColumn<Options, State> implements IShaderAttribute {\n  gl: WebGLRenderingContext;\n  id: string;\n  size: number;\n  settings: DataColumnSettings<Options>;\n  value: NumericArray | null;\n  doublePrecision: boolean;\n\n  protected _buffer: LumaBuffer | null;\n  protected state: DataColumnInternalState<Options, State>;\n\n  /* eslint-disable max-statements */\n  constructor(gl: WebGLRenderingContext, opts: DataColumnOptions<Options>, state: State) {\n    this.gl = gl;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === GL.DOUBLE;\n\n    let {defaultValue} = opts;\n    defaultValue = Number.isFinite(defaultValue)\n      ? [defaultValue]\n      : defaultValue || new Array(this.size).fill(0);\n\n    let bufferType: number;\n    if (doublePrecision) {\n      bufferType = GL.FLOAT;\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType =\n        gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? GL.UNSIGNED_INT : GL.UNSIGNED_SHORT;\n    } else {\n      bufferType = logicalType || GL.FLOAT;\n    }\n\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = glArrayFromType(logicalType || bufferType || GL.FLOAT);\n    this.doublePrecision = doublePrecision;\n\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    this.value = null;\n    this.settings = {\n      ...opts,\n      defaultType,\n      defaultValue: defaultValue as number[],\n      logicalType,\n      type: bufferType,\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = {\n      ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n    this._buffer = null;\n  }\n  /* eslint-enable max-statements */\n\n  get isConstant(): boolean {\n    return this.state.constant;\n  }\n\n  get buffer(): LumaBuffer {\n    if (!this._buffer) {\n      const {isIndexed, type} = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,\n        accessor: {type}\n      }) as LumaBuffer;\n    }\n    return this._buffer;\n  }\n\n  get byteOffset(): number {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n\n  get numInstances(): number {\n    return this.state.numInstances;\n  }\n\n  set numInstances(n: number) {\n    this.state.numInstances = n;\n  }\n\n  delete(): void {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(\n    id: string,\n    options: Partial<ShaderAttributeOptions> | null\n  ): Record<string, IShaderAttribute> {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(\n        this.getAccessor(),\n        options || {}\n      );\n\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[`${id}64Low`] = isBuffer64Bit\n        ? new ShaderAttribute(this, doubleShaderAttributeDefs.low)\n        : new Float32Array(this.size); // use constant for low part if buffer is 32-bit\n      return shaderAttributes;\n    }\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {[id]: new ShaderAttribute(this, shaderAttributeDef)};\n    }\n    return {[id]: this};\n  }\n\n  getBuffer(): LumaBuffer | null {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue(): [LumaBuffer, BufferAccessor] | NumericArray | null {\n    if (this.state.constant) {\n      return this.value;\n    }\n    return [this.getBuffer() as LumaBuffer, this.getAccessor() as BufferAccessor];\n  }\n\n  getAccessor(): DataColumnSettings<Options> {\n    return this.state.bufferAccessor;\n  }\n\n  // Returns [min: Array(size), max: Array(size)]\n  /* eslint-disable max-depth */\n  getBounds(): [number[], number[]] | null {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n    let result: [number[], number[]] | null = null;\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {value, numInstances, size} = this;\n      const len = numInstances * size;\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n        for (let i = 0; i < len; ) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n        result = [min, max];\n      }\n    }\n    this.state.bounds = result;\n    return result;\n  }\n\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(\n    data:\n      | TypedArray\n      | LumaBuffer\n      | ({\n          constant?: boolean;\n          value?: NumericArray;\n          buffer?: LumaBuffer;\n        } & Partial<BufferAccessor>)\n  ): boolean {\n    const {state} = this;\n\n    let opts: {\n      constant?: boolean;\n      value?: NumericArray;\n      buffer?: LumaBuffer;\n    } & Partial<BufferAccessor>;\n    if (ArrayBuffer.isView(data)) {\n      opts = {value: data};\n    } else if (data instanceof Buffer) {\n      opts = {buffer: data as LumaBuffer};\n    } else {\n      opts = data;\n    }\n\n    const accessor: DataColumnSettings<Options> = {...this.settings, ...opts};\n    state.bufferAccessor = accessor;\n    state.bounds = null; // clear cached bounds\n\n    if (opts.constant) {\n      // set constant\n      let value = opts.value as NumericArray;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n\n      // Copy the type of the buffer into the accessor\n      // @ts-ignore\n      accessor.type = opts.type || buffer.accessor.type;\n      // @ts-ignore\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value as TypedArray;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n\n      const {buffer, byteOffset} = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n\n      // A small over allocation is used as safety margin\n      // Shader attributes may try to access this buffer with bigger offsets\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n      // Hack: force Buffer to infer data type\n      buffer.setAccessor(null);\n      buffer.subData({data: value, offset: byteOffset});\n      // @ts-ignore\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(\n    opts: {\n      startOffset?: number;\n      endOffset?: number;\n    } = {}\n  ): void {\n    this.state.bounds = null; // clear cached bounds\n\n    const value = this.value as TypedArray;\n    const {startOffset = 0, endOffset} = opts;\n    this.buffer.subData({\n      data:\n        this.doublePrecision && value instanceof Float64Array\n          ? toDoublePrecisionArray(value, {\n              size: this.size,\n              startIndex: startOffset,\n              endIndex: endOffset\n            })\n          : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate(numInstances: number, copy: boolean = false): boolean {\n    const {state} = this;\n    const oldValue = state.allocatedValue;\n\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n\n    this.value = value;\n\n    const {buffer, byteOffset} = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.subData({\n          data:\n            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  // PRIVATE HELPER METHODS\n  protected _checkExternalBuffer(opts: {value?: NumericArray; normalized?: boolean}): void {\n    const {value} = opts;\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(`Attribute ${this.id} value is not TypedArray`);\n    }\n    const ArrayType = this.settings.defaultType;\n\n    let illegalArrayType = false;\n    if (this.doublePrecision) {\n      // not 32bit or 64bit\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n    if (illegalArrayType) {\n      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n    }\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(`Attribute ${this.id} is normalized`)();\n    }\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  normalizeConstant(value: NumericArray): NumericArray {\n    switch (this.settings.type) {\n      case GL.BYTE:\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n\n      case GL.SHORT:\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n\n      case GL.UNSIGNED_BYTE:\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n\n      case GL.UNSIGNED_SHORT:\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n\n  /* check user supplied values and apply fallback */\n  protected _normalizeValue(value: any, out: NumericArray, start: number): NumericArray {\n    const {defaultValue, size} = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n\n    return out;\n  }\n\n  protected _areValuesEqual(value1: any, value2: any): boolean {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {size} = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}