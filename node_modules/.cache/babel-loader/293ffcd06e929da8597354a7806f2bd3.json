{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, _flatten as flatten } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport Tileset2D, { STRATEGY_DEFAULT } from './tileset-2d';\nimport { urlType, getURLFromTemplate } from './utils';\nconst defaultProps = {\n  TilesetClass: Tileset2D,\n  data: {\n    type: 'data',\n    value: []\n  },\n  dataComparator: urlType.equals,\n  renderSubLayers: {\n    type: 'function',\n    value: props => new GeoJsonLayer(props),\n    compare: false\n  },\n  getTileData: {\n    type: 'function',\n    optional: true,\n    value: null,\n    compare: false\n  },\n  onViewportLoad: {\n    type: 'function',\n    optional: true,\n    value: null,\n    compare: false\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tile => {},\n    compare: false\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tile => {},\n    compare: false\n  },\n  onTileError: {\n    type: 'function',\n    value: err => console.error(err),\n    compare: false\n  },\n  extent: {\n    type: 'array',\n    optional: true,\n    value: null,\n    compare: true\n  },\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0\n};\nexport default class TileLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n\n  finalizeState() {\n    var _this$state, _this$state$tileset;\n\n    (_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$tileset = _this$state.tileset) === null || _this$state$tileset === void 0 ? void 0 : _this$state$tileset.finalize();\n  }\n\n  get isLoaded() {\n    var _this$state2, _this$state2$tileset;\n\n    return (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : (_this$state2$tileset = _this$state2.tileset) === null || _this$state2$tileset === void 0 ? void 0 : _this$state2$tileset.selectedTiles.every(tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded));\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(_ref2) {\n    let {\n      changeFlags\n    } = _ref2;\n    let {\n      tileset\n    } = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);\n\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({\n        tileset\n      });\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n\n      if (dataChanged) {\n        tileset.reloadAll();\n      } else {\n        this.state.tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n\n    this._updateTileset();\n  }\n\n  _getTilesetOptions() {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      zoomOffset\n    } = this.props;\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      zoomOffset,\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n\n  _updateTileset() {\n    const {\n      tileset\n    } = this.state;\n    const {\n      zRange,\n      modelMatrix\n    } = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {\n      zRange,\n      modelMatrix\n    });\n    const {\n      isLoaded\n    } = tileset;\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n\n    if (tilesetChanged) {\n      this.setState({\n        frameNumber\n      });\n    }\n\n    this.state.isLoaded = isLoaded;\n  }\n\n  _onViewportLoad() {\n    const {\n      tileset\n    } = this.state;\n    const {\n      onViewportLoad\n    } = this.props;\n\n    if (onViewportLoad) {\n      onViewportLoad(tileset.selectedTiles);\n    }\n  }\n\n  _onTileLoad(tile) {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n\n  _onTileError(error, tile) {\n    this.props.onTileError(error);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tile) {\n    this.props.onTileUnload(tile);\n  }\n\n  getTileData(tile) {\n    const {\n      data,\n      getTileData,\n      fetch\n    } = this.props;\n    const {\n      signal\n    } = tile;\n    tile.url = typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n\n    if (getTileData) {\n      return getTileData(tile);\n    }\n\n    if (fetch && tile.url) {\n      return fetch(tile.url, {\n        propName: 'data',\n        layer: this,\n        signal\n      });\n    }\n\n    return null;\n  }\n\n  renderSubLayers(props) {\n    return this.props.renderSubLayers(props);\n  }\n\n  getSubLayerPropsByTile(tile) {\n    return null;\n  }\n\n  getPickingInfo(_ref3) {\n    let {\n      info,\n      sourceLayer\n    } = _ref3;\n    info.tile = sourceLayer.props.tile;\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    if (info.sourceLayer) {\n      info.sourceLayer.updateAutoHighlight(info);\n    }\n  }\n\n  renderLayers() {\n    return this.state.tileset.tiles.map(tile => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n\n      if (!tile.isLoaded && !tile.content) {} else if (!tile.layers) {\n        const layers = this.renderSubLayers({ ...this.props,\n          id: \"\".concat(this.id, \"-\").concat(tile.id),\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = flatten(layers, Boolean).map(layer => layer.clone({\n          tile,\n          ...subLayerProps\n        }));\n      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some(propName => tile.layers[0].props[propName] !== subLayerProps[propName])) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n\n      return tile.layers;\n    });\n  }\n\n  filterSubLayer(_ref4) {\n    let {\n      layer,\n      cullRect\n    } = _ref4;\n    const {\n      tile\n    } = layer.props;\n    return this.state.tileset.isTileVisible(tile, cullRect);\n  }\n\n}\n\n_defineProperty(TileLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(TileLayer, \"layerName\", 'TileLayer');","map":{"version":3,"mappings":"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","names":["CompositeLayer","_flatten","flatten","GeoJsonLayer","Tileset2D","STRATEGY_DEFAULT","urlType","getURLFromTemplate","defaultProps","TilesetClass","data","type","value","dataComparator","equals","renderSubLayers","props","compare","getTileData","optional","onViewportLoad","onTileLoad","tile","onTileUnload","onTileError","err","console","error","extent","tileSize","maxZoom","minZoom","maxCacheSize","maxCacheByteSize","refinementStrategy","zRange","maxRequests","zoomOffset","TileLayer","initializeState","state","tileset","isLoaded","finalizeState","finalize","_this$state2","_this$state2$tileset","selectedTiles","every","layers","layer","shouldUpdateState","changeFlags","somethingChanged","updateState","propsChanged","propsOrDataChanged","updateTriggersChanged","dataChanged","all","_getTilesetOptions","setState","setOptions","reloadAll","tiles","forEach","_updateTileset","bind","_onTileLoad","_onTileError","_onTileUnload","modelMatrix","frameNumber","update","context","viewport","loadingStateChanged","tilesetChanged","_onViewportLoad","setNeedsUpdate","fetch","signal","url","Array","isArray","propName","getSubLayerPropsByTile","getPickingInfo","info","sourceLayer","_updateAutoHighlight","updateAutoHighlight","renderLayers","map","subLayerProps","content","id","_offset","Boolean","clone","Object","keys","some","filterSubLayer","cullRect","isTileVisible"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@deck.gl\\geo-layers\\src\\tile-layer\\tile-layer.ts"],"sourcesContent":["import {\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  LayerProps,\n  UpdateParameters,\n  PickingInfo,\n  GetPickingInfoParams,\n  DefaultProps,\n  FilterContext,\n  _flatten as flatten\n} from '@deck.gl/core';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {LayersList} from '@deck.gl/core';\nimport Tile2DHeader from './tile-2d-header';\n\nimport Tileset2D, {RefinementStrategy, STRATEGY_DEFAULT, Tileset2DProps} from './tileset-2d';\nimport {TileLoadProps, ZRange} from './types';\nimport {urlType, getURLFromTemplate} from './utils';\n\nconst defaultProps: DefaultProps<TileLayerProps> = {\n  TilesetClass: Tileset2D,\n  data: {type: 'data', value: []},\n  dataComparator: urlType.equals,\n  renderSubLayers: {type: 'function', value: props => new GeoJsonLayer(props), compare: false},\n  getTileData: {type: 'function', optional: true, value: null, compare: false},\n  // TODO - change to onViewportLoad to align with Tile3DLayer\n  onViewportLoad: {type: 'function', optional: true, value: null, compare: false},\n  onTileLoad: {type: 'function', value: tile => {}, compare: false},\n  onTileUnload: {type: 'function', value: tile => {}, compare: false},\n  // eslint-disable-next-line\n  onTileError: {type: 'function', value: err => console.error(err), compare: false},\n  extent: {type: 'array', optional: true, value: null, compare: true},\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0\n};\n\n/** All props supported by the TileLayer */\nexport type TileLayerProps<DataT = any> = CompositeLayerProps<any> & _TileLayerProps<DataT>;\n\n/** Props added by the TileLayer */\ntype _TileLayerProps<DataT> = {\n  /**\n   * Optionally implement a custom indexing scheme.\n   */\n  TilesetClass: typeof Tileset2D;\n  /**\n   * Renders one or an array of Layer instances.\n   */\n  renderSubLayers?: (\n    props: TileLayerProps<DataT> & {\n      id: string;\n      data: DataT;\n      _offset: number;\n      tile: Tile2DHeader<DataT>;\n    }\n  ) => Layer | null | LayersList;\n  /**\n   * If supplied, `getTileData` is called to retrieve the data of each tile.\n   */\n  getTileData?: ((props: TileLoadProps) => Promise<DataT> | DataT) | null;\n\n  /** Called when all tiles in the current viewport are loaded. */\n  onViewportLoad?: ((tiles: Tile2DHeader<DataT>[]) => void) | null;\n\n  /** Called when a tile successfully loads. */\n  onTileLoad?: (tile: Tile2DHeader<DataT>) => void;\n\n  /** Called when a tile is cleared from cache. */\n  onTileUnload?: (tile: Tile2DHeader<DataT>) => void;\n\n  /** Called when a tile failed to load. */\n  onTileError?: (err: any) => void;\n\n  /** The bounding box of the layer's data. */\n  extent?: number[] | null;\n\n  /** The pixel dimension of the tiles, usually a power of 2. */\n  tileSize?: number;\n\n  /** The max zoom level of the layer's data.\n   * @default null\n   */\n  maxZoom?: number | null;\n\n  /** The min zoom level of the layer's data.\n   * @default 0\n   */\n  minZoom?: number | null;\n\n  /** The maximum number of tiles that can be cached. */\n  maxCacheSize?: number | null;\n\n  /**\n   * The maximum memory used for caching tiles.\n   *\n   * @default null\n   */\n  maxCacheByteSize?: number | null;\n\n  /**\n   * How the tile layer refines the visibility of tiles.\n   *\n   * @default 'best-available'\n   */\n  refinementStrategy?: RefinementStrategy;\n\n  /** Range of minimum and maximum heights in the tile. */\n  zRange?: ZRange | null;\n\n  /**\n   * The maximum number of concurrent getTileData calls.\n   *\n   * @default 6\n   */\n  maxRequests?: number;\n\n  /**\n   * This offset changes the zoom level at which the tiles are fetched.\n   *\n   * Needs to be an integer.\n   *\n   * @default 0\n   */\n  zoomOffset?: number;\n};\n\nexport type TiledPickingInfo<DataT = any> = PickingInfo & {\n  tile?: Tile2DHeader<DataT>;\n};\n\n/**\n * The TileLayer is a composite layer that makes it possible to visualize very large datasets.\n *\n * Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport.\n */\nexport default class TileLayer<DataT = any, ExtraPropsT = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_TileLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps as any;\n  static layerName = 'TileLayer';\n\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n\n  finalizeState() {\n    this.state?.tileset?.finalize();\n  }\n\n  get isLoaded(): boolean {\n    return this.state?.tileset?.selectedTiles.every(\n      tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded)\n    );\n  }\n\n  shouldUpdateState({changeFlags}): boolean {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({changeFlags}: UpdateParameters<this>) {\n    let {tileset} = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData));\n\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({tileset});\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n\n      if (dataChanged) {\n        // reload all tiles\n        // use cached layers until new content is loaded\n        tileset.reloadAll();\n      } else {\n        // some render options changed, regenerate sub layers now\n        this.state.tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n\n    this._updateTileset();\n  }\n\n  _getTilesetOptions(): Tileset2DProps {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      zoomOffset\n    } = this.props;\n\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      zoomOffset,\n\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n\n  private _updateTileset(): void {\n    const {tileset} = this.state;\n    const {zRange, modelMatrix} = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {zRange, modelMatrix});\n    const {isLoaded} = tileset;\n\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n\n    if (tilesetChanged) {\n      // Save the tileset frame number - trigger a rerender\n      this.setState({frameNumber});\n    }\n    // Save the loaded state - should not trigger a rerender\n    this.state.isLoaded = isLoaded;\n  }\n\n  _onViewportLoad(): void {\n    const {tileset} = this.state;\n    const {onViewportLoad} = this.props;\n\n    if (onViewportLoad) {\n      onViewportLoad(tileset.selectedTiles);\n    }\n  }\n\n  _onTileLoad(tile: Tile2DHeader<DataT>): void {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileError(error: any, tile: Tile2DHeader<DataT>) {\n    this.props.onTileError(error);\n    tile.layers = null;\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tile: Tile2DHeader<DataT>) {\n    this.props.onTileUnload(tile);\n  }\n\n  // Methods for subclass to override\n\n  getTileData(tile: TileLoadProps): Promise<DataT> | DataT | null {\n    const {data, getTileData, fetch} = this.props;\n    const {signal} = tile;\n\n    tile.url =\n      typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (fetch && tile.url) {\n      return fetch(tile.url, {propName: 'data', layer: this, signal});\n    }\n    return null;\n  }\n\n  renderSubLayers(\n    props: TileLayer['props'] & {\n      id: string;\n      data: DataT;\n      _offset: number;\n      tile: Tile2DHeader<DataT>;\n    }\n  ): Layer | null | LayersList {\n    return this.props.renderSubLayers(props);\n  }\n\n  getSubLayerPropsByTile(tile: Tile2DHeader): Partial<LayerProps> | null {\n    return null;\n  }\n\n  getPickingInfo({info, sourceLayer}: GetPickingInfoParams): TiledPickingInfo<DataT> {\n    (info as any).tile = (sourceLayer as any).props.tile;\n    return info;\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    if (info.sourceLayer) {\n      info.sourceLayer.updateAutoHighlight(info);\n    }\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    return this.state.tileset.tiles.map((tile: Tile2DHeader) => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n      // cache the rendered layer in the tile\n      if (!tile.isLoaded && !tile.content) {\n        // nothing to show\n      } else if (!tile.layers) {\n        const layers = this.renderSubLayers({\n          ...this.props,\n          id: `${this.id}-${tile.id}`,\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = (flatten(layers, Boolean) as Layer<{tile?: Tile2DHeader}>[]).map(layer =>\n          layer.clone({\n            tile,\n            ...subLayerProps\n          })\n        );\n      } else if (\n        subLayerProps &&\n        tile.layers[0] &&\n        Object.keys(subLayerProps).some(\n          propName => tile.layers![0].props[propName] !== subLayerProps[propName]\n        )\n      ) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n      return tile.layers;\n    });\n  }\n\n  filterSubLayer({layer, cullRect}: FilterContext) {\n    const {tile} = (layer as Layer<{tile: Tile2DHeader}>).props;\n    return this.state.tileset.isTileVisible(tile, cullRect);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}