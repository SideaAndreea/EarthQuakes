{"ast":null,"code":"import { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\nexport default function parseMVT(arrayBuffer, options) {\n  var _options$gis, _options$mvt;\n\n  const mvtOptions = normalizeOptions(options);\n  const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$mvt = options.mvt) === null || _options$mvt === void 0 ? void 0 : _options$mvt.shape);\n\n  switch (shape) {\n    case 'columnar-table':\n      return {\n        shape: 'columnar-table',\n        data: parseToBinary(arrayBuffer, mvtOptions)\n      };\n\n    case 'geojson-row-table':\n      {\n        const table = {\n          shape: 'geojson-row-table',\n          data: parseToGeojson(arrayBuffer, mvtOptions)\n        };\n        return table;\n      }\n\n    case 'geojson':\n      return parseToGeojson(arrayBuffer, mvtOptions);\n\n    case 'binary-geometry':\n      return parseToBinary(arrayBuffer, mvtOptions);\n\n    case 'binary':\n      return parseToBinary(arrayBuffer, mvtOptions);\n\n    default:\n      throw new Error(shape);\n  }\n}\n\nfunction parseToBinary(arrayBuffer, options) {\n  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n  binaryData.byteLength = arrayBuffer.byteLength;\n  return binaryData;\n}\n\nfunction parseToFlatGeoJson(arrayBuffer, options) {\n  const features = [];\n  const geometryInfo = {\n    coordLength: 2,\n    pointPositionsCount: 0,\n    pointFeaturesCount: 0,\n    linePositionsCount: 0,\n    linePathsCount: 0,\n    lineFeaturesCount: 0,\n    polygonPositionsCount: 0,\n    polygonObjectsCount: 0,\n    polygonRingsCount: 0,\n    polygonFeaturesCount: 0\n  };\n\n  if (arrayBuffer.byteLength <= 0) {\n    return [features, geometryInfo];\n  }\n\n  const tile = new BinaryVectorTile(new Protobuf(arrayBuffer));\n  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(layerName => {\n    const vectorTileLayer = tile.layers[layerName];\n\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.feature(i, geometryInfo);\n      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return [features, geometryInfo];\n}\n\nfunction parseToGeojson(arrayBuffer, options) {\n  if (arrayBuffer.byteLength <= 0) {\n    return [];\n  }\n\n  const features = [];\n  const tile = new VectorTile(new Protobuf(arrayBuffer));\n  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(layerName => {\n    const vectorTileLayer = tile.layers[layerName];\n\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.feature(i);\n      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return features;\n}\n\nfunction normalizeOptions(options) {\n  var _options$mvt2;\n\n  if (!(options !== null && options !== void 0 && options.mvt)) {\n    throw new Error('mvt options required');\n  }\n\n  const wgs84Coordinates = ((_options$mvt2 = options.mvt) === null || _options$mvt2 === void 0 ? void 0 : _options$mvt2.coordinates) === 'wgs84';\n  const {\n    tileIndex\n  } = options.mvt;\n  const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n  }\n\n  return options.mvt;\n}\n\nfunction getDecodedFeature(feature, options, layerName) {\n  const decodedFeature = feature.toGeoJSON(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates);\n\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction getDecodedFeatureBinary(feature, options, layerName) {\n  const decodedFeature = feature.toBinaryCoordinates(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary);\n\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction transformToLocalCoordinates(line, feature) {\n  const {\n    extent\n  } = feature;\n\n  for (let i = 0; i < line.length; i++) {\n    const p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data, feature) {\n  const {\n    extent\n  } = feature;\n\n  for (let i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}","map":{"version":3,"mappings":"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","names":["flatGeojsonToBinary","Protobuf","VectorTile","BinaryVectorTile","parseMVT","arrayBuffer","options","mvtOptions","normalizeOptions","shape","gis","format","mvt","_options$mvt","data","parseToBinary","table","parseToGeojson","Error","flatGeoJsonFeatures","geometryInfo","parseToFlatGeoJson","binaryData","byteLength","features","coordLength","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","tile","selectedLayers","Array","isArray","layers","Object","keys","forEach","layerName","vectorTileLayer","i","length","vectorTileFeature","feature","decodedFeature","getDecodedFeatureBinary","push","getDecodedFeature","wgs84Coordinates","coordinates","tileIndex","hasTileIndex","Number","isFinite","x","y","z","toGeoJSON","transformToLocalCoordinates","layerProperty","properties","toBinaryCoordinates","transformToLocalCoordinatesBinary","line","extent","p","il"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@loaders.gl\\mvt\\src\\lib\\parse-mvt.ts"],"sourcesContent":["import {flatGeojsonToBinary} from '@loaders.gl/gis';\nimport type {\n  FlatFeature,\n  Feature,\n  GeojsonGeometryInfo,\n  BinaryFeatures,\n  GeoJSONRowTable\n} from '@loaders.gl/schema';\nimport Protobuf from 'pbf';\n\nimport type {MVTMapboxCoordinates, MVTOptions, MVTLoaderOptions} from '../lib/types';\n\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\nimport VectorTileFeatureBinary from './binary-vector-tile/vector-tile-feature';\nimport VectorTileFeatureMapBox from './mapbox-vector-tile/vector-tile-feature';\n\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport default function parseMVT(arrayBuffer: ArrayBuffer, options?: MVTLoaderOptions) {\n  const mvtOptions = normalizeOptions(options);\n\n  const shape = options?.gis?.format || options?.mvt?.shape;\n  switch (shape) {\n    case 'columnar-table': // binary + some JS arrays\n      return {shape: 'columnar-table', data: parseToBinary(arrayBuffer, mvtOptions)};\n    case 'geojson-row-table': {\n      const table: GeoJSONRowTable = {\n        shape: 'geojson-row-table',\n        data: parseToGeojson(arrayBuffer, mvtOptions)\n      };\n      return table;\n    }\n    case 'geojson':\n      return parseToGeojson(arrayBuffer, mvtOptions);\n    case 'binary-geometry':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    case 'binary':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    default:\n      throw new Error(shape);\n  }\n}\n\nfunction parseToBinary(arrayBuffer: ArrayBuffer, options: MVTOptions): BinaryFeatures {\n  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n\n  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n  // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n  // TODO decide where to store extra fields like byteLength (header etc) and document\n  // @ts-ignore\n  binaryData.byteLength = arrayBuffer.byteLength;\n  return binaryData;\n}\n\nfunction parseToFlatGeoJson(\n  arrayBuffer: ArrayBuffer,\n  options: MVTOptions\n): [FlatFeature[], GeojsonGeometryInfo] {\n  const features: FlatFeature[] = [];\n  const geometryInfo: GeojsonGeometryInfo = {\n    coordLength: 2,\n    pointPositionsCount: 0,\n    pointFeaturesCount: 0,\n    linePositionsCount: 0,\n    linePathsCount: 0,\n    lineFeaturesCount: 0,\n    polygonPositionsCount: 0,\n    polygonObjectsCount: 0,\n    polygonRingsCount: 0,\n    polygonFeaturesCount: 0\n  };\n\n  if (arrayBuffer.byteLength <= 0) {\n    return [features, geometryInfo];\n  }\n\n  const tile = new BinaryVectorTile(new Protobuf(arrayBuffer));\n\n  const selectedLayers =\n    options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n\n  selectedLayers.forEach((layerName: string) => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.feature(i, geometryInfo);\n      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n\n  return [features, geometryInfo];\n}\n\nfunction parseToGeojson(arrayBuffer: ArrayBuffer, options: MVTOptions): Feature[] {\n  if (arrayBuffer.byteLength <= 0) {\n    return [];\n  }\n\n  const features: MVTMapboxCoordinates[] = [];\n  const tile = new VectorTile(new Protobuf(arrayBuffer));\n\n  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n\n  selectedLayers.forEach((layerName: string) => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.feature(i);\n      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n\n  return features as Feature[];\n}\n\nfunction normalizeOptions(options?: MVTLoaderOptions): MVTOptions {\n  if (!options?.mvt) {\n    throw new Error('mvt options required');\n  }\n\n  // Validate\n  const wgs84Coordinates = options.mvt?.coordinates === 'wgs84';\n  const {tileIndex} = options.mvt;\n  const hasTileIndex =\n    tileIndex &&\n    Number.isFinite(tileIndex.x) &&\n    Number.isFinite(tileIndex.y) &&\n    Number.isFinite(tileIndex.z);\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n  }\n\n  return options.mvt;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(\n  feature: VectorTileFeatureMapBox,\n  options: MVTOptions,\n  layerName: string\n): MVTMapboxCoordinates {\n  const decodedFeature = feature.toGeoJSON(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(\n  feature: VectorTileFeatureBinary,\n  options: MVTOptions,\n  layerName: string\n): FlatFeature {\n  const decodedFeature = feature.toBinaryCoordinates(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param line\n * @param feature\n */\nfunction transformToLocalCoordinates(line: number[], feature: {extent: any}): void {\n  // This function transforms local coordinates in a\n  // [0 - bufferSize, this.extent + bufferSize] range to a\n  // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n  // The resulting extent would be 1.\n  const {extent} = feature;\n  for (let i = 0; i < line.length; i++) {\n    const p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data: number[], feature: {extent: any}) {\n  // For the binary code path, the feature data is just\n  // one big flat array, so we just divide each value\n  const {extent} = feature;\n  for (let i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}