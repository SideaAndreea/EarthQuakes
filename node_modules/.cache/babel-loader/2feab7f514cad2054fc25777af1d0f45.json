{"ast":null,"code":"import { canEncodeWithWorker } from '@loaders.gl/loader-utils';\nimport { processOnWorker } from '@loaders.gl/worker-utils';\nimport { concatenateArrayBuffers, resolvePath } from '@loaders.gl/loader-utils';\nimport { isBrowser } from '@loaders.gl/loader-utils';\nimport { writeFile } from '../fetch/write-file';\nimport { fetchFile } from '../fetch/fetch-file';\nimport { getLoaderOptions } from './loader-options';\nexport async function encode(data, writer, options) {\n  const globalOptions = getLoaderOptions();\n  options = { ...globalOptions,\n    ...options\n  };\n\n  if (canEncodeWithWorker(writer, options)) {\n    return await processOnWorker(writer, data, options);\n  }\n\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  if (writer.encodeText) {\n    return new TextEncoder().encode(await writer.encodeText(data, options));\n  }\n\n  if (writer.encodeInBatches) {\n    const batches = encodeInBatches(data, writer, options);\n    const chunks = [];\n\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n\n    return concatenateArrayBuffers(...chunks);\n  }\n\n  if (!isBrowser && writer.encodeURLtoURL) {\n    const tmpInputFilename = getTemporaryFilename('input');\n    await writeFile(tmpInputFilename, data);\n    const tmpOutputFilename = getTemporaryFilename('output');\n    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n  }\n\n  throw new Error('Writer could not encode data');\n}\nexport function encodeSync(data, writer, options) {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  throw new Error('Writer could not synchronously encode data');\n}\nexport async function encodeText(data, writer, options) {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\n    const arrayBuffer = await encode(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n\n  throw new Error('Writer could not encode data as text');\n}\nexport function encodeInBatches(data, writer, options) {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n\n  throw new Error('Writer could not encode data in batches');\n}\nexport async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n\nfunction getIterator(data) {\n  const dataIterator = [{\n    table: data,\n    start: 0,\n    end: data.length\n  }];\n  return dataIterator;\n}\n\nfunction getTemporaryFilename(filename) {\n  return \"/tmp/\".concat(filename);\n}","map":{"version":3,"mappings":"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","names":["canEncodeWithWorker","processOnWorker","concatenateArrayBuffers","resolvePath","isBrowser","writeFile","fetchFile","getLoaderOptions","encode","data","writer","options","globalOptions","encodeSync","encodeText","TextEncoder","encodeInBatches","batches","chunks","batch","push","encodeURLtoURL","tmpInputFilename","getTemporaryFilename","tmpOutputFilename","outputFilename","response","arrayBuffer","Error","text","TextDecoder","decode","dataIterator","getIterator","inputUrl","outputUrl","table","start","end","length","filename"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplica»õii\\earthquakes\\node_modules\\@loaders.gl\\core\\src\\lib\\api\\encode.ts"],"sourcesContent":["import {Writer, LoaderOptions, canEncodeWithWorker} from '@loaders.gl/loader-utils';\nimport {processOnWorker} from '@loaders.gl/worker-utils';\nimport {concatenateArrayBuffers, resolvePath} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/loader-utils';\nimport {writeFile} from '../fetch/write-file';\nimport {fetchFile} from '../fetch/fetch-file';\nimport {getLoaderOptions} from './loader-options';\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): Promise<ArrayBuffer> {\n  const globalOptions = getLoaderOptions();\n  options = {...globalOptions, ...options};\n  if (canEncodeWithWorker(writer, options)) {\n    return await processOnWorker(writer, data, options);\n  }\n\n  // TODO Merge default writer options with options argument like it is done in load module.\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  if (writer.encodeText) {\n    return new TextEncoder().encode(await writer.encodeText(data, options));\n  }\n\n  if (writer.encodeInBatches) {\n    // Create an iterator representing the data\n    // TODO - Assumes this is a table\n    const batches = encodeInBatches(data, writer, options);\n\n    // Concatenate the output\n    const chunks: any[] = [];\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n    // @ts-ignore\n    return concatenateArrayBuffers(...chunks);\n  }\n\n  if (!isBrowser && writer.encodeURLtoURL) {\n    // TODO - how to generate filenames with correct extensions?\n    const tmpInputFilename = getTemporaryFilename('input');\n    await writeFile(tmpInputFilename, data);\n\n    const tmpOutputFilename = getTemporaryFilename('output');\n\n    const outputFilename = await encodeURLtoURL(\n      tmpInputFilename,\n      tmpOutputFilename,\n      writer,\n      options\n    );\n\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n  }\n\n  throw new Error('Writer could not encode data');\n}\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data: any, writer: Writer, options?: LoaderOptions): ArrayBuffer {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  throw new Error('Writer could not synchronously encode data');\n}\n\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): Promise<string> {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\n    const arrayBuffer = await encode(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n\n  throw new Error('Writer could not encode data as text');\n}\n\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): AsyncIterable<ArrayBuffer> {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error('Writer could not encode data in batches');\n}\n\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(\n  inputUrl,\n  outputUrl,\n  writer: Writer,\n  options\n): Promise<string> {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n  const dataIterator = [{table: data, start: 0, end: data.length}];\n  return dataIterator;\n}\n\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename: string): string {\n  return `/tmp/${filename}`;\n}\n"]},"metadata":{},"sourceType":"module"}