{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nexport class TypedArrayManager {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"_pool\", []);\n\n    _defineProperty(this, \"opts\", {\n      overAlloc: 2,\n      poolSize: 100\n    });\n\n    this.setOptions(options);\n  }\n\n  setOptions(options) {\n    Object.assign(this.opts, options);\n  }\n\n  allocate(typedArray, count, _ref) {\n    let {\n      size = 1,\n      type,\n      padding = 0,\n      copy = false,\n      initialize = false,\n      maxCount\n    } = _ref;\n    const Type = type || typedArray && typedArray.constructor || Float32Array;\n    const newSize = count * size + padding;\n\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    let maxSize = Infinity;\n\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size, initialize, maxSize) {\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n\n    if (i >= 0) {\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n\n      if (initialize) {\n        array.fill(0);\n      }\n\n      return array;\n    }\n\n    return new Type(sizeToAllocate);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n\n    const pool = this._pool;\n    const {\n      buffer\n    } = typedArray;\n    const {\n      byteLength\n    } = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n\n    if (pool.length > this.opts.poolSize) {\n      pool.shift();\n    }\n  }\n\n}\nexport default new TypedArrayManager();","map":{"version":3,"mappings":"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","names":["TypedArrayManager","constructor","options","_defineProperty","overAlloc","poolSize","setOptions","Object","assign","opts","allocate","typedArray","count","size","type","padding","copy","initialize","maxCount","Type","Float32Array","newSize","ArrayBuffer","isView","length","BYTES_PER_ELEMENT","buffer","byteLength","maxSize","Infinity","newArray","_allocate","set","fill","_release","release","sizeToAllocate","Math","max","ceil","pool","_pool","i","findIndex","b","array","splice","push","shift"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplica»õii\\earthquakes\\node_modules\\@deck.gl\\core\\src\\utils\\typed-array-manager.ts"],"sourcesContent":["import {TypedArray, TypedArrayConstructor} from '../types/types';\n\nexport type TypedArrayManagerOptions = {\n  overAlloc?: number;\n  poolSize?: number;\n};\n\nexport class TypedArrayManager {\n  private _pool: ArrayBuffer[] = [];\n  opts: {\n    overAlloc: number;\n    poolSize: number;\n  } = {overAlloc: 2, poolSize: 100};\n\n  constructor(options: TypedArrayManagerOptions = {}) {\n    this.setOptions(options);\n  }\n\n  setOptions(options: TypedArrayManagerOptions) {\n    Object.assign(this.opts, options);\n  }\n\n  allocate<T extends TypedArray>(\n    typedArray: T | null | undefined,\n    count: number,\n    {\n      size = 1,\n      type,\n      padding = 0,\n      copy = false,\n      initialize = false,\n      maxCount\n    }: {\n      size?: number;\n      type?: TypedArrayConstructor;\n      padding?: number;\n      copy?: boolean;\n      initialize?: boolean;\n      maxCount?: number;\n    }\n  ): T {\n    const Type =\n      type || (typedArray && (typedArray.constructor as TypedArrayConstructor)) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize) as T;\n      }\n    }\n\n    let maxSize: number = Infinity;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray as T;\n  }\n\n  release(typedArray: TypedArray | null | undefined) {\n    this._release(typedArray);\n  }\n\n  private _allocate(\n    Type: TypedArrayConstructor,\n    size: number,\n    initialize: boolean,\n    maxSize: number\n  ): TypedArray {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  private _release(typedArray: TypedArray | null | undefined): void {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.opts.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"]},"metadata":{},"sourceType":"module"}