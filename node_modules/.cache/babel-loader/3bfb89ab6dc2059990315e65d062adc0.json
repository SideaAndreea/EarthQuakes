{"ast":null,"code":"import { Buffer, Texture2D, assert } from '@luma.gl/webgl';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { Transform } from '@luma.gl/engine';\nimport { default as textureFilterModule } from './texture-filter';\nimport { POLY_TEX_VS, FILTER_VS } from './shaders';\nimport * as Polygon from './polygon';\nconst TEXTURE_SIZE = 512;\nexport default class GPUPointInPolygon {\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    assert(isWebGL2(gl));\n    this.textureSize = TEXTURE_SIZE;\n\n    this._setupResources();\n\n    this.update(opts);\n  }\n\n  update() {\n    let {\n      polygons,\n      textureSize\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (textureSize) {\n      this.textureSize = textureSize;\n    }\n\n    if (!polygons || polygons.length === 0) {\n      return;\n    }\n\n    const {\n      vertices,\n      indices,\n      vertexCount,\n      ids\n    } = triangulatePolygons(polygons);\n\n    this._updateResources(vertices, indices, ids, vertexCount);\n  }\n\n  filter(_ref) {\n    let {\n      positionBuffer,\n      filterValueIndexBuffer,\n      count\n    } = _ref;\n    this.filterTransform.update({\n      sourceBuffers: {\n        a_position: positionBuffer\n      },\n      feedbackBuffers: {\n        filterValueIndex: filterValueIndexBuffer\n      },\n      elementCount: count\n    });\n    const {\n      polygonTexture,\n      boundingBox\n    } = this;\n    this.filterTransform.run({\n      moduleSettings: {\n        boundingBox,\n        texture: polygonTexture\n      }\n    });\n  }\n\n  _setupResources() {\n    const {\n      gl\n    } = this;\n    this.polygonTexture = new Texture2D(gl, {\n      format: 6407,\n      type: 5121,\n      dataFormat: 6407,\n      border: 0,\n      mipmaps: false,\n      parameters: {\n        [10240]: 9728,\n        [10241]: 9728,\n        [10242]: 33071,\n        [10243]: 33071\n      }\n    });\n    this.positionBuffer = new Buffer(gl, {\n      accessor: {\n        type: 5126,\n        size: 2\n      }\n    });\n    this.idBuffer = new Buffer(gl, {\n      accessor: {\n        type: 5126,\n        size: 1\n      }\n    });\n    this.indexBuffer = new Buffer(gl, {\n      target: 34963,\n      accessor: {\n        type: 5123\n      }\n    });\n    this.polyTextureTransform = new Transform(gl, {\n      id: \"polygon-texture-creation-transform\",\n      elementCount: 0,\n      _targetTexture: this.polygonTexture,\n      _targetTextureVarying: 'v_polygonColor',\n      vs: POLY_TEX_VS,\n      drawMode: 4,\n      isIndexed: true,\n      sourceBuffers: {\n        a_position: this.positionBuffer,\n        a_polygonID: this.idBuffer,\n        indices: this.indexBuffer\n      }\n    });\n    this.filterTransform = new Transform(gl, {\n      id: 'filter transform',\n      vs: FILTER_VS,\n      modules: [textureFilterModule],\n      varyings: ['filterValueIndex']\n    });\n  }\n\n  _updateResources(vertices, indices, ids, vertexCount) {\n    const boundingBox = getBoundingBox(vertices, vertexCount);\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const width = xMax - xMin;\n    const height = yMax - yMin;\n    const whRatio = width / height;\n    const {\n      textureSize\n    } = this;\n    let texWidth = textureSize;\n    let texHeight = textureSize;\n\n    if (whRatio > 1) {\n      texHeight = texWidth / whRatio;\n    } else {\n      texWidth = texHeight * whRatio;\n    }\n\n    this.boundingBox = boundingBox;\n    this.polygonTexture.resize({\n      width: texWidth,\n      height: texHeight,\n      mipmaps: false\n    });\n    this.positionBuffer.setData(new Float32Array(vertices));\n    this.idBuffer.setData(new Float32Array(ids));\n    this.indexBuffer.setData(new Uint16Array(indices));\n    this.polyTextureTransform.update({\n      elementCount: indices.length,\n      _targetTexture: this.polygonTexture\n    });\n    this.polyTextureTransform.run({\n      uniforms: {\n        boundingBoxOriginSize: [xMin, yMin, width, height]\n      }\n    });\n  }\n\n}\n\nfunction getBoundingBox(positions, vertexCount) {\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  const SIZE = 2;\n  const vertices = [];\n  const indices = [];\n  const ids = [];\n  let count = 0;\n  let polygonId = 0;\n\n  for (let i = 0; i < polygons.length; i++) {\n    const normalized = Polygon.normalize(polygons[i], SIZE);\n    const curVertices = normalized.positions || normalized;\n    const curCount = curVertices.length / SIZE;\n    const curIds = new Array(curCount).fill(polygonId);\n    vertices.push(...curVertices);\n    ids.push(...curIds);\n    const curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    const indexCount = curIndices.length;\n\n    for (let j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n\n    count += curCount;\n    indices.push(...curIndices);\n    polygonId++;\n  }\n\n  assert(count < 65536);\n  const vertexCount = Polygon.getVertexCount(vertices, SIZE);\n  return {\n    vertices,\n    indices,\n    ids,\n    vertexCount\n  };\n}","map":{"version":3,"mappings":"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","names":["Buffer","Texture2D","assert","isWebGL2","Transform","default","textureFilterModule","POLY_TEX_VS","FILTER_VS","Polygon","TEXTURE_SIZE","GPUPointInPolygon","constructor","gl","opts","textureSize","_setupResources","update","polygons","arguments","length","vertices","indices","vertexCount","ids","triangulatePolygons","_updateResources","filter","positionBuffer","filterValueIndexBuffer","count","_ref","filterTransform","sourceBuffers","a_position","feedbackBuffers","filterValueIndex","elementCount","polygonTexture","boundingBox","run","moduleSettings","texture","format","type","dataFormat","border","mipmaps","parameters","accessor","size","idBuffer","indexBuffer","target","polyTextureTransform","id","_targetTexture","_targetTextureVarying","vs","drawMode","isIndexed","a_polygonID","modules","varyings","getBoundingBox","xMin","yMin","xMax","yMax","width","height","whRatio","texWidth","texHeight","resize","setData","Float32Array","Uint16Array","uniforms","boundingBoxOriginSize","positions","Infinity","y","x","i","SIZE","polygonId","normalized","normalize","curVertices","curCount","curIds","Array","fill","push","curIndices","getSurfaceIndices","indexCount","j","getVertexCount"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\AplicaÈ›ii\\earthquakes\\node_modules\\@luma.gl\\experimental\\src\\gpgpu\\point-in-polygon\\gpu-point-in-polygon.js"],"sourcesContent":["// @ts-nocheck TODO remove\n\nimport GL from '@luma.gl/constants';\nimport {Buffer, Texture2D, assert} from '@luma.gl/webgl';\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {Transform} from '@luma.gl/engine';\nimport {default as textureFilterModule} from './texture-filter';\nimport {POLY_TEX_VS, FILTER_VS} from './shaders';\nimport * as Polygon from './polygon';\nconst TEXTURE_SIZE = 512;\n\nexport default class GPUPointInPolygon {\n  constructor(gl, opts = {}) {\n    this.gl = gl;\n    assert(isWebGL2(gl)); // supports WebGL2 only\n    this.textureSize = TEXTURE_SIZE;\n    this._setupResources();\n    this.update(opts);\n  }\n\n  update({polygons, textureSize} = {}) {\n    if (textureSize) {\n      this.textureSize = textureSize;\n    }\n    if (!polygons || polygons.length === 0) {\n      return;\n    }\n\n    const {vertices, indices, vertexCount, ids} = triangulatePolygons(polygons);\n    this._updateResources(vertices, indices, ids, vertexCount);\n  }\n\n  filter({positionBuffer, filterValueIndexBuffer, count}) {\n    this.filterTransform.update({\n      sourceBuffers: {\n        a_position: positionBuffer\n      },\n      feedbackBuffers: {\n        filterValueIndex: filterValueIndexBuffer\n      },\n      elementCount: count\n    });\n    const {polygonTexture, boundingBox} = this;\n\n    this.filterTransform.run({\n      moduleSettings: {boundingBox, texture: polygonTexture}\n    });\n  }\n\n  // PRIVATE\n\n  _setupResources() {\n    const {gl} = this;\n\n    // texture to render polygons to\n    this.polygonTexture = new Texture2D(gl, {\n      format: GL.RGB,\n      type: GL.UNSIGNED_BYTE,\n      dataFormat: GL.RGB,\n      border: 0,\n      mipmaps: false,\n      parameters: {\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n    this.positionBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 2}});\n    this.idBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 1}});\n    this.indexBuffer = new Buffer(gl, {\n      target: GL.ELEMENT_ARRAY_BUFFER,\n      accessor: {type: GL.UNSIGNED_SHORT}\n    });\n\n    // transform to generate polygon texture\n    this.polyTextureTransform = new Transform(gl, {\n      id: `polygon-texture-creation-transform`,\n      elementCount: 0,\n      _targetTexture: this.polygonTexture,\n      _targetTextureVarying: 'v_polygonColor',\n      vs: POLY_TEX_VS,\n      drawMode: GL.TRIANGLES,\n      isIndexed: true,\n      sourceBuffers: {\n        a_position: this.positionBuffer,\n        a_polygonID: this.idBuffer,\n        indices: this.indexBuffer\n      }\n    });\n\n    // transform to perform filtering\n    this.filterTransform = new Transform(gl, {\n      id: 'filter transform',\n      vs: FILTER_VS,\n      modules: [textureFilterModule],\n      varyings: ['filterValueIndex']\n    });\n  }\n\n  _updateResources(vertices, indices, ids, vertexCount) {\n    const boundingBox = getBoundingBox(vertices, vertexCount);\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const width = xMax - xMin;\n    const height = yMax - yMin;\n    const whRatio = width / height;\n    const {textureSize} = this;\n\n    // calculate max texture size with same aspect ratio\n    let texWidth = textureSize;\n    let texHeight = textureSize;\n    if (whRatio > 1) {\n      texHeight = texWidth / whRatio;\n    } else {\n      texWidth = texHeight * whRatio;\n    }\n\n    this.boundingBox = boundingBox;\n    this.polygonTexture.resize({width: texWidth, height: texHeight, mipmaps: false});\n    this.positionBuffer.setData(new Float32Array(vertices));\n    this.idBuffer.setData(new Float32Array(ids));\n    this.indexBuffer.setData(new Uint16Array(indices));\n    this.polyTextureTransform.update({\n      elementCount: indices.length,\n      _targetTexture: this.polygonTexture\n    });\n\n    this.polyTextureTransform.run({\n      uniforms: {\n        boundingBoxOriginSize: [xMin, yMin, width, height]\n      }\n    });\n  }\n}\n\n// Helper methods\n\nfunction getBoundingBox(positions, vertexCount) {\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  const SIZE = 2;\n  const vertices = [];\n  const indices = [];\n  const ids = [];\n  let count = 0;\n  let polygonId = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    const normalized = Polygon.normalize(polygons[i], SIZE);\n    const curVertices = normalized.positions || normalized;\n    const curCount = curVertices.length / SIZE;\n    const curIds = new Array(curCount).fill(polygonId);\n    vertices.push(...curVertices);\n    ids.push(...curIds);\n    const curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    const indexCount = curIndices.length;\n    for (let j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n    count += curCount;\n    indices.push(...curIndices);\n    polygonId++;\n  }\n\n  // UInt16 (UNSIGNED_SHORT) buffer is used for indices\n  assert(count < 65536); // 0xFFFF\n\n  const vertexCount = Polygon.getVertexCount(vertices, SIZE);\n\n  return {vertices, indices, ids, vertexCount};\n}\n"]},"metadata":{},"sourceType":"module"}