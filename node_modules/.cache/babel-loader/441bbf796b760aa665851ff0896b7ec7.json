{"ast":null,"code":"import { getOSMTileIndices } from './tile-2d-traversal';\nconst TILE_SIZE = 512;\nconst DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];\nexport const urlType = {\n  type: 'url',\n  value: null,\n  validate: (value, propType) => propType.optional && value === null || typeof value === 'string' || Array.isArray(value) && value.every(url => typeof url === 'string'),\n  equals: (value1, value2) => {\n    if (value1 === value2) {\n      return true;\n    }\n\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n\n    const len = value1.length;\n\n    if (len !== value2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nfunction transformBox(bbox, modelMatrix) {\n  const transformedCoords = [modelMatrix.transformAsPoint([bbox[0], bbox[1]]), modelMatrix.transformAsPoint([bbox[2], bbox[1]]), modelMatrix.transformAsPoint([bbox[0], bbox[3]]), modelMatrix.transformAsPoint([bbox[2], bbox[3]])];\n  const transformedBox = [Math.min(...transformedCoords.map(i => i[0])), Math.min(...transformedCoords.map(i => i[1])), Math.max(...transformedCoords.map(i => i[0])), Math.max(...transformedCoords.map(i => i[1]))];\n  return transformedBox;\n}\n\nfunction stringHash(s) {\n  return Math.abs(s.split('').reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0));\n}\n\nexport function getURLFromTemplate(template, tile) {\n  if (!template || !template.length) {\n    return null;\n  }\n\n  const {\n    index,\n    id\n  } = tile;\n\n  if (Array.isArray(template)) {\n    const i = stringHash(id) % template.length;\n    template = template[i];\n  }\n\n  let url = template;\n\n  for (const key of Object.keys(index)) {\n    const regex = new RegExp(\"{\".concat(key, \"}\"), 'g');\n    url = url.replace(regex, String(index[key]));\n  }\n\n  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {\n    url = url.replace(/\\{-y\\}/g, String(Math.pow(2, index.z) - index.y - 1));\n  }\n\n  return url;\n}\n\nfunction getBoundingBox(viewport, zRange, extent) {\n  let bounds;\n\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({\n      z: minZ\n    });\n    const bounds1 = viewport.getBounds({\n      z: maxZ\n    });\n    bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n  } else {\n    bounds = viewport.getBounds();\n  }\n\n  if (!viewport.isGeospatial) {\n    return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];\n  }\n\n  return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];\n}\n\nexport function getCullBounds(_ref) {\n  let {\n    viewport,\n    z,\n    cullRect\n  } = _ref;\n  const x = cullRect.x - viewport.x;\n  const y = cullRect.y - viewport.y;\n  const {\n    width,\n    height\n  } = cullRect;\n\n  if (!Array.isArray(z)) {\n    const unprojectOption = {\n      targetZ: z || 0\n    };\n    const topLeft = viewport.unproject([x, y], unprojectOption);\n    const topRight = viewport.unproject([x + width, y], unprojectOption);\n    const bottomLeft = viewport.unproject([x, y + height], unprojectOption);\n    const bottomRight = viewport.unproject([x + width, y + height], unprojectOption);\n    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n  }\n\n  const bounds0 = getCullBounds({\n    viewport,\n    z: z[0],\n    cullRect\n  });\n  const bounds1 = getCullBounds({\n    viewport,\n    z: z[1],\n    cullRect\n  });\n  return [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n}\n\nfunction getIndexingCoords(bbox, scale, modelMatrixInverse) {\n  if (modelMatrixInverse) {\n    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(i => i * scale / TILE_SIZE);\n    return transformedTileIndex;\n  }\n\n  return bbox.map(i => i * scale / TILE_SIZE);\n}\n\nfunction getScale(z, tileSize) {\n  return Math.pow(2, z) * TILE_SIZE / tileSize;\n}\n\nexport function osmTile2lngLat(x, y, z) {\n  const scale = getScale(z, TILE_SIZE);\n  const lng = x / scale * 360 - 180;\n  const n = Math.PI - 2 * Math.PI * y / scale;\n  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x, y, z, tileSize) {\n  const scale = getScale(z, tileSize);\n  return [x / scale * TILE_SIZE, y / scale * TILE_SIZE];\n}\n\nexport function tileToBoundingBox(viewport, x, y, z) {\n  let tileSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TILE_SIZE;\n\n  if (viewport.isGeospatial) {\n    const [west, north] = osmTile2lngLat(x, y, z);\n    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);\n    return {\n      west,\n      north,\n      east,\n      south\n    };\n  }\n\n  const [left, top] = tile2XY(x, y, z, tileSize);\n  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n}\n\nfunction getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {\n  const bbox = getBoundingBox(viewport, null, extent);\n  const scale = getScale(z, tileSize);\n  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);\n  const indices = [];\n\n  for (let x = Math.floor(minX); x < maxX; x++) {\n    for (let y = Math.floor(minY); y < maxY; y++) {\n      indices.push({\n        x,\n        y,\n        z\n      });\n    }\n  }\n\n  return indices;\n}\n\nexport function getTileIndices(_ref2) {\n  let {\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    extent,\n    tileSize = TILE_SIZE,\n    modelMatrix,\n    modelMatrixInverse,\n    zoomOffset = 0\n  } = _ref2;\n  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;\n\n  if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n\n    z = minZoom;\n  }\n\n  if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n\n  let transformedExtent = extent;\n\n  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {\n    transformedExtent = transformBox(extent, modelMatrix);\n  }\n\n  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);\n}\nexport function isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);\n}\nexport function isGeoBoundingBox(v) {\n  return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);\n}","map":{"version":3,"mappings":"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","names":["getOSMTileIndices","TILE_SIZE","DEFAULT_EXTENT","Infinity","urlType","type","value","validate","propType","optional","Array","isArray","every","url","equals","value1","value2","len","length","i","transformBox","bbox","modelMatrix","transformedCoords","transformAsPoint","transformedBox","Math","min","map","max","stringHash","s","abs","split","reduce","a","b","charCodeAt","getURLFromTemplate","template","tile","index","id","key","Object","keys","regex","RegExp","replace","String","Number","isInteger","y","z","pow","getBoundingBox","viewport","zRange","extent","bounds","minZ","maxZ","bounds0","getBounds","bounds1","isGeospatial","getCullBounds","cullRect","x","width","height","unprojectOption","targetZ","topLeft","unproject","topRight","bottomLeft","bottomRight","getIndexingCoords","scale","modelMatrixInverse","transformedTileIndex","getScale","tileSize","osmTile2lngLat","lng","n","PI","lat","atan","exp","tile2XY","tileToBoundingBox","west","north","east","south","left","top","right","bottom","getIdentityTileIndices","minX","minY","maxX","maxY","indices","floor","push","getTileIndices","maxZoom","minZoom","zoomOffset","round","zoom","log2","ceil","isFinite","transformedExtent","isURLTemplate","test","isGeoBoundingBox","v"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\AplicaÈ›ii\\earthquakes\\node_modules\\@deck.gl\\geo-layers\\src\\tile-layer\\utils.ts"],"sourcesContent":["import {Viewport} from '@deck.gl/core';\nimport {Matrix4} from '@math.gl/core';\nimport {getOSMTileIndices} from './tile-2d-traversal';\nimport {Bounds, GeoBoundingBox, TileBoundingBox, TileIndex, ZRange} from './types';\n\nconst TILE_SIZE = 512;\nconst DEFAULT_EXTENT: Bounds = [-Infinity, -Infinity, Infinity, Infinity];\n\nexport const urlType = {\n  type: 'url',\n  value: null,\n  validate: (value, propType) =>\n    (propType.optional && value === null) ||\n    typeof value === 'string' ||\n    (Array.isArray(value) && value.every(url => typeof url === 'string')),\n  equals: (value1, value2) => {\n    if (value1 === value2) {\n      return true;\n    }\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n    const len = value1.length;\n    if (len !== value2.length) {\n      return false;\n    }\n    for (let i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nfunction transformBox(bbox: Bounds, modelMatrix: Matrix4): Bounds {\n  const transformedCoords = [\n    // top-left\n    modelMatrix.transformAsPoint([bbox[0], bbox[1]]),\n    // top-right\n    modelMatrix.transformAsPoint([bbox[2], bbox[1]]),\n    // bottom-left\n    modelMatrix.transformAsPoint([bbox[0], bbox[3]]),\n    // bottom-right\n    modelMatrix.transformAsPoint([bbox[2], bbox[3]])\n  ];\n  const transformedBox: Bounds = [\n    // Minimum x coord\n    Math.min(...transformedCoords.map(i => i[0])),\n    // Minimum y coord\n    Math.min(...transformedCoords.map(i => i[1])),\n    // Max x coord\n    Math.max(...transformedCoords.map(i => i[0])),\n    // Max y coord\n    Math.max(...transformedCoords.map(i => i[1]))\n  ];\n  return transformedBox;\n}\n\nfunction stringHash(s: string): number {\n  return Math.abs(s.split('').reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0));\n}\n\nexport function getURLFromTemplate(\n  template: string | string[],\n  tile: {\n    index: TileIndex;\n    id: string;\n  }\n): string | null {\n  if (!template || !template.length) {\n    return null;\n  }\n  const {index, id} = tile;\n\n  if (Array.isArray(template)) {\n    const i = stringHash(id) % template.length;\n    template = template[i];\n  }\n\n  let url = template;\n  for (const key of Object.keys(index)) {\n    const regex = new RegExp(`{${key}}`, 'g');\n    url = url.replace(regex, String(index[key]));\n  }\n\n  // Back-compatible support for {-y}\n  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {\n    url = url.replace(/\\{-y\\}/g, String(Math.pow(2, index.z) - index.y - 1));\n  }\n  return url;\n}\n\n/**\n * gets the bounding box of a viewport\n */\nfunction getBoundingBox(viewport: Viewport, zRange: number[] | null, extent: Bounds): Bounds {\n  let bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    bounds = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    bounds = viewport.getBounds();\n  }\n  if (!viewport.isGeospatial) {\n    return [\n      // Top corner should not be more then bottom corner in either direction\n      Math.max(Math.min(bounds[0], extent[2]), extent[0]),\n      Math.max(Math.min(bounds[1], extent[3]), extent[1]),\n      // Bottom corner should not be less then top corner in either direction\n      Math.min(Math.max(bounds[2], extent[0]), extent[2]),\n      Math.min(Math.max(bounds[3], extent[1]), extent[3])\n    ];\n  }\n  return [\n    Math.max(bounds[0], extent[0]),\n    Math.max(bounds[1], extent[1]),\n    Math.min(bounds[2], extent[2]),\n    Math.min(bounds[3], extent[3])\n  ];\n}\n\n/** Get culling bounds in world space */\nexport function getCullBounds({\n  viewport,\n  z,\n  cullRect\n}: {\n  /** Current viewport */\n  viewport: Viewport;\n  /** Current z range */\n  z: ZRange | number | undefined;\n  /** Culling rectangle in screen space */\n  cullRect: {x: number; y: number; width: number; height: number};\n}): [number, number, number, number] {\n  const x = cullRect.x - viewport.x;\n  const y = cullRect.y - viewport.y;\n  const {width, height} = cullRect;\n\n  if (!Array.isArray(z)) {\n    const unprojectOption = {targetZ: z || 0};\n\n    const topLeft = viewport.unproject([x, y], unprojectOption);\n    const topRight = viewport.unproject([x + width, y], unprojectOption);\n    const bottomLeft = viewport.unproject([x, y + height], unprojectOption);\n    const bottomRight = viewport.unproject([x + width, y + height], unprojectOption);\n\n    return [\n      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),\n      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])\n    ];\n  }\n\n  const bounds0 = getCullBounds({viewport, z: z[0], cullRect});\n  const bounds1 = getCullBounds({viewport, z: z[1], cullRect});\n\n  return [\n    Math.min(bounds0[0], bounds1[0]),\n    Math.min(bounds0[1], bounds1[1]),\n    Math.max(bounds0[2], bounds1[2]),\n    Math.max(bounds0[3], bounds1[3])\n  ];\n}\n\nfunction getIndexingCoords(bbox: Bounds, scale: number, modelMatrixInverse?: Matrix4): Bounds {\n  if (modelMatrixInverse) {\n    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(\n      i => (i * scale) / TILE_SIZE\n    );\n    return transformedTileIndex as Bounds;\n  }\n  return bbox.map(i => (i * scale) / TILE_SIZE) as Bounds;\n}\n\nfunction getScale(z: number, tileSize: number): number {\n  return (Math.pow(2, z) * TILE_SIZE) / tileSize;\n}\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Lon..2Flat._to_tile_numbers_2\nexport function osmTile2lngLat(x: number, y: number, z: number): [number, number] {\n  const scale = getScale(z, TILE_SIZE);\n  const lng = (x / scale) * 360 - 180;\n  const n = Math.PI - (2 * Math.PI * y) / scale;\n  const lat = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x: number, y: number, z: number, tileSize: number): [number, number] {\n  const scale = getScale(z, tileSize);\n  return [(x / scale) * TILE_SIZE, (y / scale) * TILE_SIZE];\n}\nexport function tileToBoundingBox(\n  viewport: Viewport,\n  x: number,\n  y: number,\n  z: number,\n  tileSize: number = TILE_SIZE\n): TileBoundingBox {\n  if (viewport.isGeospatial) {\n    const [west, north] = osmTile2lngLat(x, y, z);\n    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);\n    return {west, north, east, south};\n  }\n  const [left, top] = tile2XY(x, y, z, tileSize);\n  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);\n  return {left, top, right, bottom};\n}\n\nfunction getIdentityTileIndices(\n  viewport: Viewport,\n  z: number,\n  tileSize: number,\n  extent: Bounds,\n  modelMatrixInverse?: Matrix4\n) {\n  const bbox = getBoundingBox(viewport, null, extent);\n  const scale = getScale(z, tileSize);\n  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);\n  const indices: TileIndex[] = [];\n\n  /*\n      |  TILE  |  TILE  |  TILE  |\n        |(minX)            |(maxX)\n   */\n  for (let x = Math.floor(minX); x < maxX; x++) {\n    for (let y = Math.floor(minY); y < maxY; y++) {\n      indices.push({x, y, z});\n    }\n  }\n  return indices;\n}\n\n/**\n * Returns all tile indices in the current viewport. If the current zoom level is smaller\n * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n * return tiles that are on maxZoom.\n */\n// eslint-disable-next-line complexity\nexport function getTileIndices({\n  viewport,\n  maxZoom,\n  minZoom,\n  zRange,\n  extent,\n  tileSize = TILE_SIZE,\n  modelMatrix,\n  modelMatrixInverse,\n  zoomOffset = 0\n}: {\n  viewport: Viewport;\n  maxZoom?: number;\n  minZoom?: number;\n  zRange: ZRange | undefined;\n  extent?: Bounds;\n  tileSize?: number;\n  modelMatrix?: Matrix4;\n  modelMatrixInverse?: Matrix4;\n  zoomOffset?: number;\n}) {\n  let z = viewport.isGeospatial\n    ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset\n    : Math.ceil(viewport.zoom) + zoomOffset;\n  if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n    z = minZoom;\n  }\n  if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n  let transformedExtent = extent;\n  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {\n    transformedExtent = transformBox(extent, modelMatrix);\n  }\n  return viewport.isGeospatial\n    ? getOSMTileIndices(viewport, z, zRange, extent)\n    : getIdentityTileIndices(\n        viewport,\n        z,\n        tileSize,\n        transformedExtent || DEFAULT_EXTENT,\n        modelMatrixInverse\n      );\n}\n\n/**\n * Returns true if s is a valid URL template\n */\nexport function isURLTemplate(s: string): boolean {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);\n}\n\nexport function isGeoBoundingBox(v: any): v is GeoBoundingBox {\n  return (\n    Number.isFinite(v.west) &&\n    Number.isFinite(v.north) &&\n    Number.isFinite(v.east) &&\n    Number.isFinite(v.south)\n  );\n}\n"]},"metadata":{},"sourceType":"module"}