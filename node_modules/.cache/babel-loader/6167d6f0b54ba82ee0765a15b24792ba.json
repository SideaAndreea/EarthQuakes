{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { LayerExtension } from '@deck.gl/core';\nimport { shaderModule, shaderModule64 } from './shader-module';\nimport * as aggregator from './aggregator';\nimport { readPixelsToArray, clear } from '@luma.gl/core';\nconst defaultProps = {\n  getFilterValue: {\n    type: 'accessor',\n    value: 0\n  },\n  onFilteredItemsChange: {\n    type: 'function',\n    value: null,\n    compare: false\n  },\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterTransformSize: true,\n  filterTransformColor: true\n};\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\nexport default class DataFilterExtension extends LayerExtension {\n  constructor() {\n    let {\n      filterSize = 1,\n      fp64 = false,\n      countItems = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!DATA_TYPE_FROM_SIZE[filterSize]) {\n      throw new Error('filterSize out of range');\n    }\n\n    super({\n      filterSize,\n      fp64,\n      countItems\n    });\n  }\n\n  getShaders(extension) {\n    const {\n      filterSize,\n      fp64\n    } = extension.opts;\n    return {\n      modules: [fp64 ? shaderModule64 : shaderModule],\n      defines: {\n        DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],\n        DATAFILTER_DOUBLE: Boolean(fp64)\n      }\n    };\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.add({\n        filterValues: {\n          size: extension.opts.filterSize,\n          type: extension.opts.fp64 ? 5130 : 5126,\n          accessor: 'getFilterValue',\n          shaderAttributes: {\n            filterValues: {\n              divisor: 0\n            },\n            instanceFilterValues: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    const {\n      gl\n    } = this.context;\n\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(gl);\n      attributeManager.add({\n        filterIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: 5121,\n          normalized: true,\n          accessor: (object, _ref) => {\n            let {\n              index\n            } = _ref;\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n      const filterFBO = aggregator.getFramebuffer(gl, useFloatTarget);\n      const filterModel = aggregator.getModel(gl, extension.getShaders.call(this, extension), useFloatTarget);\n      this.setState({\n        filterFBO,\n        filterModel\n      });\n    }\n  }\n\n  updateState(_ref2) {\n    let {\n      props,\n      oldProps\n    } = _ref2;\n\n    if (this.state.filterModel) {\n      const attributeManager = this.getAttributeManager();\n      const filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange;\n\n      if (filterNeedsUpdate) {\n        this.setState({\n          filterNeedsUpdate\n        });\n      }\n    }\n  }\n\n  draw(params, extension) {\n    const {\n      filterFBO,\n      filterModel,\n      filterNeedsUpdate\n    } = this.state;\n    const {\n      onFilteredItemsChange\n    } = this.props;\n\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const {\n        attributes: {\n          filterValues,\n          filterIndices\n        }\n      } = this.getAttributeManager();\n      filterModel.setVertexCount(this.getNumInstances());\n      const {\n        gl\n      } = this.context;\n      clear(gl, {\n        framebuffer: filterFBO,\n        color: [0, 0, 0, 0]\n      });\n      filterModel.updateModuleSettings(params.moduleParameters).setAttributes({ ...filterValues.getShaderAttributes(),\n        ...(filterIndices && filterIndices.getShaderAttributes())\n      }).draw({\n        framebuffer: filterFBO,\n        parameters: { ...aggregator.parameters,\n          viewport: [0, 0, filterFBO.width, filterFBO.height]\n        }\n      });\n      const color = readPixelsToArray(filterFBO);\n      let count = 0;\n\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n\n      onFilteredItemsChange({\n        id: this.id,\n        count\n      });\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n\n  finalizeState() {\n    const {\n      filterFBO,\n      filterModel\n    } = this.state;\n\n    if (filterFBO) {\n      filterFBO.color.delete();\n      filterFBO.delete();\n      filterModel.delete();\n    }\n  }\n\n}\n\n_defineProperty(DataFilterExtension, \"defaultProps\", defaultProps);\n\n_defineProperty(DataFilterExtension, \"extensionName\", 'DataFilterExtension');","map":{"version":3,"mappings":"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","names":["LayerExtension","shaderModule","shaderModule64","aggregator","readPixelsToArray","clear","defaultProps","getFilterValue","type","value","onFilteredItemsChange","compare","filterEnabled","filterRange","filterSoftRange","filterTransformSize","filterTransformColor","DATA_TYPE_FROM_SIZE","DataFilterExtension","constructor","filterSize","fp64","countItems","Error","getShaders","extension","opts","modules","defines","DATAFILTER_TYPE","DATAFILTER_DOUBLE","Boolean","initializeState","context","attributeManager","getAttributeManager","add","filterValues","size","accessor","shaderAttributes","divisor","instanceFilterValues","gl","useFloatTarget","supportsFloatTarget","filterIndices","vertexOffset","normalized","object","index","i","__source","Math","floor","filterPrevIndices","filterFBO","getFramebuffer","filterModel","getModel","call","setState","updateState","props","oldProps","state","filterNeedsUpdate","attributes","needsUpdate","draw","params","setVertexCount","getNumInstances","framebuffer","color","updateModuleSettings","moduleParameters","setAttributes","getShaderAttributes","parameters","viewport","width","height","count","length","id","finalizeState","delete"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\AplicaÈ›ii\\earthquakes\\node_modules\\@deck.gl\\extensions\\src\\data-filter\\data-filter.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension} from '@deck.gl/core';\nimport {shaderModule, shaderModule64} from './shader-module';\nimport * as aggregator from './aggregator';\nimport {readPixelsToArray, clear} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport type {Layer, LayerContext, Accessor, UpdateParameters} from '@deck.gl/core';\n\nconst defaultProps = {\n  getFilterValue: {type: 'accessor', value: 0},\n  onFilteredItemsChange: {type: 'function', value: null, compare: false},\n\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterTransformSize: true,\n  filterTransformColor: true\n};\n\nexport type DataFilterExtensionProps<DataT = any> = {\n  /**\n   * Accessor to retrieve the value for each object that it will be filtered by.\n   * Returns either a number (if `filterSize: 1`) or an array of numbers.\n   */\n  getFilterValue?: Accessor<DataT, number | number[]>;\n  /**\n   * Enable/disable the data filter. If the data filter is disabled, all objects are rendered.\n   * @default true\n   */\n  filterEnabled?: boolean;\n  /**\n   * The [min, max] bounds which defines whether an object should be rendered.\n   * If an object's filtered value is within the bounds, the object will be rendered; otherwise it will be hidden.\n   * @default [-1, 1]\n   */\n  filterRange?: [number, number] | [number, number][];\n  /**\n   * If specified, objects will be faded in/out instead of abruptly shown/hidden.\n   * When the filtered value is outside of the bounds defined by `filterSoftRange` but still within the bounds defined by `filterRange`, the object will be rendered as \"faded.\"\n   * @default null\n   */\n  filterSoftRange?: [number, number] | [number, number][] | null;\n  /**\n   * When an object is \"faded\", manipulate its size so that it appears smaller or thinner. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformSize?: boolean;\n  /**\n   * When an object is \"faded\", manipulate its opacity so that it appears more translucent. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformColor?: boolean;\n  /**\n   * Only called if the `countItems` option is enabled.\n   */\n  onFilteredItemsChange?: (evt: {\n    /** The id of the source layer. */\n    id: string;\n    /** The number of data objects that pass the filter. */\n    count: number;\n  }) => void;\n};\n\ntype DataFilterExtensionOptions = {\n  /**\n   * The size of the filter (number of columns to filter by). The data filter can show/hide data based on 1-4 numeric properties of each object.\n   * @default 1\n   */\n  filterSize: number;\n  /**\n   * Use 64-bit precision instead of 32-bit.\n   * @default false\n   */\n  fp64: boolean;\n  /**\n   * If `true`, reports the number of filtered objects with the `onFilteredItemsChange` callback.\n   * @default `false`.\n   */\n  countItems: boolean;\n};\n\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\n/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */\nexport default class DataFilterExtension extends LayerExtension<DataFilterExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'DataFilterExtension';\n\n  constructor({\n    filterSize = 1,\n    fp64 = false,\n    countItems = false\n  }: Partial<DataFilterExtensionOptions> = {}) {\n    if (!DATA_TYPE_FROM_SIZE[filterSize]) {\n      throw new Error('filterSize out of range');\n    }\n\n    super({filterSize, fp64, countItems});\n  }\n\n  getShaders(this: Layer<DataFilterExtensionProps>, extension: this): any {\n    const {filterSize, fp64} = extension.opts;\n\n    return {\n      modules: [fp64 ? shaderModule64 : shaderModule],\n      defines: {\n        DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],\n        DATAFILTER_DOUBLE: Boolean(fp64)\n      }\n    };\n  }\n\n  initializeState(this: Layer<DataFilterExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.add({\n        filterValues: {\n          size: extension.opts.filterSize,\n          type: extension.opts.fp64 ? GL.DOUBLE : GL.FLOAT,\n          accessor: 'getFilterValue',\n          shaderAttributes: {\n            filterValues: {\n              divisor: 0\n            },\n            instanceFilterValues: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    const {gl} = this.context;\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(gl);\n      // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n      // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n      // so that we only write one count cross multiple vertices of the same object\n      attributeManager.add({\n        filterIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: GL.UNSIGNED_BYTE,\n          normalized: true,\n          accessor: (object, {index}) => {\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n\n      const filterFBO = aggregator.getFramebuffer(gl, useFloatTarget);\n      const filterModel = aggregator.getModel(\n        gl,\n        extension.getShaders.call(this, extension),\n        useFloatTarget\n      );\n      this.setState({filterFBO, filterModel});\n    }\n  }\n\n  updateState(\n    this: Layer<DataFilterExtensionProps>,\n    {props, oldProps}: UpdateParameters<Layer<DataFilterExtensionProps>>\n  ) {\n    if (this.state.filterModel) {\n      const attributeManager = this.getAttributeManager();\n      const filterNeedsUpdate =\n        // attributeManager must be defined for filterModel to be set\n        attributeManager!.attributes.filterValues.needsUpdate() ||\n        props.filterEnabled !== oldProps.filterEnabled ||\n        props.filterRange !== oldProps.filterRange ||\n        props.filterSoftRange !== oldProps.filterSoftRange;\n      if (filterNeedsUpdate) {\n        this.setState({filterNeedsUpdate});\n      }\n    }\n  }\n\n  draw(this: Layer<DataFilterExtensionProps>, params: any, extension: this) {\n    const {filterFBO, filterModel, filterNeedsUpdate} = this.state;\n    const {onFilteredItemsChange} = this.props;\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const {\n        attributes: {filterValues, filterIndices}\n      } = this.getAttributeManager()!;\n      filterModel.setVertexCount(this.getNumInstances());\n\n      const {gl} = this.context;\n      clear(gl, {framebuffer: filterFBO, color: [0, 0, 0, 0]});\n\n      filterModel\n        .updateModuleSettings(params.moduleParameters)\n        .setAttributes({\n          ...filterValues.getShaderAttributes(),\n          ...(filterIndices && filterIndices.getShaderAttributes())\n        })\n        .draw({\n          framebuffer: filterFBO,\n          parameters: {\n            ...aggregator.parameters,\n            viewport: [0, 0, filterFBO.width, filterFBO.height]\n          }\n        });\n      const color = readPixelsToArray(filterFBO);\n      let count = 0;\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n      onFilteredItemsChange({id: this.id, count});\n\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n\n  finalizeState(this: Layer<DataFilterExtensionProps>) {\n    const {filterFBO, filterModel} = this.state;\n    if (filterFBO) {\n      filterFBO.color.delete();\n      filterFBO.delete();\n      filterModel.delete();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}