{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { load } from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\nimport { getLodStatus } from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  traversalFinished(frameState) {\n    return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);\n  }\n\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"_tileManager\", void 0);\n\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.header.children || [];\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = \"\".concat(child.id, \"-\").concat(frameState.viewport.id);\n      const childTile = childTiles && childTiles.find(t => t.id === extendedId);\n\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n\n        const cachedRequest = this._tileManager.find(extendedId);\n\n        if (!cachedRequest) {\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n\n          this._tileManager.add(request, extendedId, header => this._onTileLoad(header, tile, extendedId), frameState);\n        } else {\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        this.updateTile(childTile, frameState);\n      }\n    }\n\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {\n      loader\n    } = tileset;\n    const nodeUrl = tileset.getTileUrl(\"\".concat(tileset.url, \"/nodes/\").concat(nodeId));\n    const options = { ...tileset.loadOptions,\n      i3s: { ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n    return await load(nodeUrl, loader, options);\n  }\n\n  _onTileLoad(header, tile, extendedId) {\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n\n    const frameState = this._tileManager.find(childTile.id).frameState;\n\n    this.updateTile(childTile, frameState);\n\n    if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["load","TilesetTraverser","getLodStatus","TileHeader","I3STileManager","I3STilesetTraverser","traversalFinished","frameState","_tileManager","hasPendingTiles","viewport","id","_frameNumber","constructor","options","_defineProperty","shouldRefine","tile","_lodJudge","updateChildTiles","children","header","childTiles","tileset","child","extendedId","childTile","find","t","request","_loadTile","cachedRequest","nodePages","nodePagesTile","formTileFromNodePages","add","_onTileLoad","update","updateTile","nodeId","loader","nodeUrl","getTileUrl","url","loadOptions","i3s","isTileHeader","loadContent","push","frameNumber","Date","getTime","lastUpdate","updateDebounceTime","executeTraversal"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@loaders.gl\\tiles\\src\\tileset\\traversers\\i3s-tileset-traverser.ts"],"sourcesContent":["import {load} from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\n\nimport {getLodStatus} from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\nimport {FrameState} from '../helpers/frame-state';\n\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  private _tileManager: I3STileManager;\n\n  /**\n   * Check if there are no penging tile header requests,\n   * that means the traversal is finished and we can call\n   * following-up callbacks.\n   */\n  protected traversalFinished(frameState: FrameState): boolean {\n    return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);\n  }\n\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState: FrameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState: FrameState): boolean {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(\n            request,\n            extendedId,\n            (header) => this._onTileLoad(header, tile, extendedId),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n\n    return await load(nodeUrl, loader, options);\n  }\n\n  /**\n   * The callback to init TileHeader instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {TileHeader} tile - the parent TileHeader instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (\n      this._frameNumber === frameState.frameNumber &&\n      (this.traversalFinished(frameState) ||\n        new Date().getTime() - this.lastUpdate > this.updateDebounceTime)\n    ) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}