{"ast":null,"code":"export async function waitForGLTFAssets(gltfObjects) {\n  const remaining = [];\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse(model => {\n      Object.values(model.model.getUniforms()).forEach(uniform => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition) {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}","map":{"version":3,"mappings":"AAGA,OAAO,eAAeA,iBAAf,CAAiCC,WAAjC,EAAoF;EACzF,MAAMC,SAAgB,GAAG,EAAzB;EAEAD,WAAW,CAACE,MAAZF,CAAmBG,OAAnBH,CAA2BI,KAAK,IAAI;IAClCA,KAAK,CAACC,QAAND,CAAgBE,KAAD,IAAsB;MACnCC,MAAM,CAACC,MAAPD,CAAcD,KAAK,CAACA,KAANA,CAAYG,WAAZH,EAAdC,EAAyCJ,OAAzCI,CAAkDG,OAAD,IAAkB;QACjE,IAAIA,OAAO,CAACC,MAARD,KAAmB,KAAvB,EAA8B;UAC5BT,SAAS,CAACW,IAAVX,CAAeS,OAAfT;QACD;MAHH;IADF;EADF;EAUA,OAAO,MAAMY,kBAAkB,CAAC,MAAMZ,SAAS,CAACa,IAAVb,CAAeS,OAAO,IAAI,CAACA,OAAO,CAACC,MAAnCV,CAAP,CAA/B;AACD;;AAED,eAAeY,kBAAf,CAAkCE,SAAlC,EAA2E;EACzE,OAAOA,SAAS,EAAhB,EAAoB;IAClB,MAAM,IAAIC,OAAJ,CAAYC,OAAO,IAAIC,qBAAqB,CAACD,OAAD,CAA5C,CAAN;EACD;AACF","names":["waitForGLTFAssets","gltfObjects","remaining","scenes","forEach","scene","traverse","model","Object","values","getUniforms","uniform","loaded","push","waitWhileCondition","some","condition","Promise","resolve","requestAnimationFrame"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@deck.gl\\mesh-layers\\src\\scenegraph-layer\\gltf-utils.ts"],"sourcesContent":["/* global requestAnimationFrame */\nimport type {GroupNode, ModelNode} from '@luma.gl/experimental';\n\nexport async function waitForGLTFAssets(gltfObjects: {scenes: GroupNode[]}): Promise<void> {\n  const remaining: any[] = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse((model: ModelNode) => {\n      Object.values(model.model.getUniforms()).forEach((uniform: any) => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition: () => boolean): Promise<void> {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}