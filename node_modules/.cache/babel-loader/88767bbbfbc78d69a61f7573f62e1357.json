{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D } from '@luma.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport { OPERATION } from '../../lib/constants';\nimport { getMaskBounds, getMaskViewport } from './utils';\nimport log from '../../utils/log';\nexport default class MaskEffect {\n  constructor() {\n    _defineProperty(this, \"id\", 'mask-effect');\n\n    _defineProperty(this, \"props\", null);\n\n    _defineProperty(this, \"useInPicking\", true);\n\n    _defineProperty(this, \"dummyMaskMap\", void 0);\n\n    _defineProperty(this, \"channels\", []);\n\n    _defineProperty(this, \"masks\", null);\n\n    _defineProperty(this, \"maskPass\", void 0);\n\n    _defineProperty(this, \"maskMap\", void 0);\n\n    _defineProperty(this, \"lastViewport\", void 0);\n  }\n\n  preRender(gl, _ref) {\n    let {\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views\n    } = _ref;\n\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation === OPERATION.MASK);\n\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return;\n    }\n\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {\n        id: 'default-mask'\n      });\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    const channelMap = this._sortMaskChannels(maskLayers);\n\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    for (const maskId in channelMap) {\n      this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n  }\n\n  _renderChannel(channelInfo, _ref2) {\n    let {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    } = _ref2;\n    const oldChannelInfo = this.channels[channelInfo.index];\n\n    if (!oldChannelInfo) {\n      return;\n    }\n\n    const maskChanged = channelInfo === oldChannelInfo || oldChannelInfo.layers.length !== channelInfo.layers.length || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      this.lastViewport = viewport;\n      channelInfo.bounds = getMaskBounds({\n        layers: channelInfo.layers,\n        viewport\n      });\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        const {\n          maskPass,\n          maskMap\n        } = this;\n        const maskViewport = getMaskViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height\n        });\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n      }\n    }\n\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n  }\n\n  _sortMaskChannels(maskLayers) {\n    const channelMap = {};\n    let channelCount = 0;\n\n    for (const layer of maskLayers) {\n      const {\n        id\n      } = layer.root;\n      let channelInfo = channelMap[id];\n\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue;\n        }\n\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => (c === null || c === void 0 ? void 0 : c.id) === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n\n    return channelMap;\n  }\n\n  getModuleParameters() {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup() {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Texture2D","equals","MaskPass","OPERATION","getMaskBounds","getMaskViewport","log","MaskEffect","constructor","_defineProperty","preRender","gl","layers","layerFilter","viewports","onViewportActive","views","dummyMaskMap","width","height","maskLayers","filter","l","props","visible","operation","MASK","length","masks","channels","maskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","maskId","_renderChannel","channelInfo","oldChannelInfo","index","maskChanged","layerBounds","some","b","i","bounds","maskBounds","maskViewport","getBounds","render","pass","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","layer","root","warn","findIndex","c","push","getModuleParameters","maskChannels","cleanup","delete","undefined"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@deck.gl\\core\\src\\effects\\mask\\mask-effect.ts"],"sourcesContent":["import {Texture2D} from '@luma.gl/core';\n// import {readPixelsToArray} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport {OPERATION} from '../../lib/constants';\nimport {getMaskBounds, getMaskViewport} from './utils';\nimport log from '../../utils/log';\n\nimport type {Effect, PreRenderOptions} from '../../lib/effect';\nimport type Layer from '../../lib/layer';\nimport type Viewport from '../../viewports/viewport';\nimport type {MaskBounds} from './utils';\nimport type {CoordinateSystem} from '../../lib/constants';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: MaskBounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: MaskBounds;\n  maskBounds: MaskBounds;\n  layerBounds: MaskBounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views}: PreRenderOptions\n  ): void {\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation === OPERATION.MASK);\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return;\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    for (const maskId in channelMap) {\n      this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // // Debug show FBO contents on screen\n    // const color = readPixelsToArray(this.maskMap);\n    // let canvas = document.getElementById('fbo-canvas');\n    // if (!canvas) {\n    //   canvas = document.createElement('canvas');\n    //   canvas.id = 'fbo-canvas';\n    //   canvas.width = this.maskMap.width;\n    //   canvas.height = this.maskMap.height;\n    //   canvas.style.zIndex = 100;\n    //   canvas.style.position = 'absolute';\n    //   canvas.style.right = 0;\n    //   canvas.style.border = 'blue 1px solid';\n    //   canvas.style.width = '256px';\n    //   canvas.style.transform = 'scaleY(-1)';\n    //   document.body.appendChild(canvas);\n    // }\n    // const ctx = canvas.getContext('2d');\n    // const imageData = ctx.createImageData(this.maskMap.width, this.maskMap.height);\n    // for (let i = 0; i < color.length; i += 4) {\n    //   imageData.data[i + 0] = color[i + 0];\n    //   imageData.data[i + 1] = color[i + 1];\n    //   imageData.data[i + 2] = color[i + 2];\n    //   imageData.data[i + 3] = color[i + 3] + 128;\n    // }\n    // ctx.putImageData(imageData, 0, 0);\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      oldChannelInfo.layers.length !== channelInfo.layers.length ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      channelInfo.bounds = getMaskBounds({layers: channelInfo.layers, viewport});\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport = getMaskViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height\n        });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}