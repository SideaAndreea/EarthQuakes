{"ast":null,"code":"import * as mat4 from 'gl-matrix/mat4';\nimport * as vec4 from 'gl-matrix/vec4';\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from '../../lib/constants';\nimport memoize from '../../utils/memoize';\nconst ZERO_VECTOR = [0, 0, 0, 0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\nconst getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\nexport function getOffsetOrigin(viewport, coordinateSystem) {\n  let coordinateOrigin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_COORDINATE_ORIGIN;\n\n  if (coordinateOrigin.length < 3) {\n    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];\n  }\n\n  let shaderCoordinateOrigin = coordinateOrigin;\n  let geospatialOrigin;\n  let offsetMode = true;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;\n  }\n\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        geospatialOrigin = [0, 0, 0];\n        offsetMode = false;\n      }\n\n      break;\n\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n        shaderCoordinateOrigin[0] -= coordinateOrigin[0];\n        shaderCoordinateOrigin[1] -= coordinateOrigin[1];\n        shaderCoordinateOrigin[2] -= coordinateOrigin[2];\n      }\n\n      break;\n\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround);\n      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n      break;\n\n    case PROJECTION_MODE.GLOBE:\n      offsetMode = false;\n      geospatialOrigin = null;\n      break;\n\n    default:\n      offsetMode = false;\n  }\n\n  return {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  };\n}\n\nfunction calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {\n  const {\n    viewMatrixUncentered,\n    projectionMatrix\n  } = viewport;\n  let {\n    viewMatrix,\n    viewProjectionMatrix\n  } = viewport;\n  let projectionCenter = ZERO_VECTOR;\n  let originCommon = ZERO_VECTOR;\n  let cameraPosCommon = viewport.cameraPosition;\n  const {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);\n\n  if (offsetMode) {\n    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];\n    originCommon[3] = 1;\n    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n\n  return {\n    viewMatrix,\n    viewProjectionMatrix,\n    projectionCenter,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  };\n}\n\nexport function getUniformsFromViewport(_ref) {\n  let {\n    viewport,\n    devicePixelRatio = 1,\n    modelMatrix = null,\n    coordinateSystem = COORDINATE_SYSTEM.DEFAULT,\n    coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,\n    autoWrapLongitude = false\n  } = _ref;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  const uniforms = getMemoizedViewportUniforms({\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  });\n  uniforms.project_uWrapLongitude = autoWrapLongitude;\n  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;\n  return uniforms;\n}\n\nfunction calculateViewportUniforms(_ref2) {\n  let {\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  } = _ref2;\n  const {\n    projectionCenter,\n    viewProjectionMatrix,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);\n  const distanceScales = viewport.getDistanceScales();\n  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n  const focalDistance = vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;\n  const uniforms = {\n    project_uCoordinateSystem: coordinateSystem,\n    project_uProjectionMode: viewport.projectionMode,\n    project_uCoordinateOrigin: shaderCoordinateOrigin,\n    project_uCommonOrigin: originCommon.slice(0, 3),\n    project_uCenter: projectionCenter,\n    project_uPseudoMeters: Boolean(viewport._pseudoMeters),\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n    project_uFocalDistance: focalDistance,\n    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale,\n    project_uWrapLongitude: false,\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n    project_uModelMatrix: IDENTITY_MATRIX,\n    project_uCameraPosition: cameraPosCommon\n  };\n\n  if (geospatialOrigin) {\n    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);\n\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        if (!viewport._pseudoMeters) {\n          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;\n        }\n\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return uniforms;\n}","map":{"version":3,"mappings":"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","names":["mat4","vec4","COORDINATE_SYSTEM","PROJECTION_MODE","memoize","ZERO_VECTOR","VECTOR_TO_POINT_MATRIX","IDENTITY_MATRIX","DEFAULT_PIXELS_PER_UNIT2","DEFAULT_COORDINATE_ORIGIN","getMemoizedViewportUniforms","calculateViewportUniforms","getOffsetOrigin","viewport","coordinateSystem","coordinateOrigin","length","shaderCoordinateOrigin","geospatialOrigin","offsetMode","LNGLAT_OFFSETS","METER_OFFSETS","isGeospatial","Math","fround","longitude","latitude","projectionMode","WEB_MERCATOR","LNGLAT","CARTESIAN","WEB_MERCATOR_AUTO_OFFSET","center","unprojectPosition","IDENTITY","position","map","GLOBE","calculateMatrixAndOffset","viewMatrixUncentered","projectionMatrix","viewMatrix","viewProjectionMatrix","projectionCenter","originCommon","cameraPosCommon","cameraPosition","projectPosition","transformMat4","multiply","getUniformsFromViewport","devicePixelRatio","modelMatrix","DEFAULT","autoWrapLongitude","uniforms","project_uWrapLongitude","project_uModelMatrix","distanceScales","getDistanceScales","viewportSize","width","height","focalDistance","project_uCoordinateSystem","project_uProjectionMode","project_uCoordinateOrigin","project_uCommonOrigin","slice","project_uCenter","project_uPseudoMeters","Boolean","_pseudoMeters","project_uViewportSize","project_uDevicePixelRatio","project_uFocalDistance","project_uCommonUnitsPerMeter","unitsPerMeter","project_uCommonUnitsPerWorldUnit","project_uCommonUnitsPerWorldUnit2","project_uScale","scale","project_uViewProjectionMatrix","project_uCameraPosition","distanceScalesAtOrigin","unitsPerMeter2","unitsPerDegree","unitsPerDegree2"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\AplicaÈ›ii\\earthquakes\\node_modules\\@deck.gl\\core\\src\\shaderlib\\project\\viewport-uniforms.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable complexity, camelcase */\n\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec4 from 'gl-matrix/vec4';\n\nimport {COORDINATE_SYSTEM, PROJECTION_MODE} from '../../lib/constants';\n\nimport memoize from '../../utils/memoize';\n\nimport type Viewport from '../../viewports/viewport';\nimport type {CoordinateSystem} from '../../lib/constants';\nimport type {NumericArray} from '../../types/types';\n\ntype Vec3 = [number, number, number];\ntype Vec4 = [number, number, number, number];\n\n// To quickly set a vector to zero\nconst ZERO_VECTOR: Vec4 = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_PIXELS_PER_UNIT2: Vec3 = [0, 0, 0];\nconst DEFAULT_COORDINATE_ORIGIN: Vec3 = [0, 0, 0];\n\nconst getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\n\nexport function getOffsetOrigin(\n  viewport: Viewport,\n  coordinateSystem: CoordinateSystem,\n  coordinateOrigin: Vec3 = DEFAULT_COORDINATE_ORIGIN\n): {\n  geospatialOrigin: Vec3 | null;\n  shaderCoordinateOrigin: Vec3;\n  offsetMode: boolean;\n} {\n  if (coordinateOrigin.length < 3) {\n    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];\n  }\n\n  let shaderCoordinateOrigin = coordinateOrigin;\n  let geospatialOrigin: Vec3 | null;\n  let offsetMode = true;\n\n  if (\n    coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS\n  ) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial\n      ? // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports\n        [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]\n      : null;\n  }\n\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (\n        coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n        coordinateSystem === COORDINATE_SYSTEM.CARTESIAN\n      ) {\n        geospatialOrigin = [0, 0, 0];\n        offsetMode = false;\n      }\n      break;\n\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        // viewport center in world space\n        // @ts-expect-error when using LNGLAT coordinates, we expect the viewport to be geospatial, in which case geospatialOrigin is defined\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        // viewport center in common space\n        shaderCoordinateOrigin = [\n          Math.fround(viewport.center[0]),\n          Math.fround(viewport.center[1]),\n          0\n        ];\n        // Geospatial origin (wgs84) must match shaderCoordinateOrigin (common)\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n        shaderCoordinateOrigin[0] -= coordinateOrigin[0];\n        shaderCoordinateOrigin[1] -= coordinateOrigin[1];\n        shaderCoordinateOrigin[2] -= coordinateOrigin[2];\n      }\n      break;\n\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround) as Vec3;\n      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n      break;\n\n    case PROJECTION_MODE.GLOBE:\n      offsetMode = false;\n      geospatialOrigin = null;\n      break;\n\n    default:\n      // Unknown projection mode\n      offsetMode = false;\n  }\n\n  return {geospatialOrigin, shaderCoordinateOrigin, offsetMode};\n}\n\n// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\nfunction calculateMatrixAndOffset(\n  viewport: Viewport,\n  coordinateSystem: CoordinateSystem,\n  coordinateOrigin: Vec3\n): {\n  viewMatrix: NumericArray;\n  viewProjectionMatrix: NumericArray;\n  projectionCenter: Vec4;\n  originCommon: Vec4;\n  cameraPosCommon: Vec3;\n  shaderCoordinateOrigin: Vec3;\n  geospatialOrigin: Vec3 | null;\n} {\n  const {viewMatrixUncentered, projectionMatrix} = viewport;\n  let {viewMatrix, viewProjectionMatrix} = viewport;\n\n  let projectionCenter = ZERO_VECTOR;\n  let originCommon: Vec4 = ZERO_VECTOR;\n  let cameraPosCommon: Vec3 = viewport.cameraPosition as Vec3;\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  if (offsetMode) {\n    // Calculate transformed projectionCenter (using 64 bit precision JS)\n    // This is the key to offset mode precision\n    // (avoids doing this addition in 32 bit precision in GLSL)\n    // @ts-expect-error the 4th component is assigned below\n    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n\n    cameraPosCommon = [\n      cameraPosCommon[0] - originCommon[0],\n      cameraPosCommon[1] - originCommon[1],\n      cameraPosCommon[2] - originCommon[2]\n    ];\n\n    originCommon[3] = 1;\n\n    // projectionCenter = new Matrix4(viewProjectionMatrix)\n    //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);\n\n    // Always apply uncentered projection matrix if available (shader adds center)\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n\n    // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n    // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n    //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n\n  return {\n    viewMatrix,\n    viewProjectionMatrix,\n    projectionCenter,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  };\n}\n\nexport type ProjectUniforms = {\n  project_uCoordinateSystem: number;\n  project_uProjectionMode: number;\n  project_uCoordinateOrigin: Vec3;\n  project_uCommonOrigin: Vec3;\n  project_uCenter: Vec4;\n  // Backward compatibility\n  // TODO: remove in v9\n  project_uPseudoMeters: boolean;\n\n  // Screen size\n  project_uViewportSize: [number, number];\n  project_uDevicePixelRatio: number;\n\n  project_uFocalDistance: number;\n  project_uCommonUnitsPerMeter: Vec3;\n  project_uCommonUnitsPerWorldUnit: Vec3;\n  project_uCommonUnitsPerWorldUnit2: Vec3;\n  /** 2^zoom */\n  project_uScale: number;\n  project_uWrapLongitude: boolean;\n\n  project_uViewProjectionMatrix: NumericArray;\n  project_uModelMatrix: NumericArray;\n\n  // This is for lighting calculations\n  project_uCameraPosition: Vec3;\n};\n\nexport type ProjectModuleSettings = {\n  viewport: Viewport;\n  devicePixelRatio?: number;\n  modelMatrix?: NumericArray | null;\n  coordinateSystem?: CoordinateSystem;\n  coordinateOrigin?: Vec3;\n  autoWrapLongitude?: boolean;\n};\n\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nexport function getUniformsFromViewport({\n  viewport,\n  devicePixelRatio = 1,\n  modelMatrix = null,\n  // Match Layer.defaultProps\n  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,\n  autoWrapLongitude = false\n}: ProjectModuleSettings): ProjectUniforms {\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  const uniforms = getMemoizedViewportUniforms({\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  });\n\n  uniforms.project_uWrapLongitude = autoWrapLongitude;\n  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;\n\n  return uniforms;\n}\n\nfunction calculateViewportUniforms({\n  viewport,\n  devicePixelRatio,\n  coordinateSystem,\n  coordinateOrigin\n}: {\n  viewport: Viewport;\n  devicePixelRatio: number;\n  coordinateSystem: CoordinateSystem;\n  coordinateOrigin: Vec3;\n}): ProjectUniforms {\n  const {\n    projectionCenter,\n    viewProjectionMatrix,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);\n\n  // Calculate projection pixels per unit\n  const distanceScales = viewport.getDistanceScales();\n\n  const viewportSize: [number, number] = [\n    viewport.width * devicePixelRatio,\n    viewport.height * devicePixelRatio\n  ];\n\n  // Distance at which screen pixels are projected.\n  // Used to scale sizes in clipspace to match screen pixels.\n  // When using Viewport class's default projection matrix, this yields 1 for orthographic\n  // and `viewport.focalDistance` for perspective views\n  const focalDistance =\n    vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;\n\n  const uniforms: ProjectUniforms = {\n    // Projection mode values\n    project_uCoordinateSystem: coordinateSystem,\n    project_uProjectionMode: viewport.projectionMode,\n    project_uCoordinateOrigin: shaderCoordinateOrigin,\n    project_uCommonOrigin: originCommon.slice(0, 3) as Vec3,\n    project_uCenter: projectionCenter,\n\n    // Backward compatibility\n    // TODO: remove in v9\n    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport\n    project_uPseudoMeters: Boolean(viewport._pseudoMeters),\n\n    // Screen size\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n\n    project_uFocalDistance: focalDistance,\n    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter as Vec3,\n    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter as Vec3,\n    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale, // This is the mercator scale (2 ** zoom)\n    project_uWrapLongitude: false,\n\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n    project_uModelMatrix: IDENTITY_MATRIX,\n\n    // This is for lighting calculations\n    project_uCameraPosition: cameraPosCommon\n  };\n\n  if (geospatialOrigin) {\n    // Get high-precision DistanceScales from geospatial viewport\n    // TODO: stricter types in Viewport classes\n    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin) as {\n      unitsPerMeter: Vec3;\n      metersPerUnit: Vec3;\n      unitsPerMeter2: Vec3;\n      unitsPerDegree: Vec3;\n      degreesPerUnit: Vec3;\n      unitsPerDegree2: Vec3;\n    };\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        // @ts-expect-error _pseudoMeters only exists on WebMercatorView\n        if (!viewport._pseudoMeters) {\n          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;\n        }\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n\n      // a.k.a \"preprojected\" positions\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.project_uCommonUnitsPerWorldUnit2 = [\n          0,\n          0,\n          distanceScalesAtOrigin.unitsPerMeter2[2]\n        ];\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return uniforms;\n}\n"]},"metadata":{},"sourceType":"module"}