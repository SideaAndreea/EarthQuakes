{"ast":null,"code":"import { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst cameraPositionCartesian = new Vector3();\nconst toEye = new Vector3();\nconst cameraPositionEnu = new Vector3();\nconst extraVertexEnu = new Vector3();\nconst projectedOriginVector = new Vector3();\nconst enuToCartesianMatrix = new Matrix4();\nconst cartesianToEnuMatrix = new Matrix4();\nexport function getLodStatus(tile, frameState) {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\nexport function getProjectedRadius(tile, frameState) {\n  const {\n    topDownViewport: viewport\n  } = frameState;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);\n  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();\n  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n  const extraZ = projection * projection / cameraPositionEnu[2];\n  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();\n  return projectedRadius;\n}","map":{"version":3,"mappings":"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","names":["Matrix4","Vector3","Ellipsoid","cameraPositionCartesian","toEye","cameraPositionEnu","extraVertexEnu","projectedOriginVector","enuToCartesianMatrix","cartesianToEnuMatrix","getLodStatus","tile","frameState","lodMetricValue","isNaN","screenSize","getProjectedRadius","header","children","topDownViewport","viewport","mbsLat","mbs","mbsLon","mbsZ","mbsR","mbsCenterCartesian","boundingVolume","center","cameraPositionCartographic","unprojectPosition","cameraPosition","WGS84","cartographicToCartesian","copy","subtract","normalize","eastNorthUpToFixedFrame","invert","transform","projection","Math","sqrt","extraZ","extraVertexCartesian","extraVectorCartesian","radiusVector","cross","scale","sphereMbsBorderVertexCartesian","add","sphereMbsBorderVertexCartographic","cartesianToCartographic","projectedOrigin","project","projectedMbsBorderVertex","projectedRadius","magnitude"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@loaders.gl\\tiles\\src\\tileset\\helpers\\i3s-lod.ts"],"sourcesContent":["import {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport Tile3D from '../tile-3d';\nimport {FrameState} from './frame-state';\n\nconst cameraPositionCartesian = new Vector3();\nconst toEye = new Vector3();\nconst cameraPositionEnu = new Vector3();\nconst extraVertexEnu = new Vector3();\nconst projectedOriginVector = new Vector3();\nconst enuToCartesianMatrix = new Matrix4();\nconst cartesianToEnuMatrix = new Matrix4();\n\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile \n * @param frameState \n * @returns \n */\nexport function getLodStatus(tile: Tile3D, frameState: FrameState): 'DIG' | 'OUT' | 'DRAW' {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile: Tile3D, frameState: FrameState): number {\n  const {topDownViewport: viewport} = frameState;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);\n\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();\n  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(\n    cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]\n  );\n  const extraZ = (projection * projection) / cameraPositionEnu[2];\n  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(\n    sphereMbsBorderVertexCartesian\n  );\n  // ---------------------------\n\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(\n    sphereMbsBorderVertexCartographic as [number, number, number]\n  );\n  const projectedRadius = projectedOriginVector\n    .copy(projectedOrigin)\n    .subtract(projectedMbsBorderVertex)\n    .magnitude();\n  return projectedRadius;\n}\n"]},"metadata":{},"sourceType":"module"}