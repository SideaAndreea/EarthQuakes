{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/webgl';\nexport default class Tesselator {\n  constructor(opts) {\n    _defineProperty(this, \"opts\", void 0);\n\n    _defineProperty(this, \"typedArrayManager\", void 0);\n\n    _defineProperty(this, \"indexStarts\", [0]);\n\n    _defineProperty(this, \"vertexStarts\", [0]);\n\n    _defineProperty(this, \"vertexCount\", 0);\n\n    _defineProperty(this, \"instanceCount\", 0);\n\n    _defineProperty(this, \"attributes\", void 0);\n\n    _defineProperty(this, \"_attributeDefs\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"getGeometry\", void 0);\n\n    _defineProperty(this, \"geometryBuffer\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"positionSize\", void 0);\n\n    _defineProperty(this, \"normalize\", void 0);\n\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry(_ref) {\n    let {\n      startRow,\n      endRow\n    } = _ref;\n\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n\n    if (!ArrayBuffer.isView(value)) {\n      return null;\n    }\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  _rebuildGeometry(dataRange) {\n    if (!this.data) {\n      return;\n    }\n\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = normalizedGeometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n      }, startRow, endRow);\n\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n\n    this._forEachGeometry((geometry, dataIndex) => {\n      const normalizedGeometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(normalizedGeometry, context);\n    }, startRow, endRow);\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n\n}","map":{"version":3,"mappings":"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","names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","_defineProperty","attributes","typedArrayManager","_attributeDefs","updateGeometry","Object","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","value","ArrayBuffer","isView","offset","stride","_allocate","instanceCount","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","geometry","indexStarts","vertexStarts","Infinity","normalizedData","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\AplicaÈ›ii\\earthquakes\\node_modules\\@deck.gl\\core\\src\\utils\\tesselator.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}