{"ast":null,"code":"import { isBrowser } from '@loaders.gl/worker-utils';\nimport { WorkerFarm, getWorkerURL } from '@loaders.gl/worker-utils';\nexport function canParseWithWorker(loader, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  if (!isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {\n    return false;\n  }\n\n  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);\n}\nexport async function parseWithWorker(loader, data, options, context, parseOnMainThread) {\n  const name = loader.id;\n  const url = getWorkerURL(loader, options);\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({\n    name,\n    url\n  });\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));\n  job.postMessage('process', {\n    input: data,\n    options,\n    context\n  });\n  const result = await job.result;\n  return await result.result;\n}\n\nasync function onMessage(parseOnMainThread, job, type, payload) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      const {\n        id,\n        input,\n        options\n      } = payload;\n\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {\n          id,\n          result\n        });\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {\n          id,\n          error: message\n        });\n      }\n\n      break;\n\n    default:\n      console.warn(\"parse-with-worker unknown message \".concat(type));\n  }\n}","map":{"version":3,"mappings":"AAAA,SAIEA,SAJF,QAKO,0BALP;AAOA,SAAQC,UAAR,EAAoBC,YAApB,QAAuC,0BAAvC;AAOA,OAAO,SAASC,kBAAT,CAA4BC,MAA5B,EAA4CC,OAA5C,EAAqE;EAC1E,IAAI,CAACJ,UAAU,CAACK,WAAXL,EAAL,EAA+B;IAC7B,OAAO,KAAP;EACD;;EAGD,IAAI,CAACD,SAAD,IAAc,EAACK,OAAD,SAACA,WAAD,WAACA,WAAO,CAAEE,YAAV,CAAlB,EAA0C;IACxC,OAAO,KAAP;EACD;;EAED,OAAOH,MAAM,CAACI,MAAPJ,KAAiBC,OAAjB,SAAiBA,WAAjB,WAAiBA,GAAjB,MAAiBA,UAAO,CAAEG,MAA1BJ,CAAP;AACD;AAMD,OAAO,eAAeK,eAAf,CACLL,MADK,EAELM,IAFK,EAGLL,OAHK,EAILM,OAJK,EAKLC,iBALK,EAML;EACA,MAAMC,IAAI,GAAGT,MAAM,CAACU,EAApB;EACA,MAAMC,GAAG,GAAGb,YAAY,CAACE,MAAD,EAASC,OAAT,CAAxB;EAEA,MAAMW,UAAU,GAAGf,UAAU,CAACgB,aAAXhB,CAAyBI,OAAzBJ,CAAnB;EACA,MAAMiB,UAAU,GAAGF,UAAU,CAACG,aAAXH,CAAyB;IAACH,IAAD;IAAOE;EAAP,CAAzBC,CAAnB;EAKAX,OAAO,GAAGe,IAAI,CAACC,KAALD,CAAWA,IAAI,CAACE,SAALF,CAAef,OAAfe,CAAXA,CAAVf;EACAM,OAAO,GAAGS,IAAI,CAACC,KAALD,CAAWA,IAAI,CAACE,SAALF,CAAeT,OAAO,IAAI,EAA1BS,CAAXA,CAAVT;EAEA,MAAMY,GAAG,GAAG,MAAML,UAAU,CAACM,QAAXN,CAChB,mBADgBA,EAGhBO,SAAS,CAACC,IAAVD,CAAe,IAAfA,EAAqBb,iBAArBa,CAHgBP,CAAlB;EAMAK,GAAG,CAACI,WAAJJ,CAAgB,SAAhBA,EAA2B;IAEzBK,KAAK,EAAElB,IAFkB;IAGzBL,OAHyB;IAIzBM;EAJyB,CAA3BY;EAOA,MAAMM,MAAM,GAAG,MAAMN,GAAG,CAACM,MAAzB;EAEA,OAAO,MAAMA,MAAM,CAACA,MAApB;AACD;;AAQD,eAAeJ,SAAf,CACEb,iBADF,EAEEW,GAFF,EAGEO,IAHF,EAIEC,OAJF,EAKE;EACA,QAAQD,IAAR;IACE,KAAK,MAAL;MACEP,GAAG,CAACS,IAAJT,CAASQ,OAATR;MACA;;IAEF,KAAK,OAAL;MACEA,GAAG,CAACU,KAAJV,CAAU,IAAIW,KAAJ,CAAUH,OAAO,CAACE,KAAlB,CAAVV;MACA;;IAEF,KAAK,SAAL;MAEE,MAAM;QAACT,EAAD;QAAKc,KAAL;QAAYvB;MAAZ,IAAuB0B,OAA7B;;MACA,IAAI;QACF,MAAMF,MAAM,GAAG,MAAMjB,iBAAiB,CAACgB,KAAD,EAAQvB,OAAR,CAAtC;QACAkB,GAAG,CAACI,WAAJJ,CAAgB,MAAhBA,EAAwB;UAACT,EAAD;UAAKe;QAAL,CAAxBN;MAFF,EAGE,OAAOU,KAAP,EAAc;QACd,MAAME,OAAO,GAAGF,KAAK,YAAYC,KAAjBD,GAAyBA,KAAK,CAACE,OAA/BF,GAAyC,eAAzD;QACAV,GAAG,CAACI,WAAJJ,CAAgB,OAAhBA,EAAyB;UAACT,EAAD;UAAKmB,KAAK,EAAEE;QAAZ,CAAzBZ;MACD;;MACD;;IAEF;MAEEa,OAAO,CAACC,IAARD,6CAAkDN,IAAlD;EAvBJ;AAyBD","names":["isBrowser","WorkerFarm","getWorkerURL","canParseWithWorker","loader","options","isSupported","_nodeWorkers","worker","parseWithWorker","data","context","parseOnMainThread","name","id","url","workerFarm","getWorkerFarm","workerPool","getWorkerPool","JSON","parse","stringify","job","startJob","onMessage","bind","postMessage","input","result","type","payload","done","error","Error","message","console","warn"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\AplicaÈ›ii\\earthquakes\\node_modules\\@loaders.gl\\loader-utils\\src\\lib\\worker-loader-utils\\parse-with-worker.ts"],"sourcesContent":["import {\n  WorkerJob,\n  WorkerMessageType,\n  WorkerMessagePayload,\n  isBrowser\n} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  // Node workers are still experimental\n  if (!isBrowser && !options?._nodeWorkers) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data: any,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // context.fetch & context.parse functions cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // @ts-expect-error\n    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options,\n    context\n  });\n\n  const result = await job.result;\n  // TODO - what is going on here?\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread: (arrayBuffer: ArrayBuffer, options?: {[key: string]: any}) => Promise<void>,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}