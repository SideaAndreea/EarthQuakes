{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Stats } from '@probe.gl/stats';\nimport { RequestScheduler, assert, path } from '@loaders.gl/loader-utils';\nimport TilesetCache from './tileset-cache';\nimport { calculateTransformProps } from './helpers/transform-utils';\nimport { getFrameState, limitSelectedTiles } from './helpers/frame-state';\nimport { getZoomFromBoundingVolume, getZoomFromExtent, getZoomFromFullExtent } from './helpers/zoom';\nimport Tile3D from './tile-3d';\nimport Tileset3DTraverser from './traversers/tileset-3d-traverser';\nimport TilesetTraverser from './traversers/tileset-traverser';\nimport I3SetTraverser from './traversers/i3s-tileset-traverser';\nimport { TILESET_TYPE } from '../constants';\nconst DEFAULT_PROPS = {\n  description: '',\n  ellipsoid: Ellipsoid.WGS84,\n  modelMatrix: new Matrix4(),\n  throttleRequests: true,\n  maxRequests: 64,\n  maximumMemoryUsage: 32,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {},\n  onTraversalComplete: selectedTiles => selectedTiles,\n  contentLoader: undefined,\n  viewDistanceScale: 1.0,\n  maximumScreenSpaceError: 8,\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: '',\n  i3s: {}\n};\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points/Vertices';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\nexport default class Tileset3D {\n  constructor(json, options) {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"loadOptions\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"tileset\", void 0);\n\n    _defineProperty(this, \"loader\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"basePath\", void 0);\n\n    _defineProperty(this, \"modelMatrix\", void 0);\n\n    _defineProperty(this, \"ellipsoid\", void 0);\n\n    _defineProperty(this, \"lodMetricType\", void 0);\n\n    _defineProperty(this, \"lodMetricValue\", void 0);\n\n    _defineProperty(this, \"refine\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"roots\", void 0);\n\n    _defineProperty(this, \"asset\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"extras\", void 0);\n\n    _defineProperty(this, \"attributions\", void 0);\n\n    _defineProperty(this, \"credits\", void 0);\n\n    _defineProperty(this, \"stats\", void 0);\n\n    _defineProperty(this, \"traverseCounter\", void 0);\n\n    _defineProperty(this, \"geometricError\", void 0);\n\n    _defineProperty(this, \"selectedTiles\", void 0);\n\n    _defineProperty(this, \"updatePromise\", null);\n\n    _defineProperty(this, \"tilesetInitializationPromise\", void 0);\n\n    _defineProperty(this, \"cartographicCenter\", void 0);\n\n    _defineProperty(this, \"cartesianCenter\", void 0);\n\n    _defineProperty(this, \"zoom\", void 0);\n\n    _defineProperty(this, \"boundingVolume\", void 0);\n\n    _defineProperty(this, \"gpuMemoryUsageInBytes\", void 0);\n\n    _defineProperty(this, \"dynamicScreenSpaceErrorComputedDensity\", void 0);\n\n    _defineProperty(this, \"_traverser\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    _defineProperty(this, \"_requestScheduler\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    _defineProperty(this, \"_queryParamsString\", void 0);\n\n    _defineProperty(this, \"_queryParams\", void 0);\n\n    _defineProperty(this, \"_extensionsUsed\", void 0);\n\n    _defineProperty(this, \"_tiles\", void 0);\n\n    _defineProperty(this, \"_pendingCount\", void 0);\n\n    _defineProperty(this, \"lastUpdatedVieports\", void 0);\n\n    _defineProperty(this, \"_requestedTiles\", void 0);\n\n    _defineProperty(this, \"_emptyTiles\", void 0);\n\n    _defineProperty(this, \"frameStateData\", void 0);\n\n    _defineProperty(this, \"maximumMemoryUsage\", void 0);\n\n    assert(json);\n    this.options = { ...DEFAULT_PROPS,\n      ...options\n    };\n    this.tileset = json;\n    this.loader = json.loader;\n    this.type = json.type;\n    this.url = json.url;\n    this.basePath = json.basePath || path.dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n    this.lodMetricType = json.lodMetricType;\n    this.lodMetricValue = json.lodMetricValue;\n    this.refine = json.root.refine;\n    this.loadOptions = this.options.loadOptions || {};\n    this.root = null;\n    this.roots = {};\n    this.cartographicCenter = null;\n    this.cartesianCenter = null;\n    this.zoom = 1;\n    this.boundingVolume = null;\n    this.traverseCounter = 0;\n    this.geometricError = 0;\n    this._traverser = this._initializeTraverser();\n    this._cache = new TilesetCache();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    this._frameNumber = 0;\n    this._pendingCount = 0;\n    this._tiles = {};\n    this.selectedTiles = [];\n    this._emptyTiles = [];\n    this._requestedTiles = [];\n    this.frameStateData = {};\n    this.lastUpdatedVieports = null;\n    this._queryParams = {};\n    this._queryParamsString = '';\n    this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;\n    this.gpuMemoryUsageInBytes = 0;\n    this.stats = new Stats({\n      id: this.url\n    });\n\n    this._initializeStats();\n\n    this._extensionsUsed = undefined;\n    this.dynamicScreenSpaceErrorComputedDensity = 0.0;\n    this.extras = null;\n    this.asset = {};\n    this.credits = {};\n    this.description = this.options.description || '';\n    this.tilesetInitializationPromise = this._initializeTileSet(json);\n  }\n\n  destroy() {\n    this._destroy();\n  }\n\n  isLoaded() {\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n\n  get frameNumber() {\n    return this._frameNumber;\n  }\n\n  get queryParams() {\n    if (!this._queryParamsString) {\n      this._queryParamsString = getQueryParamString(this._queryParams);\n    }\n\n    return this._queryParamsString;\n  }\n\n  setProps(props) {\n    this.options = { ...this.options,\n      ...props\n    };\n  }\n\n  setOptions(options) {\n    this.options = { ...this.options,\n      ...options\n    };\n  }\n\n  getTileUrl(tilePath) {\n    const isDataUrl = tilePath.startsWith('data:');\n\n    if (isDataUrl) {\n      return tilePath;\n    }\n\n    return \"\".concat(tilePath).concat(this.queryParams);\n  }\n\n  hasExtension(extensionName) {\n    return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);\n  }\n\n  update() {\n    let viewports = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.tilesetInitializationPromise.then(() => {\n      if (!viewports && this.lastUpdatedVieports) {\n        viewports = this.lastUpdatedVieports;\n      } else {\n        this.lastUpdatedVieports = viewports;\n      }\n\n      if (viewports) {\n        this.doUpdate(viewports);\n      }\n    });\n  }\n\n  async selectTiles() {\n    let viewports = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    await this.tilesetInitializationPromise;\n\n    if (viewports) {\n      this.lastUpdatedVieports = viewports;\n    }\n\n    if (!this.updatePromise) {\n      this.updatePromise = new Promise(resolve => {\n        setTimeout(() => {\n          if (this.lastUpdatedVieports) {\n            this.doUpdate(this.lastUpdatedVieports);\n          }\n\n          resolve(this._frameNumber);\n          this.updatePromise = null;\n        }, this.options.debounceTime);\n      });\n    }\n\n    return this.updatePromise;\n  }\n\n  doUpdate(viewports) {\n    if ('loadTiles' in this.options && !this.options.loadTiles) {\n      return;\n    }\n\n    if (this.traverseCounter > 0) {\n      return;\n    }\n\n    const preparedViewports = viewports instanceof Array ? viewports : [viewports];\n\n    this._cache.reset();\n\n    this._frameNumber++;\n    this.traverseCounter = preparedViewports.length;\n    const viewportsToTraverse = [];\n\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n\n      if (this._needTraverse(id)) {\n        viewportsToTraverse.push(id);\n      } else {\n        this.traverseCounter--;\n      }\n    }\n\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n\n      if (!this.roots[id]) {\n        this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n      }\n\n      if (!viewportsToTraverse.includes(id)) {\n        continue;\n      }\n\n      const frameState = getFrameState(viewport, this._frameNumber);\n\n      this._traverser.traverse(this.roots[id], frameState, this.options);\n    }\n  }\n\n  _needTraverse(viewportId) {\n    let traverserId = viewportId;\n\n    if (this.options.viewportTraversersMap) {\n      traverserId = this.options.viewportTraversersMap[viewportId];\n    }\n\n    if (traverserId !== viewportId) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _onTraversalEnd(frameState) {\n    const id = frameState.viewport.id;\n\n    if (!this.frameStateData[id]) {\n      this.frameStateData[id] = {\n        selectedTiles: [],\n        _requestedTiles: [],\n        _emptyTiles: []\n      };\n    }\n\n    const currentFrameStateData = this.frameStateData[id];\n    const selectedTiles = Object.values(this._traverser.selectedTiles);\n    const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);\n    currentFrameStateData.selectedTiles = filteredSelectedTiles;\n\n    for (const tile of unselectedTiles) {\n      tile.unselect();\n    }\n\n    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n    this.traverseCounter--;\n\n    if (this.traverseCounter > 0) {\n      return;\n    }\n\n    this._updateTiles();\n  }\n\n  _updateTiles() {\n    this.selectedTiles = [];\n    this._requestedTiles = [];\n    this._emptyTiles = [];\n\n    for (const frameStateKey in this.frameStateData) {\n      const frameStateDataValue = this.frameStateData[frameStateKey];\n      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n    }\n\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n    for (const tile of this.selectedTiles) {\n      this._tiles[tile.id] = tile;\n    }\n\n    this._loadTiles();\n\n    this._unloadTiles();\n\n    this._updateStats();\n  }\n\n  _tilesChanged(oldSelectedTiles, selectedTiles) {\n    if (oldSelectedTiles.length !== selectedTiles.length) {\n      return true;\n    }\n\n    const set1 = new Set(oldSelectedTiles.map(t => t.id));\n    const set2 = new Set(selectedTiles.map(t => t.id));\n    let changed = oldSelectedTiles.filter(x => !set2.has(x.id)).length > 0;\n    changed = changed || selectedTiles.filter(x => !set1.has(x.id)).length > 0;\n    return changed;\n  }\n\n  _loadTiles() {\n    for (const tile of this._requestedTiles) {\n      if (tile.contentUnloaded) {\n        this._loadTile(tile);\n      }\n    }\n  }\n\n  _unloadTiles() {\n    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n  }\n\n  _updateStats() {\n    let tilesRenderable = 0;\n    let pointsRenderable = 0;\n\n    for (const tile of this.selectedTiles) {\n      if (tile.contentAvailable && tile.content) {\n        tilesRenderable++;\n\n        if (tile.content.pointCount) {\n          pointsRenderable += tile.content.pointCount;\n        } else {\n          pointsRenderable += tile.content.vertexCount;\n        }\n      }\n    }\n\n    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n    this.stats.get(POINTS_COUNT).count = pointsRenderable;\n  }\n\n  async _initializeTileSet(tilesetJson) {\n    if (this.type === TILESET_TYPE.I3S) {\n      this.calculateViewPropsI3S();\n      tilesetJson.root = await tilesetJson.root;\n    }\n\n    this.root = this._initializeTileHeaders(tilesetJson, null);\n\n    if (this.type === TILESET_TYPE.TILES3D) {\n      this._initializeTiles3DTileset(tilesetJson);\n\n      this.calculateViewPropsTiles3D();\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      this._initializeI3STileset();\n    }\n  }\n\n  calculateViewPropsI3S() {\n    var _this$tileset$store;\n\n    const fullExtent = this.tileset.fullExtent;\n\n    if (fullExtent) {\n      const {\n        xmin,\n        xmax,\n        ymin,\n        ymax,\n        zmin,\n        zmax\n      } = fullExtent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);\n      this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());\n      this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n\n    const extent = (_this$tileset$store = this.tileset.store) === null || _this$tileset$store === void 0 ? void 0 : _this$tileset$store.extent;\n\n    if (extent) {\n      const [xmin, ymin, xmax, ymax] = extent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);\n      this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());\n      this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n\n    console.warn('Extent is not defined in the tileset header');\n    this.cartographicCenter = new Vector3();\n    this.zoom = 1;\n    return;\n  }\n\n  calculateViewPropsTiles3D() {\n    const root = this.root;\n    assert(root);\n    const {\n      center\n    } = root.boundingVolume;\n\n    if (!center) {\n      console.warn('center was not pre-calculated for the root tile');\n      this.cartographicCenter = new Vector3();\n      this.zoom = 1;\n      return;\n    }\n\n    if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {\n      this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());\n    } else {\n      this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);\n    }\n\n    this.cartesianCenter = center;\n    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n  }\n\n  _initializeStats() {\n    this.stats.get(TILES_TOTAL);\n    this.stats.get(TILES_LOADING);\n    this.stats.get(TILES_IN_MEMORY);\n    this.stats.get(TILES_IN_VIEW);\n    this.stats.get(TILES_RENDERABLE);\n    this.stats.get(TILES_LOADED);\n    this.stats.get(TILES_UNLOADED);\n    this.stats.get(TILES_LOAD_FAILED);\n    this.stats.get(POINTS_COUNT, 'memory');\n    this.stats.get(TILES_GPU_MEMORY, 'memory');\n  }\n\n  _initializeTileHeaders(tilesetJson, parentTileHeader) {\n    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);\n\n    if (parentTileHeader) {\n      parentTileHeader.children.push(rootTile);\n      rootTile.depth = parentTileHeader.depth + 1;\n    }\n\n    if (this.type === TILESET_TYPE.TILES3D) {\n      const stack = [];\n      stack.push(rootTile);\n\n      while (stack.length > 0) {\n        const tile = stack.pop();\n        this.stats.get(TILES_TOTAL).incrementCount();\n        const children = tile.header.children || [];\n\n        for (const childHeader of children) {\n          const childTile = new Tile3D(this, childHeader, tile);\n          tile.children.push(childTile);\n          childTile.depth = tile.depth + 1;\n          stack.push(childTile);\n        }\n      }\n    }\n\n    return rootTile;\n  }\n\n  _initializeTraverser() {\n    let TraverserClass;\n    const type = this.type;\n\n    switch (type) {\n      case TILESET_TYPE.TILES3D:\n        TraverserClass = Tileset3DTraverser;\n        break;\n\n      case TILESET_TYPE.I3S:\n        TraverserClass = I3SetTraverser;\n        break;\n\n      default:\n        TraverserClass = TilesetTraverser;\n    }\n\n    return new TraverserClass({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n\n  _destroyTileHeaders(parentTile) {\n    this._destroySubtree(parentTile);\n  }\n\n  async _loadTile(tile) {\n    let loaded;\n\n    try {\n      this._onStartTileLoading();\n\n      loaded = await tile.loadContent();\n    } catch (error) {\n      this._onTileLoadError(tile, error);\n    } finally {\n      this._onEndTileLoading();\n\n      this._onTileLoad(tile, loaded);\n    }\n  }\n\n  _onTileLoadError(tile, error) {\n    this.stats.get(TILES_LOAD_FAILED).incrementCount();\n    const message = error.message || error.toString();\n    const url = tile.url;\n    console.error(\"A 3D tile failed to load: \".concat(tile.url, \" \").concat(message));\n    this.options.onTileError(tile, message, url);\n  }\n\n  _onTileLoad(tile, loaded) {\n    if (!loaded) {\n      return;\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      var _this$tileset, _this$tileset$nodePag;\n\n      const nodesInNodePages = ((_this$tileset = this.tileset) === null || _this$tileset === void 0 ? void 0 : (_this$tileset$nodePag = _this$tileset.nodePagesTile) === null || _this$tileset$nodePag === void 0 ? void 0 : _this$tileset$nodePag.nodesInNodePages) || 0;\n      this.stats.get(TILES_TOTAL).reset();\n      this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);\n    }\n\n    if (tile && tile.content) {\n      calculateTransformProps(tile, tile.content);\n    }\n\n    this._addTileToCache(tile);\n\n    this.options.onTileLoad(tile);\n  }\n\n  _onStartTileLoading() {\n    this._pendingCount++;\n    this.stats.get(TILES_LOADING).incrementCount();\n  }\n\n  _onEndTileLoading() {\n    this._pendingCount--;\n    this.stats.get(TILES_LOADING).decrementCount();\n  }\n\n  _addTileToCache(tile) {\n    this._cache.add(this, tile, tileset => tileset._updateCacheStats(tile));\n  }\n\n  _updateCacheStats(tile) {\n    this.stats.get(TILES_LOADED).incrementCount();\n    this.stats.get(TILES_IN_MEMORY).incrementCount();\n    this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n  }\n\n  _unloadTile(tile) {\n    this.gpuMemoryUsageInBytes -= tile.content && tile.content.byteLength || 0;\n    this.stats.get(TILES_IN_MEMORY).decrementCount();\n    this.stats.get(TILES_UNLOADED).incrementCount();\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    this.options.onTileUnload(tile);\n    tile.unloadContent();\n  }\n\n  _destroy() {\n    const stack = [];\n\n    if (this.root) {\n      stack.push(this.root);\n    }\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n\n      this._destroyTile(tile);\n    }\n\n    this.root = null;\n  }\n\n  _destroySubtree(tile) {\n    const root = tile;\n    const stack = [];\n    stack.push(root);\n\n    while (stack.length > 0) {\n      tile = stack.pop();\n\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n\n      if (tile !== root) {\n        this._destroyTile(tile);\n      }\n    }\n\n    root.children = [];\n  }\n\n  _destroyTile(tile) {\n    this._cache.unloadTile(this, tile);\n\n    this._unloadTile(tile);\n\n    tile.destroy();\n  }\n\n  _initializeTiles3DTileset(tilesetJson) {\n    this.asset = tilesetJson.asset;\n\n    if (!this.asset) {\n      throw new Error('Tileset must have an asset property.');\n    }\n\n    if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {\n      throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');\n    }\n\n    if ('tilesetVersion' in this.asset) {\n      this._queryParams.v = this.asset.tilesetVersion;\n    }\n\n    this.credits = {\n      attributions: this.options.attributions || []\n    };\n    this.description = this.options.description || '';\n    this.properties = tilesetJson.properties;\n    this.geometricError = tilesetJson.geometricError;\n    this._extensionsUsed = tilesetJson.extensionsUsed;\n    this.extras = tilesetJson.extras;\n  }\n\n  _initializeI3STileset() {\n    if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n      this._queryParams.token = this.loadOptions.i3s.token;\n    }\n  }\n\n}\n\nfunction getQueryParamString(queryParams) {\n  const queryParamStrings = [];\n\n  for (const key of Object.keys(queryParams)) {\n    queryParamStrings.push(\"\".concat(key, \"=\").concat(queryParams[key]));\n  }\n\n  switch (queryParamStrings.length) {\n    case 0:\n      return '';\n\n    case 1:\n      return \"?\".concat(queryParamStrings[0]);\n\n    default:\n      return \"?\".concat(queryParamStrings.join('&'));\n  }\n}","map":{"version":3,"mappings":";AAsCA,SAAQA,OAAR,EAAiBC,OAAjB,QAA+B,eAA/B;AACA,SAAQC,SAAR,QAAwB,qBAAxB;AACA,SAAQC,KAAR,QAAoB,iBAApB;AACA,SACEC,gBADF,EAEEC,MAFF,EAGEC,IAHF,QAMO,0BANP;AAOA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,SAAQC,uBAAR,QAAsC,2BAAtC;AACA,SAAoBC,aAApB,EAAmCC,kBAAnC,QAA4D,uBAA5D;AACA,SAAQC,yBAAR,EAAmCC,iBAAnC,EAAsDC,qBAAtD,QAAkF,gBAAlF;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,kBAAP,MAA+B,mCAA/B;AACA,OAAOC,gBAAP,MAA6B,gCAA7B;AACA,OAAOC,cAAP,MAA2B,oCAA3B;AACA,SAAQC,YAAR,QAA2B,cAA3B;AA6DA,MAAMC,aAAoB,GAAG;EAC3BC,WAAW,EAAE,EADc;EAG3BC,SAAS,EAAEnB,SAAS,CAACoB,KAHM;EAK3BC,WAAW,EAAE,IAAIvB,OAAJ,EALc;EAQ3BwB,gBAAgB,EAAE,IARS;EAW3BC,WAAW,EAAE,EAXc;EAa3BC,kBAAkB,EAAE,EAbO;EAe3BC,oBAAoB,EAAE,CAfK;EAiB3BC,YAAY,EAAE,CAjBa;EAuB3BC,UAAU,EAAE,MAAM,CAvBS;EA4B3BC,YAAY,EAAE,MAAM,CA5BO;EA6B3BC,WAAW,EAAE,MAAM,CA7BQ;EAmC3BC,mBAAmB,EAAGC,aAAD,IAA6BA,aAnCvB;EAsC3BC,aAAa,EAAEC,SAtCY;EAyC3BC,iBAAiB,EAAE,GAzCQ;EA4C3BC,uBAAuB,EAAE,CA5CE;EA8C3BC,SAAS,EAAE,IA9CgB;EA+C3BC,gBAAgB,EAAE,IA/CS;EAgD3BC,qBAAqB,EAAE,IAhDI;EAkD3BC,WAAW,EAAE;IAACC,KAAK,EAAE;EAAR,CAlDc;EAoD3BC,YAAY,EAAE,EApDa;EAqD3BC,QAAQ,EAAE,EArDiB;EAuD3BC,GAAG,EAAE;AAvDsB,CAA7B;AA2DA,MAAMC,WAAW,GAAG,qBAApB;AACA,MAAMC,eAAe,GAAG,iBAAxB;AACA,MAAMC,aAAa,GAAG,eAAtB;AACA,MAAMC,gBAAgB,GAAG,iBAAzB;AACA,MAAMC,YAAY,GAAG,cAArB;AACA,MAAMC,aAAa,GAAG,eAAtB;AACA,MAAMC,cAAc,GAAG,gBAAvB;AACA,MAAMC,iBAAiB,GAAG,mBAA1B;AACA,MAAMC,YAAY,GAAG,iBAArB;AACA,MAAMC,gBAAgB,GAAG,iBAAzB;AAEA,eAAe,MAAMC,SAAN,CAAgB;EAyE7BC,WAAW,CAACC,IAAD,EAAYC,OAAZ,EAAsC;IAAAC;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA,uCA3CD,IA2CC;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAC/CvD,MAAM,CAACqD,IAAD,CAANrD;IAGA,KAAKsD,OAAL,GAAe,EAAC,GAAGxC,aAAJ;MAAmB,GAAGwC;IAAtB,CAAf;IAEA,KAAKE,OAAL,GAAeH,IAAf;IACA,KAAKI,MAAL,GAAcJ,IAAI,CAACI,MAAnB;IAEA,KAAKC,IAAL,GAAYL,IAAI,CAACK,IAAjB;IAEA,KAAKC,GAAL,GAAWN,IAAI,CAACM,GAAhB;IACA,KAAKpB,QAAL,GAAgBc,IAAI,CAACd,QAALc,IAAiBpD,IAAI,CAAC2D,OAAL3D,CAAa,KAAK0D,GAAlB1D,CAAjC;IACA,KAAKiB,WAAL,GAAmB,KAAKoC,OAAL,CAAapC,WAAhC;IACA,KAAKF,SAAL,GAAiB,KAAKsC,OAAL,CAAatC,SAA9B;IAGA,KAAK6C,aAAL,GAAqBR,IAAI,CAACQ,aAA1B;IACA,KAAKC,cAAL,GAAsBT,IAAI,CAACS,cAA3B;IACA,KAAKC,MAAL,GAAcV,IAAI,CAACW,IAALX,CAAUU,MAAxB;IAEA,KAAK3B,WAAL,GAAmB,KAAKkB,OAAL,CAAalB,WAAb,IAA4B,EAA/C;IAEA,KAAK4B,IAAL,GAAY,IAAZ;IACA,KAAKC,KAAL,GAAa,EAAb;IAEA,KAAKC,kBAAL,GAA0B,IAA1B;IACA,KAAKC,eAAL,GAAuB,IAAvB;IACA,KAAKC,IAAL,GAAY,CAAZ;IACA,KAAKC,cAAL,GAAsB,IAAtB;IAGA,KAAKC,eAAL,GAAuB,CAAvB;IACA,KAAKC,cAAL,GAAsB,CAAtB;IACA,KAAKC,UAAL,GAAkB,KAAKC,oBAAL,EAAlB;IACA,KAAKC,MAAL,GAAc,IAAIxE,YAAJ,EAAd;IACA,KAAKyE,iBAAL,GAAyB,IAAI5E,gBAAJ,CAAqB;MAC5CoB,gBAAgB,EAAE,KAAKmC,OAAL,CAAanC,gBADa;MAE5CC,WAAW,EAAE,KAAKkC,OAAL,CAAalC;IAFkB,CAArB,CAAzB;IAMA,KAAKwD,YAAL,GAAoB,CAApB;IAGA,KAAKC,aAAL,GAAqB,CAArB;IAGA,KAAKC,MAAL,GAAc,EAAd;IACA,KAAKlD,aAAL,GAAqB,EAArB;IACA,KAAKmD,WAAL,GAAmB,EAAnB;IACA,KAAKC,eAAL,GAAuB,EAAvB;IACA,KAAKC,cAAL,GAAsB,EAAtB;IACA,KAAKC,mBAAL,GAA2B,IAA3B;IAEA,KAAKC,YAAL,GAAoB,EAApB;IACA,KAAKC,kBAAL,GAA0B,EAA1B;IAKA,KAAK/D,kBAAL,GAA0B,KAAKiC,OAAL,CAAajC,kBAAb,IAAmC,EAA7D;IAEA,KAAKgE,qBAAL,GAA6B,CAA7B;IACA,KAAKC,KAAL,GAAa,IAAIxF,KAAJ,CAAU;MAACyF,EAAE,EAAE,KAAK5B;IAAV,CAAV,CAAb;;IACA,KAAK6B,gBAAL;;IAGA,KAAKC,eAAL,GAAuB3D,SAAvB;IACA,KAAK4D,sCAAL,GAA8C,GAA9C;IAEA,KAAKC,MAAL,GAAc,IAAd;IACA,KAAKC,KAAL,GAAa,EAAb;IACA,KAAKC,OAAL,GAAe,EAAf;IACA,KAAK9E,WAAL,GAAmB,KAAKuC,OAAL,CAAavC,WAAb,IAA4B,EAA/C;IAEA,KAAK+E,4BAAL,GAAoC,KAAKC,kBAAL,CAAwB1C,IAAxB,CAApC;EACD;;EAGD2C,OAAO,GAAS;IACd,KAAKC,QAAL;EACD;;EAGDC,QAAQ,GAAY;IAElB,OAAO,KAAKrB,aAAL,KAAuB,CAAvB,IAA4B,KAAKD,YAAL,KAAsB,CAAlD,IAAuD,KAAKI,eAAL,CAAqBmB,MAArB,KAAgC,CAA9F;EACD;;EAEQ,IAALC,KAAK,GAAa;IACpB,OAAOC,MAAM,CAACC,MAAPD,CAAc,KAAKvB,MAAnBuB,CAAP;EACD;;EAEc,IAAXE,WAAW,GAAW;IACxB,OAAO,KAAK3B,YAAZ;EACD;;EAEc,IAAX4B,WAAW,GAAW;IACxB,IAAI,CAAC,KAAKpB,kBAAV,EAA8B;MAC5B,KAAKA,kBAAL,GAA0BqB,mBAAmB,CAAC,KAAKtB,YAAN,CAA7C;IACD;;IACD,OAAO,KAAKC,kBAAZ;EACD;;EAEDsB,QAAQ,CAACC,KAAD,EAA8B;IACpC,KAAKrD,OAAL,GAAe,EAAC,GAAG,KAAKA,OAAT;MAAkB,GAAGqD;IAArB,CAAf;EACD;;EAGDC,UAAU,CAACtD,OAAD,EAAgC;IACxC,KAAKA,OAAL,GAAe,EAAC,GAAG,KAAKA,OAAT;MAAkB,GAAGA;IAArB,CAAf;EACD;;EAMDuD,UAAU,CAACC,QAAD,EAA2B;IACnC,MAAMC,SAAS,GAAGD,QAAQ,CAACE,UAATF,CAAoB,OAApBA,CAAlB;;IACA,IAAIC,SAAJ,EAAe;MACb,OAAOD,QAAP;IACD;;IACD,iBAAUA,QAAV,SAAqB,KAAKN,WAA1B;EACD;;EAGDS,YAAY,CAACC,aAAD,EAAiC;IAC3C,OAAOC,OAAO,CAAC,KAAK1B,eAAL,IAAwB,KAAKA,eAAL,CAAqB2B,OAArB,CAA6BF,aAA7B,IAA8C,CAAC,CAAxE,CAAd;EACD;;EAODG,MAAM,GAAiD;IAAA,IAAhDC,SAAgD,uEAAN,IAAM;IAErD,KAAKxB,4BAAL,CAAkCyB,IAAlC,CAAuC,MAAM;MAC3C,IAAI,CAACD,SAAD,IAAc,KAAKpC,mBAAvB,EAA4C;QAC1CoC,SAAS,GAAG,KAAKpC,mBAAjBoC;MADF,OAEO;QACL,KAAKpC,mBAAL,GAA2BoC,SAA3B;MACD;;MACD,IAAIA,SAAJ,EAAe;QACb,KAAKE,QAAL,CAAcF,SAAd;MACD;IARH;EAUD;;EAQgB,MAAXG,WAAW,GAAkE;IAAA,IAAjEH,SAAiE,uEAAvB,IAAuB;IACjF,MAAM,KAAKxB,4BAAX;;IACA,IAAIwB,SAAJ,EAAe;MACb,KAAKpC,mBAAL,GAA2BoC,SAA3B;IACD;;IACD,IAAI,CAAC,KAAKI,aAAV,EAAyB;MACvB,KAAKA,aAAL,GAAqB,IAAIC,OAAJ,CAAqBC,OAAD,IAAa;QACpDC,UAAU,CAAC,MAAM;UACf,IAAI,KAAK3C,mBAAT,EAA8B;YAC5B,KAAKsC,QAAL,CAAc,KAAKtC,mBAAnB;UACD;;UACD0C,OAAO,CAAC,KAAKhD,YAAN,CAAPgD;UACA,KAAKF,aAAL,GAAqB,IAArB;QALQ,GAMP,KAAKpE,OAAL,CAAa/B,YANN,CAAVsG;MADmB,EAArB;IASD;;IACD,OAAO,KAAKH,aAAZ;EACD;;EAOOF,QAAQ,CAACF,SAAD,EAAyC;IACvD,IAAI,eAAe,KAAKhE,OAApB,IAA+B,CAAC,KAAKA,OAAL,CAAarB,SAAjD,EAA4D;MAC1D;IACD;;IACD,IAAI,KAAKqC,eAAL,GAAuB,CAA3B,EAA8B;MAC5B;IACD;;IACD,MAAMwD,iBAAiB,GAAGR,SAAS,YAAYS,KAArBT,GAA6BA,SAA7BA,GAAyC,CAACA,SAAD,CAAnE;;IAEA,KAAK5C,MAAL,CAAYsD,KAAZ;;IACA,KAAKpD,YAAL;IACA,KAAKN,eAAL,GAAuBwD,iBAAiB,CAAC3B,MAAzC;IACA,MAAM8B,mBAA6B,GAAG,EAAtC;;IAEA,KAAK,MAAMC,QAAX,IAAuBJ,iBAAvB,EAA0C;MACxC,MAAMvC,EAAE,GAAG2C,QAAQ,CAAC3C,EAApB;;MACA,IAAI,KAAK4C,aAAL,CAAmB5C,EAAnB,CAAJ,EAA4B;QAC1B0C,mBAAmB,CAACG,IAApBH,CAAyB1C,EAAzB0C;MADF,OAEO;QACL,KAAK3D,eAAL;MACD;IACF;;IAGD,KAAK,MAAM4D,QAAX,IAAuBJ,iBAAvB,EAA0C;MACxC,MAAMvC,EAAE,GAAG2C,QAAQ,CAAC3C,EAApB;;MACA,IAAI,CAAC,KAAKtB,KAAL,CAAWsB,EAAX,CAAL,EAAqB;QACnB,KAAKtB,KAAL,CAAWsB,EAAX,IAAiB,KAAK8C,sBAAL,CAA4B,KAAK7E,OAAjC,EAA0C,IAA1C,CAAjB;MACD;;MAED,IAAI,CAACyE,mBAAmB,CAACK,QAApBL,CAA6B1C,EAA7B0C,CAAL,EAAuC;QACrC;MACD;;MACD,MAAMM,UAAU,GAAGnI,aAAa,CAAC8H,QAAD,EAAW,KAAKtD,YAAhB,CAAhC;;MACA,KAAKJ,UAAL,CAAgBgE,QAAhB,CAAyB,KAAKvE,KAAL,CAAWsB,EAAX,CAAzB,EAAyCgD,UAAzC,EAAqD,KAAKjF,OAA1D;IACD;EACF;;EAOD6E,aAAa,CAACM,UAAD,EAA8B;IACzC,IAAIC,WAAW,GAAGD,UAAlB;;IACA,IAAI,KAAKnF,OAAL,CAAanB,qBAAjB,EAAwC;MACtCuG,WAAW,GAAG,KAAKpF,OAAL,CAAanB,qBAAb,CAAmCsG,UAAnC,CAAdC;IACD;;IACD,IAAIA,WAAW,KAAKD,UAApB,EAAgC;MAC9B,OAAO,KAAP;IACD;;IAED,OAAO,IAAP;EACD;;EAMDE,eAAe,CAACJ,UAAD,EAA+B;IAC5C,MAAMhD,EAAE,GAAGgD,UAAU,CAACL,QAAXK,CAAoBhD,EAA/B;;IACA,IAAI,CAAC,KAAKN,cAAL,CAAoBM,EAApB,CAAL,EAA8B;MAC5B,KAAKN,cAAL,CAAoBM,EAApB,IAA0B;QAAC3D,aAAa,EAAE,EAAhB;QAAoBoD,eAAe,EAAE,EAArC;QAAyCD,WAAW,EAAE;MAAtD,CAA1B;IACD;;IACD,MAAM6D,qBAAqB,GAAG,KAAK3D,cAAL,CAAoBM,EAApB,CAA9B;IACA,MAAM3D,aAAa,GAAGyE,MAAM,CAACC,MAAPD,CAAc,KAAK7B,UAAL,CAAgB5C,aAA9ByE,CAAtB;IACA,MAAM,CAACwC,qBAAD,EAAwBC,eAAxB,IAA2CzI,kBAAkB,CACjEuB,aADiE,EAEjE2G,UAFiE,EAGjE,KAAKjF,OAAL,CAAahC,oBAHoD,CAAnE;IAKAsH,qBAAqB,CAAChH,aAAtBgH,GAAsCC,qBAAtCD;;IACA,KAAK,MAAMG,IAAX,IAAmBD,eAAnB,EAAoC;MAClCC,IAAI,CAACC,QAALD;IACD;;IAEDH,qBAAqB,CAAC5D,eAAtB4D,GAAwCvC,MAAM,CAACC,MAAPD,CAAc,KAAK7B,UAAL,CAAgByE,cAA9B5C,CAAxCuC;IACAA,qBAAqB,CAAC7D,WAAtB6D,GAAoCvC,MAAM,CAACC,MAAPD,CAAc,KAAK7B,UAAL,CAAgB0E,UAA9B7C,CAApCuC;IAEA,KAAKtE,eAAL;;IACA,IAAI,KAAKA,eAAL,GAAuB,CAA3B,EAA8B;MAC5B;IACD;;IAED,KAAK6E,YAAL;EACD;;EAKDA,YAAY,GAAS;IACnB,KAAKvH,aAAL,GAAqB,EAArB;IACA,KAAKoD,eAAL,GAAuB,EAAvB;IACA,KAAKD,WAAL,GAAmB,EAAnB;;IAEA,KAAK,MAAMqE,aAAX,IAA4B,KAAKnE,cAAjC,EAAiD;MAC/C,MAAMoE,mBAAmB,GAAG,KAAKpE,cAAL,CAAoBmE,aAApB,CAA5B;MACA,KAAKxH,aAAL,GAAqB,KAAKA,aAAL,CAAmB0H,MAAnB,CAA0BD,mBAAmB,CAACzH,aAA9C,CAArB;MACA,KAAKoD,eAAL,GAAuB,KAAKA,eAAL,CAAqBsE,MAArB,CAA4BD,mBAAmB,CAACrE,eAAhD,CAAvB;MACA,KAAKD,WAAL,GAAmB,KAAKA,WAAL,CAAiBuE,MAAjB,CAAwBD,mBAAmB,CAACtE,WAA5C,CAAnB;IACD;;IAED,KAAKnD,aAAL,GAAqB,KAAK0B,OAAL,CAAa3B,mBAAb,CAAiC,KAAKC,aAAtC,CAArB;;IAEA,KAAK,MAAMmH,IAAX,IAAmB,KAAKnH,aAAxB,EAAuC;MACrC,KAAKkD,MAAL,CAAYiE,IAAI,CAACxD,EAAjB,IAAuBwD,IAAvB;IACD;;IAED,KAAKQ,UAAL;;IACA,KAAKC,YAAL;;IACA,KAAKC,YAAL;EACD;;EAEDC,aAAa,CAACC,gBAAD,EAAmB/H,aAAnB,EAAkC;IAC7C,IAAI+H,gBAAgB,CAACxD,MAAjBwD,KAA4B/H,aAAa,CAACuE,MAA9C,EAAsD;MACpD,OAAO,IAAP;IACD;;IACD,MAAMyD,IAAI,GAAG,IAAIC,GAAJ,CAAQF,gBAAgB,CAACG,GAAjBH,CAAsBI,CAAD,IAAOA,CAAC,CAACxE,EAA9BoE,CAAR,CAAb;IACA,MAAMK,IAAI,GAAG,IAAIH,GAAJ,CAAQjI,aAAa,CAACkI,GAAdlI,CAAmBmI,CAAD,IAAOA,CAAC,CAACxE,EAA3B3D,CAAR,CAAb;IACA,IAAIqI,OAAO,GAAGN,gBAAgB,CAACO,MAAjBP,CAAyBQ,CAAD,IAAO,CAACH,IAAI,CAACI,GAALJ,CAASG,CAAC,CAAC5E,EAAXyE,CAAhCL,EAAgDxD,MAAhDwD,GAAyD,CAAvE;IACAM,OAAO,GAAGA,OAAO,IAAIrI,aAAa,CAACsI,MAAdtI,CAAsBuI,CAAD,IAAO,CAACP,IAAI,CAACQ,GAALR,CAASO,CAAC,CAAC5E,EAAXqE,CAA7BhI,EAA6CuE,MAA7CvE,GAAsD,CAA3EqI;IACA,OAAOA,OAAP;EACD;;EAEDV,UAAU,GAAG;IAIX,KAAK,MAAMR,IAAX,IAAmB,KAAK/D,eAAxB,EAAyC;MACvC,IAAI+D,IAAI,CAACsB,eAAT,EAA0B;QAExB,KAAKC,SAAL,CAAevB,IAAf;MACD;IACF;EACF;;EAEDS,YAAY,GAAG;IAEb,KAAK9E,MAAL,CAAY6F,WAAZ,CAAwB,IAAxB,EAA8B,CAAC/G,OAAD,EAAUuF,IAAV,KAAmBvF,OAAO,CAACgH,WAARhH,CAAoBuF,IAApBvF,CAAjD;EACD;;EAEDiG,YAAY,GAAG;IACb,IAAIgB,eAAe,GAAG,CAAtB;IACA,IAAIC,gBAAgB,GAAG,CAAvB;;IACA,KAAK,MAAM3B,IAAX,IAAmB,KAAKnH,aAAxB,EAAuC;MACrC,IAAImH,IAAI,CAAC4B,gBAAL5B,IAAyBA,IAAI,CAAC6B,OAAlC,EAA2C;QACzCH,eAAe;;QACf,IAAI1B,IAAI,CAAC6B,OAAL7B,CAAa8B,UAAjB,EAA6B;UAC3BH,gBAAgB,IAAI3B,IAAI,CAAC6B,OAAL7B,CAAa8B,UAAjCH;QADF,OAEO;UAELA,gBAAgB,IAAI3B,IAAI,CAAC6B,OAAL7B,CAAa+B,WAAjCJ;QACD;MACF;IACF;;IAED,KAAKpF,KAAL,CAAWyF,GAAX,CAAepI,aAAf,EAA8BqI,KAA9B,GAAsC,KAAKpJ,aAAL,CAAmBuE,MAAzD;IACA,KAAKb,KAAL,CAAWyF,GAAX,CAAenI,gBAAf,EAAiCoI,KAAjC,GAAyCP,eAAzC;IACA,KAAKnF,KAAL,CAAWyF,GAAX,CAAe9H,YAAf,EAA6B+H,KAA7B,GAAqCN,gBAArC;EACD;;EAEuB,MAAlB3E,kBAAkB,CAACkF,WAAD,EAAc;IACpC,IAAI,KAAKvH,IAAL,KAAc7C,YAAY,CAACqK,GAA/B,EAAoC;MAClC,KAAKC,qBAAL;MACAF,WAAW,CAACjH,IAAZiH,GAAmB,MAAMA,WAAW,CAACjH,IAArCiH;IACD;;IACD,KAAKjH,IAAL,GAAY,KAAKqE,sBAAL,CAA4B4C,WAA5B,EAAyC,IAAzC,CAAZ;;IAEA,IAAI,KAAKvH,IAAL,KAAc7C,YAAY,CAACuK,OAA/B,EAAwC;MACtC,KAAKC,yBAAL,CAA+BJ,WAA/B;;MACA,KAAKK,yBAAL;IACD;;IAED,IAAI,KAAK5H,IAAL,KAAc7C,YAAY,CAACqK,GAA/B,EAAoC;MAClC,KAAKK,qBAAL;IACD;EACF;;EAQOJ,qBAAqB,GAAG;IAAA;;IAE9B,MAAMK,UAAU,GAAG,KAAKhI,OAAL,CAAagI,UAAhC;;IACA,IAAIA,UAAJ,EAAgB;MACd,MAAM;QAACC,IAAD;QAAOC,IAAP;QAAaC,IAAb;QAAmBC,IAAnB;QAAyBC,IAAzB;QAA+BC;MAA/B,IAAuCN,UAA7C;MACA,KAAKtH,kBAAL,GAA0B,IAAItE,OAAJ,CACxB6L,IAAI,GAAG,CAACC,IAAI,GAAGD,IAAR,IAAgB,CADC,EAExBE,IAAI,GAAG,CAACC,IAAI,GAAGD,IAAR,IAAgB,CAFC,EAGxBE,IAAI,GAAG,CAACC,IAAI,GAAGD,IAAR,IAAgB,CAHC,CAA1B;MAKA,KAAK1H,eAAL,GAAuBtE,SAAS,CAACoB,KAAVpB,CAAgBkM,uBAAhBlM,CACrB,KAAKqE,kBADgBrE,EAErB,IAAID,OAAJ,EAFqBC,CAAvB;MAIA,KAAKuE,IAAL,GAAY5D,qBAAqB,CAACgL,UAAD,EAAa,KAAKtH,kBAAlB,EAAsC,KAAKC,eAA3C,CAAjC;MACA;IACD;;IAED,MAAM6H,MAAM,0BAAG,KAAKxI,OAAL,CAAayI,KAAhB,wDAAGC,oBAAoBF,MAAnC;;IACA,IAAIA,MAAJ,EAAY;MACV,MAAM,CAACP,IAAD,EAAOE,IAAP,EAAaD,IAAb,EAAmBE,IAAnB,IAA2BI,MAAjC;MACA,KAAK9H,kBAAL,GAA0B,IAAItE,OAAJ,CAAY6L,IAAI,GAAG,CAACC,IAAI,GAAGD,IAAR,IAAgB,CAAnC,EAAsCE,IAAI,GAAG,CAACC,IAAI,GAAGD,IAAR,IAAgB,CAA7D,EAAgE,CAAhE,CAA1B;MACA,KAAKxH,eAAL,GAAuBtE,SAAS,CAACoB,KAAVpB,CAAgBkM,uBAAhBlM,CACrB,KAAKqE,kBADgBrE,EAErB,IAAID,OAAJ,EAFqBC,CAAvB;MAIA,KAAKuE,IAAL,GAAY7D,iBAAiB,CAACyL,MAAD,EAAS,KAAK9H,kBAAd,EAAkC,KAAKC,eAAvC,CAA7B;MACA;IACD;;IAEDgI,OAAO,CAACC,IAARD,CAAa,6CAAbA;IACA,KAAKjI,kBAAL,GAA0B,IAAItE,OAAJ,EAA1B;IACA,KAAKwE,IAAL,GAAY,CAAZ;IACA;EACD;;EAQOkH,yBAAyB,GAAG;IAClC,MAAMtH,IAAI,GAAG,KAAKA,IAAlB;IACAhE,MAAM,CAACgE,IAAD,CAANhE;IACA,MAAM;MAACqM;IAAD,IAAWrI,IAAI,CAACK,cAAtB;;IAEA,IAAI,CAACgI,MAAL,EAAa;MAEXF,OAAO,CAACC,IAARD,CAAa,iDAAbA;MACA,KAAKjI,kBAAL,GAA0B,IAAItE,OAAJ,EAA1B;MACA,KAAKwE,IAAL,GAAY,CAAZ;MACA;IACD;;IAGD,IAAIiI,MAAM,CAAC,CAAD,CAANA,KAAc,CAAdA,IAAmBA,MAAM,CAAC,CAAD,CAANA,KAAc,CAAjCA,IAAsCA,MAAM,CAAC,CAAD,CAANA,KAAc,CAAxD,EAA2D;MACzD,KAAKnI,kBAAL,GAA0BrE,SAAS,CAACoB,KAAVpB,CAAgByM,uBAAhBzM,CAAwCwM,MAAxCxM,EAAgD,IAAID,OAAJ,EAAhDC,CAA1B;IADF,OAEO;MACL,KAAKqE,kBAAL,GAA0B,IAAItE,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAACC,SAAS,CAACoB,KAAVpB,CAAgB0M,KAAhB1M,CAAsB,CAAtBA,CAAnB,CAA1B;IACD;;IACD,KAAKsE,eAAL,GAAuBkI,MAAvB;IACA,KAAKjI,IAAL,GAAY9D,yBAAyB,CAAC0D,IAAI,CAACK,cAAN,EAAsB,KAAKH,kBAA3B,CAArC;EACD;;EAEDsB,gBAAgB,GAAG;IACjB,KAAKF,KAAL,CAAWyF,GAAX,CAAetI,WAAf;IACA,KAAK6C,KAAL,CAAWyF,GAAX,CAAejI,aAAf;IACA,KAAKwC,KAAL,CAAWyF,GAAX,CAAerI,eAAf;IACA,KAAK4C,KAAL,CAAWyF,GAAX,CAAepI,aAAf;IACA,KAAK2C,KAAL,CAAWyF,GAAX,CAAenI,gBAAf;IACA,KAAK0C,KAAL,CAAWyF,GAAX,CAAelI,YAAf;IACA,KAAKyC,KAAL,CAAWyF,GAAX,CAAehI,cAAf;IACA,KAAKuC,KAAL,CAAWyF,GAAX,CAAe/H,iBAAf;IACA,KAAKsC,KAAL,CAAWyF,GAAX,CAAe9H,YAAf,EAA6B,QAA7B;IACA,KAAKqC,KAAL,CAAWyF,GAAX,CAAe7H,gBAAf,EAAiC,QAAjC;EACD;;EAIDmF,sBAAsB,CAAC4C,WAAD,EAAcuB,gBAAd,EAAgC;IAGpD,MAAMC,QAAQ,GAAG,IAAIhM,MAAJ,CAAW,IAAX,EAAiBwK,WAAW,CAACjH,IAA7B,EAAmCwI,gBAAnC,CAAjB;;IAIA,IAAIA,gBAAJ,EAAsB;MACpBA,gBAAgB,CAACE,QAAjBF,CAA0BpE,IAA1BoE,CAA+BC,QAA/BD;MACAC,QAAQ,CAACE,KAATF,GAAiBD,gBAAgB,CAACG,KAAjBH,GAAyB,CAA1CC;IACD;;IAGD,IAAI,KAAK/I,IAAL,KAAc7C,YAAY,CAACuK,OAA/B,EAAwC;MACtC,MAAMwB,KAAe,GAAG,EAAxB;MACAA,KAAK,CAACxE,IAANwE,CAAWH,QAAXG;;MAEA,OAAOA,KAAK,CAACzG,MAANyG,GAAe,CAAtB,EAAyB;QACvB,MAAM7D,IAAI,GAAG6D,KAAK,CAACC,GAAND,EAAb;QACA,KAAKtH,KAAL,CAAWyF,GAAX,CAAetI,WAAf,EAA4BqK,cAA5B;QACA,MAAMJ,QAAQ,GAAG3D,IAAI,CAACgE,MAALhE,CAAY2D,QAAZ3D,IAAwB,EAAzC;;QACA,KAAK,MAAMiE,WAAX,IAA0BN,QAA1B,EAAoC;UAClC,MAAMO,SAAS,GAAG,IAAIxM,MAAJ,CAAW,IAAX,EAAiBuM,WAAjB,EAA8BjE,IAA9B,CAAlB;UACAA,IAAI,CAAC2D,QAAL3D,CAAcX,IAAdW,CAAmBkE,SAAnBlE;UACAkE,SAAS,CAACN,KAAVM,GAAkBlE,IAAI,CAAC4D,KAAL5D,GAAa,CAA/BkE;UACAL,KAAK,CAACxE,IAANwE,CAAWK,SAAXL;QACD;MACF;IACF;;IAED,OAAOH,QAAP;EACD;;EAEDhI,oBAAoB,GAAG;IACrB,IAAIyI,cAAJ;IACA,MAAMxJ,IAAI,GAAG,KAAKA,IAAlB;;IACA,QAAQA,IAAR;MACE,KAAK7C,YAAY,CAACuK,OAAlB;QACE8B,cAAc,GAAGxM,kBAAjBwM;QACA;;MACF,KAAKrM,YAAY,CAACqK,GAAlB;QACEgC,cAAc,GAAGtM,cAAjBsM;QACA;;MACF;QACEA,cAAc,GAAGvM,gBAAjBuM;IARJ;;IAWA,OAAO,IAAIA,cAAJ,CAAmB;MACxB3K,QAAQ,EAAE,KAAKA,QADS;MAExB4K,cAAc,EAAE,KAAKxE,eAAL,CAAqByE,IAArB,CAA0B,IAA1B;IAFQ,CAAnB,CAAP;EAID;;EAEDC,mBAAmB,CAACC,UAAD,EAAa;IAC9B,KAAKC,eAAL,CAAqBD,UAArB;EACD;;EAEc,MAAThD,SAAS,CAACvB,IAAD,EAAO;IACpB,IAAIyE,MAAJ;;IACA,IAAI;MACF,KAAKC,mBAAL;;MACAD,MAAM,GAAG,MAAMzE,IAAI,CAAC2E,WAAL3E,EAAfyE;IAFF,EAGE,OAAOG,KAAP,EAAc;MACd,KAAKC,gBAAL,CAAsB7E,IAAtB,EAA4B4E,KAA5B;IAJF,UAKU;MACR,KAAKE,iBAAL;;MACA,KAAKC,WAAL,CAAiB/E,IAAjB,EAAuByE,MAAvB;IACD;EACF;;EAEDI,gBAAgB,CAAC7E,IAAD,EAAO4E,KAAP,EAAc;IAC5B,KAAKrI,KAAL,CAAWyF,GAAX,CAAe/H,iBAAf,EAAkC8J,cAAlC;IAEA,MAAMiB,OAAO,GAAGJ,KAAK,CAACI,OAANJ,IAAiBA,KAAK,CAACK,QAANL,EAAjC;IACA,MAAMhK,GAAG,GAAGoF,IAAI,CAACpF,GAAjB;IAEAwI,OAAO,CAACwB,KAARxB,qCAA2CpD,IAAI,CAACpF,GAAhD,cAAuDoK,OAAvD;IACA,KAAKzK,OAAL,CAAa5B,WAAb,CAAyBqH,IAAzB,EAA+BgF,OAA/B,EAAwCpK,GAAxC;EACD;;EAEDmK,WAAW,CAAC/E,IAAD,EAAOyE,MAAP,EAAe;IACxB,IAAI,CAACA,MAAL,EAAa;MACX;IACD;;IAED,IAAI,KAAK9J,IAAL,KAAc7C,YAAY,CAACqK,GAA/B,EAAoC;MAAA;;MAElC,MAAM+C,gBAAgB,GAAG,uBAAKzK,OAAL,yFAAc0K,aAAd,gFAA6BD,gBAA7B,KAAiD,CAA1E;MACA,KAAK3I,KAAL,CAAWyF,GAAX,CAAetI,WAAf,EAA4BuF,KAA5B;MACA,KAAK1C,KAAL,CAAWyF,GAAX,CAAetI,WAAf,EAA4B0L,QAA5B,CAAqCF,gBAArC;IACD;;IAGD,IAAIlF,IAAI,IAAIA,IAAI,CAAC6B,OAAjB,EAA0B;MACxBzK,uBAAuB,CAAC4I,IAAD,EAAOA,IAAI,CAAC6B,OAAZ,CAAvBzK;IACD;;IAED,KAAKiO,eAAL,CAAqBrF,IAArB;;IACA,KAAKzF,OAAL,CAAa9B,UAAb,CAAwBuH,IAAxB;EACD;;EAED0E,mBAAmB,GAAG;IACpB,KAAK5I,aAAL;IACA,KAAKS,KAAL,CAAWyF,GAAX,CAAejI,aAAf,EAA8BgK,cAA9B;EACD;;EAEDe,iBAAiB,GAAG;IAClB,KAAKhJ,aAAL;IACA,KAAKS,KAAL,CAAWyF,GAAX,CAAejI,aAAf,EAA8BuL,cAA9B;EACD;;EAEDD,eAAe,CAACrF,IAAD,EAAO;IACpB,KAAKrE,MAAL,CAAY4J,GAAZ,CAAgB,IAAhB,EAAsBvF,IAAtB,EAA6BvF,OAAD,IAAaA,OAAO,CAAC+K,iBAAR/K,CAA0BuF,IAA1BvF,CAAzC;EACD;;EAED+K,iBAAiB,CAACxF,IAAD,EAAO;IACtB,KAAKzD,KAAL,CAAWyF,GAAX,CAAelI,YAAf,EAA6BiK,cAA7B;IACA,KAAKxH,KAAL,CAAWyF,GAAX,CAAerI,eAAf,EAAgCoK,cAAhC;IAGA,KAAKzH,qBAAL,IAA8B0D,IAAI,CAAC6B,OAAL7B,CAAayF,UAAbzF,IAA2B,CAAzD;IACA,KAAKzD,KAAL,CAAWyF,GAAX,CAAe7H,gBAAf,EAAiC8H,KAAjC,GAAyC,KAAK3F,qBAA9C;EACD;;EAEDmF,WAAW,CAACzB,IAAD,EAAO;IAChB,KAAK1D,qBAAL,IAA+B0D,IAAI,CAAC6B,OAAL7B,IAAgBA,IAAI,CAAC6B,OAAL7B,CAAayF,UAA7BzF,IAA4C,CAA3E;IAEA,KAAKzD,KAAL,CAAWyF,GAAX,CAAerI,eAAf,EAAgC2L,cAAhC;IACA,KAAK/I,KAAL,CAAWyF,GAAX,CAAehI,cAAf,EAA+B+J,cAA/B;IACA,KAAKxH,KAAL,CAAWyF,GAAX,CAAe7H,gBAAf,EAAiC8H,KAAjC,GAAyC,KAAK3F,qBAA9C;IAEA,KAAK/B,OAAL,CAAa7B,YAAb,CAA0BsH,IAA1B;IACAA,IAAI,CAAC0F,aAAL1F;EACD;;EAGD9C,QAAQ,GAAG;IACT,MAAM2G,KAAe,GAAG,EAAxB;;IAEA,IAAI,KAAK5I,IAAT,EAAe;MACb4I,KAAK,CAACxE,IAANwE,CAAW,KAAK5I,IAAhB4I;IACD;;IAED,OAAOA,KAAK,CAACzG,MAANyG,GAAe,CAAtB,EAAyB;MACvB,MAAM7D,IAAY,GAAG6D,KAAK,CAACC,GAAND,EAArB;;MAEA,KAAK,MAAM8B,KAAX,IAAoB3F,IAAI,CAAC2D,QAAzB,EAAmC;QACjCE,KAAK,CAACxE,IAANwE,CAAW8B,KAAX9B;MACD;;MAED,KAAK+B,YAAL,CAAkB5F,IAAlB;IACD;;IACD,KAAK/E,IAAL,GAAY,IAAZ;EACD;;EAGDuJ,eAAe,CAACxE,IAAD,EAAO;IACpB,MAAM/E,IAAI,GAAG+E,IAAb;IACA,MAAM6D,KAAe,GAAG,EAAxB;IACAA,KAAK,CAACxE,IAANwE,CAAW5I,IAAX4I;;IACA,OAAOA,KAAK,CAACzG,MAANyG,GAAe,CAAtB,EAAyB;MACvB7D,IAAI,GAAG6D,KAAK,CAACC,GAAND,EAAP7D;;MACA,KAAK,MAAM2F,KAAX,IAAoB3F,IAAI,CAAC2D,QAAzB,EAAmC;QACjCE,KAAK,CAACxE,IAANwE,CAAW8B,KAAX9B;MACD;;MACD,IAAI7D,IAAI,KAAK/E,IAAb,EAAmB;QACjB,KAAK2K,YAAL,CAAkB5F,IAAlB;MACD;IACF;;IACD/E,IAAI,CAAC0I,QAAL1I,GAAgB,EAAhBA;EACD;;EAED2K,YAAY,CAAC5F,IAAD,EAAO;IACjB,KAAKrE,MAAL,CAAYkK,UAAZ,CAAuB,IAAvB,EAA6B7F,IAA7B;;IACA,KAAKyB,WAAL,CAAiBzB,IAAjB;;IACAA,IAAI,CAAC/C,OAAL+C;EACD;;EAEDsC,yBAAyB,CAACJ,WAAD,EAAc;IACrC,KAAKrF,KAAL,GAAaqF,WAAW,CAACrF,KAAzB;;IACA,IAAI,CAAC,KAAKA,KAAV,EAAiB;MACf,MAAM,IAAIiJ,KAAJ,CAAU,sCAAV,CAAN;IACD;;IACD,IAAI,KAAKjJ,KAAL,CAAWkJ,OAAX,KAAuB,KAAvB,IAAgC,KAAKlJ,KAAL,CAAWkJ,OAAX,KAAuB,KAA3D,EAAkE;MAChE,MAAM,IAAID,KAAJ,CAAU,kDAAV,CAAN;IACD;;IAID,IAAI,oBAAoB,KAAKjJ,KAA7B,EAAoC;MAClC,KAAKT,YAAL,CAAkB4J,CAAlB,GAAsB,KAAKnJ,KAAL,CAAWoJ,cAAjC;IACD;;IAGD,KAAKnJ,OAAL,GAAe;MACbvD,YAAY,EAAE,KAAKgB,OAAL,CAAahB,YAAb,IAA6B;IAD9B,CAAf;IAGA,KAAKvB,WAAL,GAAmB,KAAKuC,OAAL,CAAavC,WAAb,IAA4B,EAA/C;IAGA,KAAKkO,UAAL,GAAkBhE,WAAW,CAACgE,UAA9B;IACA,KAAK1K,cAAL,GAAsB0G,WAAW,CAAC1G,cAAlC;IACA,KAAKkB,eAAL,GAAuBwF,WAAW,CAACiE,cAAnC;IAEA,KAAKvJ,MAAL,GAAcsF,WAAW,CAACtF,MAA1B;EACD;;EAED4F,qBAAqB,GAAG;IACtB,IAAI,KAAKnJ,WAAL,CAAiBI,GAAjB,IAAwB,WAAW,KAAKJ,WAAL,CAAiBI,GAAxD,EAA6D;MAC3D,KAAK2C,YAAL,CAAkBgK,KAAlB,GAA0B,KAAK/M,WAAL,CAAiBI,GAAjB,CAAqB2M,KAA/C;IACD;EACF;;AAxtB4B;;AA2tB/B,SAAS1I,mBAAT,CAA6BD,WAA7B,EAAkD;EAChD,MAAM4I,iBAA2B,GAAG,EAApC;;EACA,KAAK,MAAMC,GAAX,IAAkBhJ,MAAM,CAACiJ,IAAPjJ,CAAYG,WAAZH,CAAlB,EAA4C;IAC1C+I,iBAAiB,CAAChH,IAAlBgH,WAA0BC,GAA1B,cAAiC7I,WAAW,CAAC6I,GAAD,CAA5C;EACD;;EACD,QAAQD,iBAAiB,CAACjJ,MAA1B;IACE,KAAK,CAAL;MACE,OAAO,EAAP;;IACF,KAAK,CAAL;MACE,kBAAWiJ,iBAAiB,CAAC,CAAD,CAA5B;;IACF;MACE,kBAAWA,iBAAiB,CAACG,IAAlBH,CAAuB,GAAvBA,CAAX;EANJ;AAQD","names":["Matrix4","Vector3","Ellipsoid","Stats","RequestScheduler","assert","path","TilesetCache","calculateTransformProps","getFrameState","limitSelectedTiles","getZoomFromBoundingVolume","getZoomFromExtent","getZoomFromFullExtent","Tile3D","Tileset3DTraverser","TilesetTraverser","I3SetTraverser","TILESET_TYPE","DEFAULT_PROPS","description","ellipsoid","WGS84","modelMatrix","throttleRequests","maxRequests","maximumMemoryUsage","maximumTilesSelected","debounceTime","onTileLoad","onTileUnload","onTileError","onTraversalComplete","selectedTiles","contentLoader","undefined","viewDistanceScale","maximumScreenSpaceError","loadTiles","updateTransforms","viewportTraversersMap","loadOptions","fetch","attributions","basePath","i3s","TILES_TOTAL","TILES_IN_MEMORY","TILES_IN_VIEW","TILES_RENDERABLE","TILES_LOADED","TILES_LOADING","TILES_UNLOADED","TILES_LOAD_FAILED","POINTS_COUNT","TILES_GPU_MEMORY","Tileset3D","constructor","json","options","_defineProperty","tileset","loader","type","url","dirname","lodMetricType","lodMetricValue","refine","root","roots","cartographicCenter","cartesianCenter","zoom","boundingVolume","traverseCounter","geometricError","_traverser","_initializeTraverser","_cache","_requestScheduler","_frameNumber","_pendingCount","_tiles","_emptyTiles","_requestedTiles","frameStateData","lastUpdatedVieports","_queryParams","_queryParamsString","gpuMemoryUsageInBytes","stats","id","_initializeStats","_extensionsUsed","dynamicScreenSpaceErrorComputedDensity","extras","asset","credits","tilesetInitializationPromise","_initializeTileSet","destroy","_destroy","isLoaded","length","tiles","Object","values","frameNumber","queryParams","getQueryParamString","setProps","props","setOptions","getTileUrl","tilePath","isDataUrl","startsWith","hasExtension","extensionName","Boolean","indexOf","update","viewports","then","doUpdate","selectTiles","updatePromise","Promise","resolve","setTimeout","preparedViewports","Array","reset","viewportsToTraverse","viewport","_needTraverse","push","_initializeTileHeaders","includes","frameState","traverse","viewportId","traverserId","_onTraversalEnd","currentFrameStateData","filteredSelectedTiles","unselectedTiles","tile","unselect","requestedTiles","emptyTiles","_updateTiles","frameStateKey","frameStateDataValue","concat","_loadTiles","_unloadTiles","_updateStats","_tilesChanged","oldSelectedTiles","set1","Set","map","t","set2","changed","filter","x","has","contentUnloaded","_loadTile","unloadTiles","_unloadTile","tilesRenderable","pointsRenderable","contentAvailable","content","pointCount","vertexCount","get","count","tilesetJson","I3S","calculateViewPropsI3S","TILES3D","_initializeTiles3DTileset","calculateViewPropsTiles3D","_initializeI3STileset","fullExtent","xmin","xmax","ymin","ymax","zmin","zmax","cartographicToCartesian","extent","store","_this$tileset$store","console","warn","center","cartesianToCartographic","radii","parentTileHeader","rootTile","children","depth","stack","pop","incrementCount","header","childHeader","childTile","TraverserClass","onTraversalEnd","bind","_destroyTileHeaders","parentTile","_destroySubtree","loaded","_onStartTileLoading","loadContent","error","_onTileLoadError","_onEndTileLoading","_onTileLoad","message","toString","nodesInNodePages","nodePagesTile","addCount","_addTileToCache","decrementCount","add","_updateCacheStats","byteLength","unloadContent","child","_destroyTile","unloadTile","Error","version","v","tilesetVersion","properties","extensionsUsed","token","queryParamStrings","key","keys","join"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@loaders.gl\\tiles\\src\\tileset\\tileset-3d.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/*\n\n  The Tileset loading and rendering flow is as below,\n  A rendered (i.e. deck.gl `Tile3DLayer`) triggers `tileset.update()` after a `tileset` is loaded\n  `tileset` starts traversing the tile tree and update `requestTiles` (tiles of which content need\n  to be fetched) and `selectedTiles` (tiles ready for rendering under the current viewport).\n  `Tile3DLayer` will update rendering based on `selectedTiles`.\n  `Tile3DLayer` also listens to `onTileLoad` callback and trigger another round of `update and then traversal`\n  when new tiles are loaded.\n\n  As I3S tileset have stored `tileHeader` file (metadata) and tile content files (geometry, texture, ...) separately.\n  During each traversal, it issues `tilHeader` requests if that `tileHeader` is not yet fetched,\n  after the tile header is fulfilled, it will resume the traversal starting from the tile just fetched (not root).\n\n  Tile3DLayer\n       |\n   await load(tileset)\n       |\n   tileset.update()\n       |                async load tileHeader\n   tileset.traverse() -------------------------- Queued\n       |        resume traversal after fetched  |\n       |----------------------------------------|\n       |\n       |                     async load tile content\n  tilset.requestedTiles  ----------------------------- RequestScheduler\n                                                              |\n  tilset.selectedTiles (ready for rendering)                  |\n       |         Listen to                                    |\n    Tile3DLayer ----------- onTileLoad  ----------------------|\n       |                         |   notify new tile is available\n    updateLayers                 |\n                        tileset.update // trigger another round of update\n*/\n\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {Stats} from '@probe.gl/stats';\nimport {\n  RequestScheduler,\n  assert,\n  path,\n  LoaderWithParser,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport TilesetCache from './tileset-cache';\nimport {calculateTransformProps} from './helpers/transform-utils';\nimport {FrameState, getFrameState, limitSelectedTiles} from './helpers/frame-state';\nimport {getZoomFromBoundingVolume, getZoomFromExtent, getZoomFromFullExtent} from './helpers/zoom';\nimport Tile3D from './tile-3d';\nimport Tileset3DTraverser from './traversers/tileset-3d-traverser';\nimport TilesetTraverser from './traversers/tileset-traverser';\nimport I3SetTraverser from './traversers/i3s-tileset-traverser';\nimport {TILESET_TYPE} from '../constants';\nimport {Viewport} from '../types';\n\nexport type Tileset3DProps = {\n  // loading\n  throttleRequests?: boolean;\n  maxRequests?: number;\n  loadOptions?: LoaderOptions;\n  loadTiles?: boolean;\n  basePath?: string;\n  maximumMemoryUsage?: number;\n  maximumTilesSelected?: number;\n  debounceTime?: number;\n\n  // Metadata\n  description?: string;\n  attributions?: string[];\n\n  // Transforms\n  ellipsoid?: object;\n  modelMatrix?: Matrix4;\n\n  // Traversal\n  maximumScreenSpaceError?: number;\n  viewportTraversersMap?: any;\n  updateTransforms?: boolean;\n  viewDistanceScale?: number;\n\n  // Callbacks\n  onTileLoad?: (tile: Tile3D) => any;\n  onTileUnload?: (tile: Tile3D) => any;\n  onTileError?: (tile: Tile3D, message: string, url: string) => any;\n  contentLoader?: (tile: Tile3D) => Promise<void>;\n  onTraversalComplete?: (selectedTiles: Tile3D[]) => Tile3D[];\n};\n\ntype Props = {\n  description: string;\n  ellipsoid: object;\n  modelMatrix: Matrix4;\n  throttleRequests: boolean;\n  maximumMemoryUsage: number;\n  maximumTilesSelected: number;\n  debounceTime: number;\n  onTileLoad: (tile: Tile3D) => any;\n  onTileUnload: (tile: Tile3D) => any;\n  onTileError: (tile: Tile3D, message: string, url: string) => any;\n  onTraversalComplete: (selectedTiles: Tile3D[]) => Tile3D[];\n  maximumScreenSpaceError: number;\n  viewportTraversersMap: any;\n  attributions: string[];\n  maxRequests: number;\n  loadTiles: boolean;\n  loadOptions: LoaderOptions;\n  updateTransforms: boolean;\n  viewDistanceScale: number;\n  basePath: string;\n  contentLoader?: (tile: Tile3D) => Promise<void>;\n  i3s: {[key: string]: any};\n};\n\nconst DEFAULT_PROPS: Props = {\n  description: '',\n\n  ellipsoid: Ellipsoid.WGS84,\n  // A 4x4 transformation matrix this transforms the entire tileset.\n  modelMatrix: new Matrix4(),\n\n  // Set to false to disable network request throttling\n  throttleRequests: true,\n\n  // Number of simultaneous requsts, if throttleRequests is true\n  maxRequests: 64,\n\n  maximumMemoryUsage: 32,\n  /** Maximum number limit of tiles selected for show. 0 means no limit */\n  maximumTilesSelected: 0,\n  /** Delay time before the tileset traversal. It prevents traversal requests spam.*/\n  debounceTime: 0,\n\n  /**\n   * Callback. Indicates this a tile's content was loaded\n   * @param tile {TileHeader}\n   */\n  onTileLoad: () => {},\n  /**\n   * Callback. Indicates this a tile's content was unloaded\n   * @param tile {TileHeader}\n   */\n  onTileUnload: () => {},\n  onTileError: () => {},\n  /**\n   * Callback. Allows post-process selectedTiles right after traversal.\n   * @param selectedTiles {TileHeader[]}\n   * @returns TileHeader[] - output array of tiles to return to deck.gl\n   */\n  onTraversalComplete: (selectedTiles: Tile3D[]) => selectedTiles,\n\n  // Optional async tile content loader\n  contentLoader: undefined,\n\n  // View distance scale modifier\n  viewDistanceScale: 1.0,\n\n  // The maximum screen space error used to drive level of detail refinement.\n  maximumScreenSpaceError: 8,\n\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n\n  loadOptions: {fetch: {}},\n\n  attributions: [],\n  basePath: '',\n\n  i3s: {}\n};\n\n// Tracked Stats\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points/Vertices';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\n\nexport default class Tileset3D {\n  // props: Tileset3DProps;\n  options: Props;\n  loadOptions: {[key: string]: any};\n\n  type: string;\n  tileset: {[key: string]: any};\n  loader: LoaderWithParser;\n  url: string;\n  basePath: string;\n  modelMatrix: Matrix4;\n  ellipsoid: any;\n  lodMetricType: string;\n  lodMetricValue: number;\n  refine: string;\n  root: Tile3D | null;\n  roots: {[key: string]: Tile3D};\n  asset: {[key: string]: any};\n\n  description: string;\n  properties: any;\n  extras: any;\n  attributions: any;\n  credits: any;\n\n  stats: Stats;\n\n  traverseCounter: number;\n  geometricError: number;\n  selectedTiles: Tile3D[];\n  private updatePromise: Promise<number> | null = null;\n  tilesetInitializationPromise: Promise<void>;\n\n  cartographicCenter: Vector3 | null;\n  cartesianCenter: Vector3 | null;\n  zoom: number;\n  boundingVolume: any;\n\n  // METRICS\n  // The maximum amount of GPU memory (in MB) that may be used to cache tiles.\n  // Tiles not in view are unloaded to enforce private\n  // The total amount of GPU memory in bytes used by the tileset.\n  gpuMemoryUsageInBytes: any;\n  dynamicScreenSpaceErrorComputedDensity: any;\n\n  // TRAVERSAL\n  _traverser: TilesetTraverser;\n  private _cache: TilesetCache;\n  _requestScheduler: RequestScheduler;\n\n  _frameNumber: number;\n  private _queryParamsString: string;\n  private _queryParams: any;\n  private _extensionsUsed: any;\n  private _tiles: {[id: string]: Tile3D};\n\n  // counter for tracking tiles requests\n  private _pendingCount: any;\n\n  // HOLD TRAVERSAL RESULTS\n  private lastUpdatedVieports: Viewport[] | Viewport | null;\n  private _requestedTiles: any;\n  private _emptyTiles: any;\n  private frameStateData: any;\n\n  maximumMemoryUsage: number;\n\n  /**\n   * Create a new Tileset3D\n   * @param json\n   * @param props\n   */\n  // eslint-disable-next-line max-statements\n  constructor(json: any, options?: Tileset3DProps) {\n    assert(json);\n\n    // PUBLIC MEMBERS\n    this.options = {...DEFAULT_PROPS, ...options};\n    // raw data\n    this.tileset = json;\n    this.loader = json.loader;\n    // could be  3d tiles, i3s\n    this.type = json.type;\n    // The url to a tileset JSON file.\n    this.url = json.url;\n    this.basePath = json.basePath || path.dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n\n    // Geometric error when the tree is not rendered at all\n    this.lodMetricType = json.lodMetricType;\n    this.lodMetricValue = json.lodMetricValue;\n    this.refine = json.root.refine;\n\n    this.loadOptions = this.options.loadOptions || {};\n\n    this.root = null;\n    this.roots = {};\n    // view props\n    this.cartographicCenter = null;\n    this.cartesianCenter = null;\n    this.zoom = 1;\n    this.boundingVolume = null;\n\n    // TRAVERSAL\n    this.traverseCounter = 0;\n    this.geometricError = 0;\n    this._traverser = this._initializeTraverser();\n    this._cache = new TilesetCache();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    // update tracker\n    // increase in each update cycle\n    this._frameNumber = 0;\n\n    // counter for tracking tiles requests\n    this._pendingCount = 0;\n\n    // HOLD TRAVERSAL RESULTS\n    this._tiles = {};\n    this.selectedTiles = [];\n    this._emptyTiles = [];\n    this._requestedTiles = [];\n    this.frameStateData = {};\n    this.lastUpdatedVieports = null;\n\n    this._queryParams = {};\n    this._queryParamsString = '';\n\n    // METRICS\n    // The maximum amount of GPU memory (in MB) that may be used to cache tiles.\n    // Tiles not in view are unloaded to enforce this.\n    this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;\n    // The total amount of GPU memory in bytes used by the tileset.\n    this.gpuMemoryUsageInBytes = 0;\n    this.stats = new Stats({id: this.url});\n    this._initializeStats();\n\n    // EXTRACTED FROM TILESET\n    this._extensionsUsed = undefined;\n    this.dynamicScreenSpaceErrorComputedDensity = 0.0; // Updated based on the camera position and direction\n    // Metadata for the entire tileset\n    this.extras = null;\n    this.asset = {};\n    this.credits = {};\n    this.description = this.options.description || '';\n\n    this.tilesetInitializationPromise = this._initializeTileSet(json);\n  }\n\n  /** Release resources */\n  destroy(): void {\n    this._destroy();\n  }\n\n  /** Is the tileset loaded (update needs to have been called at least once) */\n  isLoaded(): boolean {\n    // Check that `_frameNumber !== 0` which means that update was called at least once\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n\n  get tiles(): object[] {\n    return Object.values(this._tiles);\n  }\n\n  get frameNumber(): number {\n    return this._frameNumber;\n  }\n\n  get queryParams(): string {\n    if (!this._queryParamsString) {\n      this._queryParamsString = getQueryParamString(this._queryParams);\n    }\n    return this._queryParamsString;\n  }\n\n  setProps(props: Tileset3DProps): void {\n    this.options = {...this.options, ...props};\n  }\n\n  /** @deprecated */\n  setOptions(options: Tileset3DProps): void {\n    this.options = {...this.options, ...options};\n  }\n\n  /**\n   * Return a loadable tile url for a specific tile subpath\n   * @param tilePath a tile subpath\n   */\n  getTileUrl(tilePath: string): string {\n    const isDataUrl = tilePath.startsWith('data:');\n    if (isDataUrl) {\n      return tilePath;\n    }\n    return `${tilePath}${this.queryParams}`;\n  }\n\n  // TODO CESIUM specific\n  hasExtension(extensionName: string): boolean {\n    return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);\n  }\n\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports - list of viewports\n   * @deprecated\n   */\n  update(viewports: Viewport[] | Viewport | null = null) {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.tilesetInitializationPromise.then(() => {\n      if (!viewports && this.lastUpdatedVieports) {\n        viewports = this.lastUpdatedVieports;\n      } else {\n        this.lastUpdatedVieports = viewports;\n      }\n      if (viewports) {\n        this.doUpdate(viewports);\n      }\n    });\n  }\n\n  /**\n   * Update visible tiles relying on a list of viewports.\n   * Do it with debounce delay to prevent update spam\n   * @param viewports viewports\n   * @returns Promise of new frameNumber\n   */\n  async selectTiles(viewports: Viewport[] | Viewport | null = null): Promise<number> {\n    await this.tilesetInitializationPromise;\n    if (viewports) {\n      this.lastUpdatedVieports = viewports;\n    }\n    if (!this.updatePromise) {\n      this.updatePromise = new Promise<number>((resolve) => {\n        setTimeout(() => {\n          if (this.lastUpdatedVieports) {\n            this.doUpdate(this.lastUpdatedVieports);\n          }\n          resolve(this._frameNumber);\n          this.updatePromise = null;\n        }, this.options.debounceTime);\n      });\n    }\n    return this.updatePromise;\n  }\n\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports viewports\n   */\n  // eslint-disable-next-line max-statements, complexity\n  private doUpdate(viewports: Viewport[] | Viewport): void {\n    if ('loadTiles' in this.options && !this.options.loadTiles) {\n      return;\n    }\n    if (this.traverseCounter > 0) {\n      return;\n    }\n    const preparedViewports = viewports instanceof Array ? viewports : [viewports];\n\n    this._cache.reset();\n    this._frameNumber++;\n    this.traverseCounter = preparedViewports.length;\n    const viewportsToTraverse: string[] = [];\n    // First loop to decrement traverseCounter\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (this._needTraverse(id)) {\n        viewportsToTraverse.push(id);\n      } else {\n        this.traverseCounter--;\n      }\n    }\n\n    // Second loop to traverse\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (!this.roots[id]) {\n        this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n      }\n\n      if (!viewportsToTraverse.includes(id)) {\n        continue; // eslint-disable-line no-continue\n      }\n      const frameState = getFrameState(viewport, this._frameNumber);\n      this._traverser.traverse(this.roots[id], frameState, this.options);\n    }\n  }\n\n  /**\n   * Check if traversal is needed for particular viewport\n   * @param {string} viewportId - id of a viewport\n   * @return {boolean}\n   */\n  _needTraverse(viewportId: string): boolean {\n    let traverserId = viewportId;\n    if (this.options.viewportTraversersMap) {\n      traverserId = this.options.viewportTraversersMap[viewportId];\n    }\n    if (traverserId !== viewportId) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * The callback to post-process tiles after traversal procedure\n   * @param frameState - frame state for tile culling\n   */\n  _onTraversalEnd(frameState: FrameState): void {\n    const id = frameState.viewport.id;\n    if (!this.frameStateData[id]) {\n      this.frameStateData[id] = {selectedTiles: [], _requestedTiles: [], _emptyTiles: []};\n    }\n    const currentFrameStateData = this.frameStateData[id];\n    const selectedTiles = Object.values(this._traverser.selectedTiles);\n    const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(\n      selectedTiles,\n      frameState,\n      this.options.maximumTilesSelected\n    );\n    currentFrameStateData.selectedTiles = filteredSelectedTiles;\n    for (const tile of unselectedTiles) {\n      tile.unselect();\n    }\n\n    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n\n    this.traverseCounter--;\n    if (this.traverseCounter > 0) {\n      return;\n    }\n\n    this._updateTiles();\n  }\n\n  /**\n   * Update tiles relying on data from all traversers\n   */\n  _updateTiles(): void {\n    this.selectedTiles = [];\n    this._requestedTiles = [];\n    this._emptyTiles = [];\n\n    for (const frameStateKey in this.frameStateData) {\n      const frameStateDataValue = this.frameStateData[frameStateKey];\n      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n    }\n\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n    for (const tile of this.selectedTiles) {\n      this._tiles[tile.id] = tile;\n    }\n\n    this._loadTiles();\n    this._unloadTiles();\n    this._updateStats();\n  }\n\n  _tilesChanged(oldSelectedTiles, selectedTiles) {\n    if (oldSelectedTiles.length !== selectedTiles.length) {\n      return true;\n    }\n    const set1 = new Set(oldSelectedTiles.map((t) => t.id));\n    const set2 = new Set(selectedTiles.map((t) => t.id));\n    let changed = oldSelectedTiles.filter((x) => !set2.has(x.id)).length > 0;\n    changed = changed || selectedTiles.filter((x) => !set1.has(x.id)).length > 0;\n    return changed;\n  }\n\n  _loadTiles() {\n    // Sort requests by priority before making any requests.\n    // This makes it less likely this requests will be cancelled after being issued.\n    // requestedTiles.sort((a, b) => a._priority - b._priority);\n    for (const tile of this._requestedTiles) {\n      if (tile.contentUnloaded) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._loadTile(tile);\n      }\n    }\n  }\n\n  _unloadTiles() {\n    // unload tiles from cache when hit maximumMemoryUsage\n    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n  }\n\n  _updateStats() {\n    let tilesRenderable = 0;\n    let pointsRenderable = 0;\n    for (const tile of this.selectedTiles) {\n      if (tile.contentAvailable && tile.content) {\n        tilesRenderable++;\n        if (tile.content.pointCount) {\n          pointsRenderable += tile.content.pointCount;\n        } else {\n          // Calculate vertices for non point cloud tiles.\n          pointsRenderable += tile.content.vertexCount;\n        }\n      }\n    }\n\n    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n    this.stats.get(POINTS_COUNT).count = pointsRenderable;\n  }\n\n  async _initializeTileSet(tilesetJson) {\n    if (this.type === TILESET_TYPE.I3S) {\n      this.calculateViewPropsI3S();\n      tilesetJson.root = await tilesetJson.root;\n    }\n    this.root = this._initializeTileHeaders(tilesetJson, null);\n\n    if (this.type === TILESET_TYPE.TILES3D) {\n      this._initializeTiles3DTileset(tilesetJson);\n      this.calculateViewPropsTiles3D();\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      this._initializeI3STileset();\n    }\n  }\n\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset\n   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n   * @returns\n   */\n  private calculateViewPropsI3S() {\n    // for I3S 1.8 try to calculate with fullExtent\n    const fullExtent = this.tileset.fullExtent;\n    if (fullExtent) {\n      const {xmin, xmax, ymin, ymax, zmin, zmax} = fullExtent;\n      this.cartographicCenter = new Vector3(\n        xmin + (xmax - xmin) / 2,\n        ymin + (ymax - ymin) / 2,\n        zmin + (zmax - zmin) / 2\n      );\n      this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(\n        this.cartographicCenter,\n        new Vector3()\n      );\n      this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // for I3S 1.6-1.7 try to calculate with extent\n    const extent = this.tileset.store?.extent;\n    if (extent) {\n      const [xmin, ymin, xmax, ymax] = extent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);\n      this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(\n        this.cartographicCenter,\n        new Vector3()\n      );\n      this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console.warn('Extent is not defined in the tileset header');\n    this.cartographicCenter = new Vector3();\n    this.zoom = 1;\n    return;\n  }\n\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset.\n   * For 3DTiles the root tile data is used to calculate view props.\n   * @returns\n   */\n  private calculateViewPropsTiles3D() {\n    const root = this.root as Tile3D;\n    assert(root);\n    const {center} = root.boundingVolume;\n    // TODO - handle all cases\n    if (!center) {\n      // eslint-disable-next-line no-console\n      console.warn('center was not pre-calculated for the root tile');\n      this.cartographicCenter = new Vector3();\n      this.zoom = 1;\n      return;\n    }\n\n    // cartographic coordinates are undefined at the center of the ellipsoid\n    if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {\n      this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());\n    } else {\n      this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);\n    }\n    this.cartesianCenter = center;\n    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n  }\n\n  _initializeStats() {\n    this.stats.get(TILES_TOTAL);\n    this.stats.get(TILES_LOADING);\n    this.stats.get(TILES_IN_MEMORY);\n    this.stats.get(TILES_IN_VIEW);\n    this.stats.get(TILES_RENDERABLE);\n    this.stats.get(TILES_LOADED);\n    this.stats.get(TILES_UNLOADED);\n    this.stats.get(TILES_LOAD_FAILED);\n    this.stats.get(POINTS_COUNT, 'memory');\n    this.stats.get(TILES_GPU_MEMORY, 'memory');\n  }\n\n  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n  // eslint-disable-next-line max-statements\n  _initializeTileHeaders(tilesetJson, parentTileHeader) {\n    // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.\n    // Get the basePath relative to the external tileset.\n    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader); // resource\n\n    // If there is a parentTileHeader, add the root of the currently loading tileset\n    // to parentTileHeader's children, and update its depth.\n    if (parentTileHeader) {\n      parentTileHeader.children.push(rootTile);\n      rootTile.depth = parentTileHeader.depth + 1;\n    }\n\n    // 3DTiles knows the hierarchy beforehand\n    if (this.type === TILESET_TYPE.TILES3D) {\n      const stack: Tile3D[] = [];\n      stack.push(rootTile);\n\n      while (stack.length > 0) {\n        const tile = stack.pop() as Tile3D;\n        this.stats.get(TILES_TOTAL).incrementCount();\n        const children = tile.header.children || [];\n        for (const childHeader of children) {\n          const childTile = new Tile3D(this, childHeader, tile);\n          tile.children.push(childTile);\n          childTile.depth = tile.depth + 1;\n          stack.push(childTile);\n        }\n      }\n    }\n\n    return rootTile;\n  }\n\n  _initializeTraverser() {\n    let TraverserClass;\n    const type = this.type;\n    switch (type) {\n      case TILESET_TYPE.TILES3D:\n        TraverserClass = Tileset3DTraverser;\n        break;\n      case TILESET_TYPE.I3S:\n        TraverserClass = I3SetTraverser;\n        break;\n      default:\n        TraverserClass = TilesetTraverser;\n    }\n\n    return new TraverserClass({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n\n  _destroyTileHeaders(parentTile) {\n    this._destroySubtree(parentTile);\n  }\n\n  async _loadTile(tile) {\n    let loaded;\n    try {\n      this._onStartTileLoading();\n      loaded = await tile.loadContent();\n    } catch (error) {\n      this._onTileLoadError(tile, error);\n    } finally {\n      this._onEndTileLoading();\n      this._onTileLoad(tile, loaded);\n    }\n  }\n\n  _onTileLoadError(tile, error) {\n    this.stats.get(TILES_LOAD_FAILED).incrementCount();\n\n    const message = error.message || error.toString();\n    const url = tile.url;\n    // TODO - Allow for probe log to be injected instead of console?\n    console.error(`A 3D tile failed to load: ${tile.url} ${message}`); // eslint-disable-line\n    this.options.onTileError(tile, message, url);\n  }\n\n  _onTileLoad(tile, loaded) {\n    if (!loaded) {\n      return;\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      // We can't calculate tiles total in I3S in advance so we calculate it dynamically.\n      const nodesInNodePages = this.tileset?.nodePagesTile?.nodesInNodePages || 0;\n      this.stats.get(TILES_TOTAL).reset();\n      this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);\n    }\n\n    // add coordinateOrigin and modelMatrix to tile\n    if (tile && tile.content) {\n      calculateTransformProps(tile, tile.content);\n    }\n\n    this._addTileToCache(tile);\n    this.options.onTileLoad(tile);\n  }\n\n  _onStartTileLoading() {\n    this._pendingCount++;\n    this.stats.get(TILES_LOADING).incrementCount();\n  }\n\n  _onEndTileLoading() {\n    this._pendingCount--;\n    this.stats.get(TILES_LOADING).decrementCount();\n  }\n\n  _addTileToCache(tile) {\n    this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));\n  }\n\n  _updateCacheStats(tile) {\n    this.stats.get(TILES_LOADED).incrementCount();\n    this.stats.get(TILES_IN_MEMORY).incrementCount();\n\n    // Good enough? Just use the raw binary ArrayBuffer's byte length.\n    this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n  }\n\n  _unloadTile(tile) {\n    this.gpuMemoryUsageInBytes -= (tile.content && tile.content.byteLength) || 0;\n\n    this.stats.get(TILES_IN_MEMORY).decrementCount();\n    this.stats.get(TILES_UNLOADED).incrementCount();\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n\n    this.options.onTileUnload(tile);\n    tile.unloadContent();\n  }\n\n  // Traverse the tree and destroy all tiles\n  _destroy() {\n    const stack: Tile3D[] = [];\n\n    if (this.root) {\n      stack.push(this.root);\n    }\n\n    while (stack.length > 0) {\n      const tile: Tile3D = stack.pop() as Tile3D;\n\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n\n      this._destroyTile(tile);\n    }\n    this.root = null;\n  }\n\n  // Traverse the tree and destroy all sub tiles\n  _destroySubtree(tile) {\n    const root = tile;\n    const stack: Tile3D[] = [];\n    stack.push(root);\n    while (stack.length > 0) {\n      tile = stack.pop();\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n      if (tile !== root) {\n        this._destroyTile(tile);\n      }\n    }\n    root.children = [];\n  }\n\n  _destroyTile(tile) {\n    this._cache.unloadTile(this, tile);\n    this._unloadTile(tile);\n    tile.destroy();\n  }\n\n  _initializeTiles3DTileset(tilesetJson) {\n    this.asset = tilesetJson.asset;\n    if (!this.asset) {\n      throw new Error('Tileset must have an asset property.');\n    }\n    if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {\n      throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');\n    }\n\n    // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)\n    // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version\n    if ('tilesetVersion' in this.asset) {\n      this._queryParams.v = this.asset.tilesetVersion;\n    }\n\n    // TODO - ion resources have a credits property we can use for additional attribution.\n    this.credits = {\n      attributions: this.options.attributions || []\n    };\n    this.description = this.options.description || '';\n\n    // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.\n    this.properties = tilesetJson.properties;\n    this.geometricError = tilesetJson.geometricError;\n    this._extensionsUsed = tilesetJson.extensionsUsed;\n    // Returns the extras property at the top of the tileset JSON (application specific metadata).\n    this.extras = tilesetJson.extras;\n  }\n\n  _initializeI3STileset() {\n    if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n      this._queryParams.token = this.loadOptions.i3s.token;\n    }\n  }\n}\n\nfunction getQueryParamString(queryParams): string {\n  const queryParamStrings: string[] = [];\n  for (const key of Object.keys(queryParams)) {\n    queryParamStrings.push(`${key}=${queryParams[key]}`);\n  }\n  switch (queryParamStrings.length) {\n    case 0:\n      return '';\n    case 1:\n      return `?${queryParamStrings[0]}`;\n    default:\n      return `?${queryParamStrings.join('&')}`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}