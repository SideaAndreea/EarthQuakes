{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Matrix4 } from '@math.gl/core';\nimport Viewport from './viewport';\nimport { PROJECTION_MODE } from '../lib/constants';\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nexport default class GlobeViewport extends Viewport {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      nearZMultiplier = 0.1,\n      farZMultiplier = 2,\n      resolution = 10\n    } = opts;\n    let {\n      height,\n      altitude = 1.5\n    } = opts;\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n    const viewMatrix = new Matrix4().lookAt({\n      eye: [0, -altitude, 0],\n      up: [0, 0, 1]\n    });\n    const scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n    const halfFov = Math.atan(0.5 / altitude);\n    const relativeScale = GLOBE_RADIUS * 2 * scale / height;\n    super({ ...opts,\n      height,\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n      distanceScales: getDistanceScales(),\n      fovyRadians: halfFov * 2,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n\n    _defineProperty(this, \"longitude\", void 0);\n\n    _defineProperty(this, \"latitude\", void 0);\n\n    _defineProperty(this, \"resolution\", void 0);\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.resolution = resolution;\n  }\n\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n\n  getBounds() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const left = this.unproject([0, this.height / 2], unprojectOption);\n    const top = this.unproject([this.width / 2, 0], unprojectOption);\n    const right = this.unproject([this.width, this.height / 2], unprojectOption);\n    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n    if (right[0] < this.longitude) right[0] += 360;\n    if (left[0] > this.longitude) left[0] -= 360;\n    return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];\n  }\n\n  unproject(xyz) {\n    let {\n      topLeft = true,\n      targetZ\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const {\n      pixelUnprojectionMatrix\n    } = this;\n    let coord;\n\n    if (Number.isFinite(z)) {\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = 4 * sSqr / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n\n  unprojectPosition(xyz) {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n\n  projectFlat(xyz) {\n    return xyz;\n  }\n\n  unprojectFlat(xyz) {\n    return xyz;\n  }\n\n  panByPosition(coords, pixel) {\n    const fromPosition = this.unproject(pixel);\n    return {\n      longitude: coords[0] - fromPosition[0] + this.longitude,\n      latitude: coords[1] - fromPosition[1] + this.latitude\n    };\n  }\n\n}\n\nfunction transformVector(matrix, vector) {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}","map":{"version":3,"mappings":"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","names":["Matrix4","Viewport","PROJECTION_MODE","vec3","vec4","DEGREES_TO_RADIANS","Math","PI","RADIANS_TO_DEGREES","EARTH_RADIUS","GLOBE_RADIUS","getDistanceScales","unitsPerMeter","unitsPerDegree","unitsPerMeter2","metersPerUnit","unitsPerDegree2","degreesPerUnit","GlobeViewport","constructor","opts","latitude","longitude","zoom","nearZMultiplier","farZMultiplier","resolution","height","altitude","max","viewMatrix","lookAt","eye","up","scale","pow","rotateX","rotateZ","halfFov","atan","relativeScale","distanceScales","fovyRadians","focalDistance","near","far","min","_defineProperty","projectionMode","GLOBE","getBounds","options","unprojectOption","targetZ","z","left","unproject","top","width","right","bottom","xyz","topLeft","x","y","y2","pixelUnprojectionMatrix","coord","Number","isFinite","transformVector","coord0","coord1","lt","lSqr","sqrLen","sub","l0Sqr","l1Sqr","sSqr","dSqr","r0","sqrt","dr","t","lerp","X","Y","Z","unprojectPosition","projectPosition","lng","lat","lambda","phi","cosPhi","cos","D","sin","len","asin","atan2","projectFlat","unprojectFlat","panByPosition","coords","pixel","fromPosition","matrix","vector","result","transformMat4"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@deck.gl\\core\\src\\viewports\\globe-viewport.ts"],"sourcesContent":["import {Matrix4} from '@math.gl/core';\nimport Viewport from './viewport';\nimport {PROJECTION_MODE} from '../lib/constants';\n\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = (Math.PI / 180) * GLOBE_RADIUS;\n\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nexport type GlobeViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** Longitude in degrees */\n  longitude?: number;\n  /** Latitude in degrees */\n  latitude?: number;\n  /** Camera altitude relative to the viewport height, used to control the FOV. Default `1.5` */\n  altitude?: number;\n  /* Meter offsets of the viewport center from lng, lat */\n  position?: number[];\n  /** Zoom level */\n  zoom?: number;\n  /** Use orthographic projection */\n  orthographic?: boolean;\n  /** Scaler for the near plane, 1 unit equals to the height of the viewport. Default `0.1` */\n  nearZMultiplier?: number;\n  /** Scaler for the far plane, 1 unit equals to the distance from the camera to the edge of the screen. Default `2` */\n  farZMultiplier?: number;\n  /** The resolution at which to turn flat features into 3D meshes, in degrees. Smaller numbers will generate more detailed mesh. Default `10` */\n  resolution?: number;\n};\n\nexport default class GlobeViewport extends Viewport {\n  // @ts-ignore\n  longitude: number;\n  // @ts-ignore\n  latitude: number;\n  resolution: number;\n\n  constructor(opts: GlobeViewportOptions = {}) {\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      nearZMultiplier = 0.1,\n      farZMultiplier = 2,\n      resolution = 10\n    } = opts;\n\n    let {height, altitude = 1.5} = opts;\n\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n\n    // Calculate view matrix\n    const viewMatrix = new Matrix4().lookAt({eye: [0, -altitude, 0], up: [0, 0, 1]});\n    const scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n\n    const halfFov = Math.atan(0.5 / altitude);\n    const relativeScale = (GLOBE_RADIUS * 2 * scale) / height;\n\n    super({\n      ...opts,\n      // x, y, width,\n      height,\n\n      // view matrix\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n\n      // projection matrix parameters\n      distanceScales: getDistanceScales(),\n      fovyRadians: halfFov * 2,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.resolution = resolution;\n  }\n\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n\n  getBounds(options: {z?: number} = {}): [number, number, number, number] {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const left = this.unproject([0, this.height / 2], unprojectOption);\n    const top = this.unproject([this.width / 2, 0], unprojectOption);\n    const right = this.unproject([this.width, this.height / 2], unprojectOption);\n    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n\n    if (right[0] < this.longitude) right[0] += 360;\n    if (left[0] > this.longitude) left[0] -= 360;\n\n    return [\n      Math.min(left[0], right[0], top[0], bottom[0]),\n      Math.min(left[1], right[1], top[1], bottom[1]),\n      Math.max(left[0], right[0], top[0], bottom[0]),\n      Math.max(left[1], right[1], top[1], bottom[1])\n    ];\n  }\n\n  unproject(\n    xyz: number[],\n    {topLeft = true, targetZ}: {topLeft?: boolean; targetZ?: number} = {}\n  ): number[] {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const {pixelUnprojectionMatrix} = this;\n\n    let coord;\n    if (Number.isFinite(z)) {\n      // Has depth component\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      // since we don't know the correct projected z value for the point,\n      // unproject two points to get a line and then find the point on that line that intersects with the sphere\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = (4 * sSqr) / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ as number] : [X, Y];\n  }\n\n  projectPosition(xyz: number[]): [number, number, number] {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n\n  unprojectPosition(xyz: number[]): [number, number, number] {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n\n  projectFlat(xyz: number[]): [number, number] {\n    return xyz as [number, number];\n  }\n\n  unprojectFlat(xyz: number[]): [number, number] {\n    return xyz as [number, number];\n  }\n\n  panByPosition(coords: number[], pixel: number[]): GlobeViewportOptions {\n    const fromPosition = this.unproject(pixel);\n    return {\n      longitude: coords[0] - fromPosition[0] + this.longitude,\n      latitude: coords[1] - fromPosition[1] + this.latitude\n    };\n  }\n}\n\nfunction transformVector(matrix: number[], vector: number[]): number[] {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}