{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { h3ToGeoBoundary, h3GetResolution, h3ToGeo, geoToH3, h3IsPentagon, h3Distance, edgeLength } from 'h3-js';\nimport { lerp } from '@math.gl/core';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nconst UPDATE_THRESHOLD_KM = 10;\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\nexport function scalePolygon(hexId, vertices, factor) {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n  normalizeLongitudes(vertices, lng);\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId) {\n  let coverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    normalizeLongitudes(vertices);\n  }\n\n  return vertices;\n}\n\nfunction flattenPolygon(vertices) {\n  const positions = new Float64Array(vertices.length * 2);\n  let i = 0;\n\n  for (const pt of vertices) {\n    positions[i++] = pt[0];\n    positions[i++] = pt[1];\n  }\n\n  return positions;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = { ...getHexagon,\n      coverage\n    };\n  } else {\n    trigger = {\n      getHexagon,\n      coverage\n    };\n  }\n\n  return trigger;\n}\n\nconst defaultProps = { ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: x => x.hexagon\n  },\n  extruded: true\n};\nexport default class H3HexagonLayer extends CompositeLayer {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  initializeState() {\n    H3HexagonLayer._checkH3Lib();\n\n    this.state = {\n      edgeLengthKM: 0,\n      resolution: -1\n    };\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n  }\n\n  updateState(_ref2) {\n    let {\n      props,\n      changeFlags\n    } = _ref2;\n\n    if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {\n      const dataProps = this._calculateH3DataProps();\n\n      this.setState(dataProps);\n    }\n\n    this._updateVertices(this.context.viewport);\n  }\n\n  _calculateH3DataProps() {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(this.props.data);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = this.props.getHexagon(object, objectInfo);\n      const hexResolution = h3GetResolution(hexId);\n\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!this.props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n\n      if (h3IsPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? edgeLength(resolution, 'km') : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n\n  _shouldUseHighPrecision() {\n    if (this.props.highPrecision === 'auto') {\n      const {\n        resolution,\n        hasPentagon,\n        hasMultipleRes\n      } = this.state;\n      const {\n        viewport\n      } = this.context;\n      return Boolean(viewport === null || viewport === void 0 ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n    }\n\n    return this.props.highPrecision;\n  }\n\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n\n    const {\n      resolution,\n      edgeLengthKM,\n      centerHex\n    } = this.state;\n\n    if (resolution < 0) {\n      return;\n    }\n\n    const hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n\n    if (centerHex === hex) {\n      return;\n    }\n\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {\n      unitsPerMeter\n    } = viewport.distanceScales;\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];\n    });\n    this.setState({\n      centerHex: hex,\n      vertices\n    });\n  }\n\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n\n  _renderPolygonLayer() {\n    const {\n      data,\n      getHexagon,\n      updateTriggers,\n      coverage\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n\n    const forwardProps = this._getForwardProps();\n\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n    return new SubLayerClass(forwardProps, this.getSubLayerProps({\n      id: 'hexagon-cell-hifi',\n      updateTriggers: forwardProps.updateTriggers\n    }), {\n      data,\n      _normalize: false,\n      _windingOrder: 'CCW',\n      positionFormat: 'XY',\n      getPolygon: (object, objectInfo) => {\n        const hexagonId = getHexagon(object, objectInfo);\n        return flattenPolygon(h3ToPolygon(hexagonId, coverage));\n      }\n    });\n  }\n\n  _renderColumnLayer() {\n    const {\n      data,\n      getHexagon,\n      updateTriggers\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n\n    const forwardProps = this._getForwardProps();\n\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n    return new SubLayerClass(forwardProps, this.getSubLayerProps({\n      id: 'hexagon-cell',\n      flatShading: true,\n      updateTriggers: forwardProps.updateTriggers\n    }), {\n      data,\n      diskResolution: 6,\n      radius: 1,\n      vertices: this.state.vertices,\n      getPosition: getHexagonCentroid.bind(null, getHexagon)\n    });\n  }\n\n}\n\n_defineProperty(H3HexagonLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(H3HexagonLayer, \"layerName\", 'H3HexagonLayer');\n\n_defineProperty(H3HexagonLayer, \"_checkH3Lib\", () => {});","map":{"version":3,"mappings":"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","names":["h3ToGeoBoundary","h3GetResolution","h3ToGeo","geoToH3","h3IsPentagon","h3Distance","edgeLength","lerp","CompositeLayer","createIterable","ColumnLayer","PolygonLayer","UPDATE_THRESHOLD_KM","normalizeLongitudes","vertices","refLng","undefined","pt","deltaLng","scalePolygon","hexId","factor","lat","lng","actualCount","length","vertexCount","i","getHexagonCentroid","getHexagon","object","objectInfo","hexagonId","h3ToPolygon","coverage","flattenPolygon","positions","Float64Array","mergeTriggers","trigger","defaultProps","highPrecision","type","min","max","value","centerHexagon","x","hexagon","extruded","H3HexagonLayer","constructor","_defineProperty","initializeState","_checkH3Lib","state","edgeLengthKM","resolution","shouldUpdateState","changeFlags","_shouldUseHighPrecision","propsOrDataChanged","somethingChanged","updateState","props","dataChanged","updateTriggersChanged","dataProps","_calculateH3DataProps","setState","_updateVertices","context","viewport","hasPentagon","hasMultipleRes","iterable","data","index","hexResolution","Boolean","centerHex","hex","latitude","longitude","distance","unitsPerMeter","distanceScales","centerLat","centerLng","centerX","centerY","projectFlat","map","p","worldPosition","renderLayers","_renderPolygonLayer","_renderColumnLayer","_getForwardProps","elevationScale","material","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","getFillColor","getElevation","getLineColor","getLineWidth","transitions","updateTriggers","SubLayerClass","getSubLayerClass","forwardProps","getPolygon","getSubLayerProps","id","_normalize","_windingOrder","positionFormat","getPosition","flatShading","diskResolution","radius","bind"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@deck.gl\\geo-layers\\src\\h3-layers\\h3-hexagon-layer.ts"],"sourcesContent":["import {\n  h3ToGeoBoundary,\n  h3GetResolution,\n  h3ToGeo,\n  geoToH3,\n  h3IsPentagon,\n  h3Distance,\n  edgeLength,\n  H3Index\n} from 'h3-js';\nimport {lerp} from '@math.gl/core';\nimport {\n  AccessorFunction,\n  CompositeLayer,\n  CompositeLayerProps,\n  createIterable,\n  Layer,\n  LayersList,\n  UpdateParameters,\n  WebMercatorViewport,\n  DefaultProps\n} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer, PolygonLayerProps} from '@deck.gl/layers';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices: number[][], refLng?: number): void {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId: H3Index, vertices: number[][], factor: number): void {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `h3ToGeoBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId: H3Index, coverage: number = 1): number[][] {\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  return vertices;\n}\n\nfunction flattenPolygon(vertices: number[][]): Float64Array {\n  const positions = new Float64Array(vertices.length * 2);\n  let i = 0;\n  for (const pt of vertices) {\n    positions[i++] = pt[0];\n    positions[i++] = pt[1];\n  }\n  return positions;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {...getHexagon, coverage};\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps: DefaultProps<H3HexagonLayerProps> = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: x => x.hexagon},\n  extruded: true\n};\n\n/** All properties supported by H3HexagonLayer */\nexport type H3HexagonLayerProps<DataT = any> = _H3HexagonLayerProps<DataT> &\n  PolygonLayerProps<DataT> &\n  CompositeLayerProps<DataT>;\n\n/** Props added by the H3HexagonLayer */\ntype _H3HexagonLayerProps<DataT> = {\n  /**\n   * Whether or not draw hexagons with high precision.\n   * @default 'auto'\n   */\n  highPrecision?: boolean | 'auto';\n  /**\n   * Coverage of hexagon in cell.\n   * @default 1\n   */\n  coverage?: number;\n  /**\n   * Center hexagon that best represents the shape of the set. If not specified, the hexagon closest to the center of the viewport is used.\n   */\n  centerHexagon?: H3Index | null;\n  /**\n   * Called for each data object to retrieve the quadkey string identifier.\n   *\n   * By default, it reads `hexagon` property of data object.\n   */\n  getHexagon?: AccessorFunction<DataT, string>;\n  /**\n   * Whether to extrude polygons.\n   * @default true\n   */\n  extruded?: boolean;\n};\n\n/**\n * Render hexagons from the [H3](https://h3geo.org/) geospatial indexing system.\n */\nexport default class H3HexagonLayer<DataT = any, ExtraPropsT = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_H3HexagonLayerProps<DataT> & Required<PolygonLayerProps<DataT>>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'H3HexagonLayer';\n\n  // See `main/bundle.ts`\n  static _checkH3Lib = () => {};\n\n  initializeState() {\n    H3HexagonLayer._checkH3Lib();\n    this.state = {\n      edgeLengthKM: 0,\n      resolution: -1\n    };\n  }\n\n  state!: {\n    centerHex?: H3Index;\n    edgeLengthKM: number;\n    hasMultipleRes?: boolean;\n    hasPentagon?: boolean;\n    resolution: number;\n    vertices?: number[][];\n  };\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>): boolean {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (\n      props.highPrecision !== true &&\n      (changeFlags.dataChanged ||\n        (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon))\n    ) {\n      const dataProps = this._calculateH3DataProps();\n      this.setState(dataProps);\n    }\n\n    this._updateVertices(this.context.viewport as WebMercatorViewport);\n  }\n\n  private _calculateH3DataProps() {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n\n    const {iterable, objectInfo} = createIterable(this.props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = this.props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = h3GetResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!this.props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (h3IsPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? edgeLength(resolution, 'km') : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n\n  private _shouldUseHighPrecision(): boolean {\n    if (this.props.highPrecision === 'auto') {\n      const {resolution, hasPentagon, hasMultipleRes} = this.state;\n      const {viewport} = this.context;\n      return (\n        Boolean(viewport?.resolution) ||\n        hasMultipleRes ||\n        hasPentagon ||\n        (resolution >= 0 && resolution <= 5)\n      );\n    }\n\n    return this.props.highPrecision;\n  }\n\n  private _updateVertices(viewport: WebMercatorViewport): void {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n      // h3Distance returns a negative number if the distance could not be computed\n      // due to the two indexes very far apart or on opposite sides of a pentagon.\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [\n        (worldPosition[0] - centerX) / unitsPerMeter[0],\n        (worldPosition[1] - centerY) / unitsPerMeter[1]\n      ];\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  private _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      } as {\n        getFillColor: any;\n        getElevation: any;\n        getLineColor: any;\n        getLineWidth: any;\n        getPolygon?: any;\n        getPosition?: any;\n      }\n    };\n  }\n\n  private _renderPolygonLayer(): PolygonLayer {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return flattenPolygon(h3ToPolygon(hexagonId, coverage));\n        }\n      }\n    );\n  }\n\n  private _renderColumnLayer(): ColumnLayer {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        flatShading: true,\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}