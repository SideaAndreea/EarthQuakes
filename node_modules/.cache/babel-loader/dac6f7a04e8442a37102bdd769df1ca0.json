{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, log, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  iconAtlas: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getIcon: {\n    type: 'accessor',\n    value: x => x.icon\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  onIconError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  }\n};\nexport default class IconLayer extends Layer {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: 5121,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const {\n      iconAtlas,\n      iconMapping,\n      data,\n      getIcon,\n      textureParameters\n    } = props;\n    const {\n      iconManager\n    } = this.state;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n    iconManager.setProps({\n      loadOptions: props.loadOptions,\n      autoPacking: !prePacked,\n      iconAtlas,\n      iconMapping: prePacked ? iconMapping : null,\n      textureParameters\n    });\n\n    if (prePacked) {\n      if (oldProps.iconMapping !== props.iconMapping) {\n        attributeManager.invalidate('getIcon');\n      }\n    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n      iconManager.packIcons(data, getIcon);\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.iconManager.finalize();\n  }\n\n  draw(_ref) {\n    let {\n      uniforms\n    } = _ref;\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      sizeUnits,\n      billboard,\n      alphaCutoff\n    } = this.props;\n    const {\n      iconManager\n    } = this.state;\n    const iconsTexture = iconManager.getTexture();\n\n    if (iconsTexture) {\n      this.state.model.setUniforms(uniforms).setUniforms({\n        iconsTexture,\n        iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n        sizeUnits: UNIT[sizeUnits],\n        sizeScale,\n        sizeMinPixels,\n        sizeMaxPixels,\n        billboard,\n        alphaCutoff\n      }).draw();\n    }\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        attributes: {\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  _onError(evt) {\n    var _this$getCurrentLayer;\n\n    const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;\n\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error.message)();\n    }\n  }\n\n  getInstanceOffset(icon) {\n    const {\n      width,\n      height,\n      anchorX = width / 2,\n      anchorY = height / 2\n    } = this.state.iconManager.getIconMapping(icon);\n    return [width / 2 - anchorX, height / 2 - anchorY];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.state.iconManager.getIconMapping(icon);\n    return [x, y, width, height];\n  }\n\n}\n\n_defineProperty(IconLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(IconLayer, \"layerName\", 'IconLayer');","map":{"version":3,"mappings":"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","names":["Layer","project32","picking","log","UNIT","Model","Geometry","vs","fs","IconManager","DEFAULT_COLOR","defaultProps","iconAtlas","type","value","async","iconMapping","sizeScale","min","billboard","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","alphaCutoff","max","getPosition","x","position","getIcon","icon","getColor","getSize","getAngle","getPixelOffset","onIconError","compare","optional","IconLayer","constructor","_defineProperty","getShaders","modules","initializeState","state","iconManager","context","gl","onUpdate","_onUpdate","bind","onError","_onError","attributeManager","getAttributeManager","addInstanced","instancePositions","size","fp64","use64bitPositions","transition","accessor","instanceSizes","defaultValue","instanceOffsets","transform","getInstanceOffset","instanceIconFrames","getInstanceIconFrame","instanceColorModes","getInstanceColorMode","instanceColors","props","colorFormat","length","normalized","instanceAngles","instancePixelOffset","updateState","params","oldProps","changeFlags","data","textureParameters","prePacked","internalState","isAsyncPropLoading","setProps","loadOptions","autoPacking","invalidate","dataChanged","updateTriggersChanged","all","packIcons","extensionsChanged","model","delete","_getModel","invalidateAll","isLoaded","finalizeState","finalize","draw","uniforms","iconsTexture","getTexture","setUniforms","iconsTextureDim","width","height","positions","id","geometry","drawMode","attributes","Float32Array","isInstanced","setNeedsRedraw","evt","getCurrentLayer","_this$getCurrentLayer","error","message","anchorX","anchorY","getIconMapping","mapping","mask","y"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@deck.gl\\layers\\src\\icon-layer\\icon-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Layer, project32, picking, log, UNIT} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\n\nimport type {\n  LayerProps,\n  Accessor,\n  AccessorFunction,\n  Position,\n  Color,\n  Texture,\n  Unit,\n  UpdateParameters,\n  LayerContext,\n  DefaultProps\n} from '@deck.gl/core';\nimport type {UnpackedIcon, IconMapping, LoadIconErrorContext} from './icon-manager';\n\ntype _IconLayerProps<DataT> = {\n  /** A prepacked image that contains all icons. */\n  iconAtlas?: string | Texture;\n  /** Icon names mapped to icon definitions, or a URL to load such mapping from a JSON file. */\n  iconMapping?: string | IconMapping;\n\n  /** Icon size multiplier.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The units of the icon size, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'pixels'\n   */\n  sizeUnits?: Unit;\n  /**\n   * The minimum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too small when zoomed out.\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too big when zoomed in.\n   */\n  sizeMaxPixels?: number;\n  /** If `true`, the icon always faces camera. Otherwise the icon faces up (z)\n   * @default true\n   */\n  billboard?: boolean;\n  /**\n   * Discard pixels whose opacity is below this threshold.\n   * A discarded pixel would create a \"hole\" in the icon that is not considered part of the object.\n   * @default 0.05\n   */\n  alphaCutoff?: number;\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Icon definition accessor.\n   * Should return the icon id if using pre-packed icons (`iconAtlas` + `iconMapping`).\n   * Return an object that defines the icon if using auto-packing.\n   */\n  getIcon?: AccessorFunction<DataT, string> | AccessorFunction<DataT, UnpackedIcon>;\n  /** Icon color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /** Icon size accessor.\n   * @default 1\n   */\n  getSize?: Accessor<DataT, number>;\n  /** Icon rotation accessor, in degrees.\n   * @default 0\n   */\n  getAngle?: Accessor<DataT, number>;\n  /**\n   * Icon offsest accessor, in pixels.\n   * @default [0, 0]\n   */\n  getPixelOffset?: Accessor<DataT, [number, number]>;\n  /**\n   * Callback called if the attempt to fetch an icon returned by `getIcon` fails.\n   */\n  onIconError?: ((context: LoadIconErrorContext) => void) | null;\n\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: Record<number, number> | null;\n};\n\nexport type IconLayerProps<DataT = any> = _IconLayerProps<DataT> & LayerProps<DataT>;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<IconLayerProps> = {\n  iconAtlas: {type: 'image', value: null, async: true},\n  iconMapping: {type: 'object', value: {}, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels\n  alphaCutoff: {type: 'number', value: 0.05, min: 0, max: 1},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getIcon: {type: 'accessor', value: x => x.icon},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 1},\n  getAngle: {type: 'accessor', value: 0},\n  getPixelOffset: {type: 'accessor', value: [0, 0]},\n\n  onIconError: {type: 'function', value: null, compare: false, optional: true}\n};\n\n/** Render raster icons at given coordinates. */\nexport default class IconLayer<DataT = any, ExtraPropsT = {}> extends Layer<\n  ExtraPropsT & Required<_IconLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'IconLayer';\n\n  state!: {\n    model?: Model;\n    iconManager: IconManager;\n  };\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps, changeFlags} = params;\n\n    const attributeManager = this.getAttributeManager();\n    const {iconAtlas, iconMapping, data, getIcon, textureParameters} = props;\n    const {iconManager} = this.state;\n\n    // internalState is always defined during updateState\n    const prePacked = iconAtlas || this.internalState!.isAsyncPropLoading('iconAtlas');\n    iconManager.setProps({\n      loadOptions: props.loadOptions,\n      autoPacking: !prePacked,\n      iconAtlas,\n      iconMapping: prePacked ? (iconMapping as IconMapping) : null,\n      textureParameters\n    });\n\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconMapping !== props.iconMapping) {\n        attributeManager!.invalidate('getIcon');\n      }\n    } else if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))\n    ) {\n      // Auto packing - getIcon is expected to return an object\n      iconManager.packIcons(data, getIcon as AccessorFunction<any, UnpackedIcon>);\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager!.invalidateAll();\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  get isLoaded(): boolean {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState(context: LayerContext): void {\n    super.finalizeState(context);\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize();\n  }\n\n  draw({uniforms}): void {\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff} = this.props;\n    const {iconManager} = this.state;\n\n    const iconsTexture = iconManager.getTexture();\n    if (iconsTexture) {\n      this.state.model\n        .setUniforms(uniforms)\n        .setUniforms({\n          iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeUnits: UNIT[sizeUnits],\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          billboard,\n          alphaCutoff\n        })\n        .draw();\n    }\n  }\n\n  protected _getModel(gl: WebGLRenderingContext): Model {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: attribute vec2 positions;\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          // The size must be explicitly passed here otherwise luma.gl\n          // will default to assuming that positions are 3D (x,y,z)\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  private _onUpdate(): void {\n    this.setNeedsRedraw();\n  }\n\n  private _onError(evt: LoadIconErrorContext): void {\n    const onIconError = this.getCurrentLayer()?.props.onIconError;\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error.message)();\n    }\n  }\n\n  protected getInstanceOffset(icon: string): number[] {\n    const {\n      width,\n      height,\n      anchorX = width / 2,\n      anchorY = height / 2\n    } = this.state.iconManager.getIconMapping(icon);\n    return [width / 2 - anchorX, height / 2 - anchorY];\n  }\n\n  protected getInstanceColorMode(icon: string): number {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  protected getInstanceIconFrame(icon: string): number[] {\n    const {x, y, width, height} = this.state.iconManager.getIconMapping(icon);\n    return [x, y, width, height];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}