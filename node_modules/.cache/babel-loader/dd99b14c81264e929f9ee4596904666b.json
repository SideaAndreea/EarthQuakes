{"ast":null,"code":"import { WorkerBody } from '@loaders.gl/worker-utils';\nlet requestId = 0;\nexport function createLoaderWorker(loader) {\n  if (!WorkerBody.inWorkerThread()) {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          const {\n            input,\n            options = {},\n            context = {}\n          } = payload;\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: { ...context,\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {\n            result\n          });\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {\n            error: message\n          });\n        }\n\n        break;\n\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer, options) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n    const payload = {\n      id,\n      input: arrayBuffer,\n      options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\nasync function parseData(_ref) {\n  let {\n    loader,\n    arrayBuffer,\n    options,\n    context\n  } = _ref;\n  let data;\n  let parser;\n\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(\"Could not load data with \".concat(loader.name, \" loader\"));\n  }\n\n  options = { ...options,\n    modules: loader && loader.options && loader.options.modules || {},\n    worker: false\n  };\n  return await parser(data, { ...options\n  }, context, loader);\n}","map":{"version":3,"mappings":"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","names":["WorkerBody","requestId","createLoaderWorker","loader","inWorkerThread","onmessage","type","payload","input","options","context","result","parseData","arrayBuffer","parse","parseOnMainThread","postMessage","error","message","Error","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener","data","parser","parseSync","parseTextSync","textDecoder","TextDecoder","decode","name","modules","worker"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@loaders.gl\\loader-utils\\src\\lib\\worker-loader-utils\\create-loader-worker.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (!WorkerBody.inWorkerThread()) {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}, context = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              ...context,\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n"]},"metadata":{},"sourceType":"module"}