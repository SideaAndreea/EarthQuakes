{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3, Matrix3, Quaternion } from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport { INTERSECTION } from '../../constants';\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nexport default class OrientedBoundingBox {\n  constructor() {\n    let center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    let halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    _defineProperty(this, \"center\", void 0);\n\n    _defineProperty(this, \"halfAxes\", void 0);\n\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n  }\n\n  getBoundingSphere() {\n    let result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BoundingSphere();\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      return INTERSECTION.INSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.from(point).subtract(this.center);\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n    u.normalize();\n    v.normalize();\n    w.normalize();\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.dot(u)) - uHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  computePlaneDistances(position, direction) {\n    let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-0, -0];\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    throw new Error('not implemented');\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Vector3","Matrix3","Quaternion","BoundingSphere","INTERSECTION","scratchVector3","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchCorner","scratchToCenter","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","OrientedBoundingBox","constructor","center","halfAxes","_defineProperty","from","halfSize","xAxis","getColumn","yAxis","zAxis","len","quaternion","normXAxis","normalize","normYAxis","normZAxis","fromMatrix3","fromCenterHalfSizeQuaternion","quaternionObject","directionsMatrix","fromQuaternion","clone","equals","right","Boolean","getBoundingSphere","result","u","v","w","cornerVector","copy","add","radius","magnitude","intersectPlane","plane","normal","normalX","x","normalY","y","normalZ","z","radEffective","Math","abs","distanceToPlane","dot","distance","OUTSIDE","INSIDE","INTERSECTING","distanceTo","point","sqrt","distanceSquaredTo","offset","subtract","uHalf","vHalf","wHalf","distanceSquared","d","computePlaneDistances","position","direction","minDist","Number","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","min","max","transform","transformation","transformAsPoint","getTransform","Error"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@math.gl\\culling\\src\\lib\\bounding-volumes\\oriented-bounding-box.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Matrix4, Quaternion, NumericArray} from '@math.gl/core';\nimport type {BoundingVolume} from './bounding-volume';\nimport BoundingSphere from './bounding-sphere';\nimport type Plane from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\n/**\n * An OrientedBoundingBox of some object is a closed and convex cuboid.\n * It can provide a tighter bounding volume than `BoundingSphere` or\n * `AxisAlignedBoundingBox` in many cases.\n */\nexport default class OrientedBoundingBox implements BoundingVolume {\n  center: Vector3;\n  halfAxes: Matrix3;\n\n  /**\n   * An OrientedBoundingBox of some object is a closed and convex cuboid.\n   * It can provide a tighter bounding volume than\n   * `BoundingSphere` or `AxisAlignedBoundingBox` in many cases.\n   */\n  constructor(center?: readonly number[], halfAxes?: readonly number[]);\n  constructor(center: Readonly<NumericArray> = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  /** Returns an array with three halfSizes for the bounding box */\n  get halfSize(): number[] {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  /** Returns a quaternion describing the orientation of the bounding box */\n  get quaternion(): Quaternion {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  /**\n   * Create OrientedBoundingBox from quaternion based OBB,\n   */\n  fromCenterHalfSizeQuaternion(\n    center: number[],\n    halfSize: number[],\n    quaternion: number[]\n  ): OrientedBoundingBox {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  /** Duplicates a OrientedBoundingBox instance. */\n  clone(): OrientedBoundingBox {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  /** Compares the provided OrientedBoundingBox component wise and returns */\n  equals(right: OrientedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */\n  getBoundingSphere(result = new BoundingSphere()): BoundingSphere {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  /** Determines which side of a plane the oriented bounding box is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /**\n   * Computes the estimated distance squared from the closest point\n   * on a bounding box to a point.\n   * See Geometric Tools for Computer Graphics 10.4.2\n   */\n  distanceSquaredTo(point: readonly number[]): number {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  /**\n   * The distances calculated by the vector from the center of the bounding box\n   * to position projected onto direction.\n   *\n   * - If you imagine the infinite number of planes with normal direction,\n   *   this computes the smallest distance to the closest and farthest planes\n   *   from `position` that intersect the bounding box.\n   *\n   * @param position The position to calculate the distance from.\n   * @param direction The direction from position.\n   * @param result An Interval (array of length 2) to store the nearest and farthest distances.\n   * @returns Interval (array of length 2) with nearest and farthest distances\n   *   on the bounding box from position in direction.\n   */\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(\n    position: readonly number[],\n    direction: Vector3,\n    result: number[] = [-0, -0]\n  ): number[] {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transformation: readonly number[]): this {\n    this.center.transformAsPoint(transformation);\n\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform(): Matrix4 {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}