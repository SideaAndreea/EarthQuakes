{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\nconst scratchVector = new Vector3();\nexport function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {\n  if (boundingVolume instanceof OrientedBoundingBox) {\n    const {\n      halfAxes\n    } = boundingVolume;\n    const obbSize = getObbSize(halfAxes);\n    return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n  } else if (boundingVolume instanceof BoundingSphere) {\n    const {\n      radius\n    } = boundingVolume;\n    return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n  } else if (boundingVolume.width && boundingVolume.height) {\n    const {\n      width,\n      height\n    } = boundingVolume;\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\nexport function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {\n  const extentVertex = Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], new Vector3());\n  const extentSize = Math.sqrt(Math.pow(extentVertex[0] - cartesianCenter[0], 2) + Math.pow(extentVertex[1] - cartesianCenter[1], 2) + Math.pow(extentVertex[2] - cartesianCenter[2], 2));\n  return Math.log2(WGS84_RADIUS_Z / (extentSize + cartorgraphicCenter[2]));\n}\nexport function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {\n  const [xmin, ymin, xmax, ymax] = extent;\n  return getZoomFromFullExtent({\n    xmin,\n    xmax,\n    ymin,\n    ymax,\n    zmin: 0,\n    zmax: 0\n  }, cartorgraphicCenter, cartesianCenter);\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}","map":{"version":3,"mappings":"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","names":["Vector3","BoundingSphere","OrientedBoundingBox","Ellipsoid","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","scratchVector","getZoomFromBoundingVolume","boundingVolume","cartorgraphicCenter","halfAxes","obbSize","getObbSize","Math","log2","radius","width","height","zoomX","zoomY","getZoomFromFullExtent","fullExtent","cartesianCenter","extentVertex","WGS84","cartographicToCartesian","xmax","ymax","zmax","extentSize","sqrt","pow","getZoomFromExtent","extent","xmin","ymin","zmin","getColumn","axeY","axeZ","farthestVertex","add","size","len"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@loaders.gl\\tiles\\src\\tileset\\helpers\\zoom.ts"],"sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {BoundingRectangle} from '../../types';\n\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\n\nconst scratchVector = new Vector3();\n\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param boundingVolume - the instance of bounding volume\n * @param cartorgraphicCenter - cartographic center of the bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(\n  boundingVolume: BoundingSphere | OrientedBoundingBox | BoundingRectangle,\n  cartorgraphicCenter: Vector3\n) {\n  if (boundingVolume instanceof OrientedBoundingBox) {\n    // OrientedBoundingBox\n    const {halfAxes} = boundingVolume;\n    const obbSize = getObbSize(halfAxes);\n    // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n  } else if (boundingVolume instanceof BoundingSphere) {\n    // BoundingSphere\n    const {radius} = boundingVolume;\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n  } else if (boundingVolume.width && boundingVolume.height) {\n    // BoundingRectangle\n    const {width, height} = boundingVolume;\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\n/**\n * Calculate initial zoom for the tileset from 3D `fullExtent` defined in\n * the tileset metadata\n * @param fullExtent - 3D extent of the tileset\n * @param fullExtent.xmin - minimal longitude in decimal degrees\n * @param fullExtent.xmax - maximal longitude in decimal degrees\n * @param fullExtent.ymin - minimal latitude in decimal degrees\n * @param fullExtent.ymax - maximal latitude in decimal degrees\n * @param fullExtent.zmin - minimal elevation in meters\n * @param fullExtent.zmax - maximal elevation in meters\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromFullExtent(\n  fullExtent: {\n    xmin: number;\n    xmax: number;\n    ymin: number;\n    ymax: number;\n    zmin: number;\n    zmax: number;\n  },\n  cartorgraphicCenter: Vector3,\n  cartesianCenter: Vector3\n) {\n  const extentVertex = Ellipsoid.WGS84.cartographicToCartesian(\n    [fullExtent.xmax, fullExtent.ymax, fullExtent.zmax],\n    new Vector3()\n  );\n  const extentSize = Math.sqrt(\n    Math.pow(extentVertex[0] - cartesianCenter[0], 2) +\n      Math.pow(extentVertex[1] - cartesianCenter[1], 2) +\n      Math.pow(extentVertex[2] - cartesianCenter[2], 2)\n  );\n  return Math.log2(WGS84_RADIUS_Z / (extentSize + cartorgraphicCenter[2]));\n}\n\n/**\n * Calculate initial zoom for the tileset from 2D `extent` defined in\n * the tileset metadata\n * @param extent - 2D extent of the tileset. It is array of 4 elements [xmin, ymin, xmax, ymax]\n * @param extent[0] - minimal longitude in decimal degrees\n * @param extent[1] - minimal latitude in decimal degrees\n * @param extent[2] - maximal longitude in decimal degrees\n * @param extent[3] - maximal latitude in decimal degrees\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromExtent(\n  extent: [number, number, number, number],\n  cartorgraphicCenter: Vector3,\n  cartesianCenter: Vector3\n) {\n  const [xmin, ymin, xmax, ymax] = extent;\n  return getZoomFromFullExtent(\n    {xmin, xmax, ymin, ymax, zmin: 0, zmax: 0},\n    cartorgraphicCenter,\n    cartesianCenter\n  );\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}\n"]},"metadata":{},"sourceType":"module"}