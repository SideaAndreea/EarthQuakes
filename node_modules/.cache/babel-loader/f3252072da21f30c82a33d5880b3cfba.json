{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ManagedArray from '../../utils/managed-array';\nimport { TILE_REFINEMENT } from '../../constants';\nexport const DEFAULT_PROPS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\nexport default class TilesetTraverser {\n  traversalFinished(frameState) {\n    return true;\n  }\n\n  constructor(options) {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"requestedTiles\", void 0);\n\n    _defineProperty(this, \"selectedTiles\", void 0);\n\n    _defineProperty(this, \"emptyTiles\", void 0);\n\n    _defineProperty(this, \"lastUpdate\", new Date().getTime());\n\n    _defineProperty(this, \"updateDebounceTime\", 1000);\n\n    _defineProperty(this, \"_traversalStack\", void 0);\n\n    _defineProperty(this, \"_emptyTraversalStack\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    this.options = { ...DEFAULT_PROPS,\n      ...options\n    };\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n    this._frameNumber = null;\n    this.root = null;\n    this.selectedTiles = {};\n    this.requestedTiles = {};\n    this.emptyTiles = {};\n  }\n\n  traverse(root, frameState, options) {\n    this.root = root;\n    this.options = { ...this.options,\n      ...options\n    };\n    this.reset();\n    this.updateTile(root, frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n\n    this._traversalStack.reset();\n\n    this._emptyTraversalStack.reset();\n  }\n\n  executeTraversal(root, frameState) {\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n    stack.push(root);\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n      let shouldRefine = false;\n\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n      }\n\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        this.loadTile(tile, frameState);\n\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      this.touchTile(tile, frameState);\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    const newTime = new Date().getTime();\n\n    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n      this.lastUpdate = newTime;\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n\n    return true;\n  }\n\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {\n      loadSiblings,\n      skipLevelOfDetail\n    } = this.options;\n    const children = tile.children;\n    children.sort(this.compareDistanceToCamera.bind(this));\n    const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n\n    return refines;\n  }\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  canTraverse(tile, frameState) {\n    let useParentMetric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let ignoreVisibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    if (tile.hasTilesetContent) {\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds = [];\n\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n\n    return anyVisible;\n  }\n\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n\n        for (const child of children) {\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n\n}","map":{"version":3,"mappings":";AAAA,OAAOA,YAAP,MAAyB,2BAAzB;AACA,SAAQC,eAAR,QAA8B,iBAA9B;AAsBA,OAAO,MAAMC,aAAoB,GAAG;EAClCC,YAAY,EAAE,KADoB;EAElCC,iBAAiB,EAAE,KAFe;EAGlCC,uBAAuB,EAAE,CAHS;EAIlCC,gBAAgB,EAAE,IAJgB;EAKlCC,cAAc,EAAE,MAAM,CALY;EAMlCC,qBAAqB,EAAE,EANW;EAOlCC,QAAQ,EAAE;AAPwB,CAA7B;AAUP,eAAe,MAAMC,gBAAN,CAAuB;EAc1BC,iBAAiB,CAACC,UAAD,EAAkC;IAC3D,OAAO,IAAP;EACD;;EAGDC,WAAW,CAACC,OAAD,EAAiC;IAAAC;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA,oCAXb,IAAIC,IAAJ,GAAWC,OAAX,EAWa;;IAAAF,4CAVJ,IAUI;;IAAAA;;IAAAA;;IAAAA;;IAC1C,KAAKD,OAAL,GAAe,EAAC,GAAGZ,aAAJ;MAAmB,GAAGY;IAAtB,CAAf;IAGA,KAAKI,eAAL,GAAuB,IAAIlB,YAAJ,EAAvB;IACA,KAAKmB,oBAAL,GAA4B,IAAInB,YAAJ,EAA5B;IAGA,KAAKoB,YAAL,GAAoB,IAApB;IAGA,KAAKC,IAAL,GAAY,IAAZ;IAIA,KAAKC,aAAL,GAAqB,EAArB;IAEA,KAAKC,cAAL,GAAsB,EAAtB;IAEA,KAAKC,UAAL,GAAkB,EAAlB;EACD;;EAGDC,QAAQ,CAACJ,IAAD,EAAOT,UAAP,EAAmBE,OAAnB,EAA4B;IAClC,KAAKO,IAAL,GAAYA,IAAZ;IACA,KAAKP,OAAL,GAAe,EAAC,GAAG,KAAKA,OAAT;MAAkB,GAAGA;IAArB,CAAf;IAGA,KAAKY,KAAL;IAGA,KAAKC,UAAL,CAAgBN,IAAhB,EAAsBT,UAAtB;IAEA,KAAKQ,YAAL,GAAoBR,UAAU,CAACgB,WAA/B;IACA,KAAKC,gBAAL,CAAsBR,IAAtB,EAA4BT,UAA5B;EACD;;EAEDc,KAAK,GAAG;IACN,KAAKH,cAAL,GAAsB,EAAtB;IACA,KAAKD,aAAL,GAAqB,EAArB;IACA,KAAKE,UAAL,GAAkB,EAAlB;;IACA,KAAKN,eAAL,CAAqBQ,KAArB;;IACA,KAAKP,oBAAL,CAA0BO,KAA1B;EACD;;EAUDG,gBAAgB,CAACR,IAAD,EAAOT,UAAP,EAA+B;IAG7C,MAAMkB,KAAK,GAAG,KAAKZ,eAAnB;IACAG,IAAI,CAACU,eAALV,GAAuB,CAAvBA;IAEAS,KAAK,CAACE,IAANF,CAAWT,IAAXS;;IACA,OAAOA,KAAK,CAACG,MAANH,GAAe,CAAtB,EAAyB;MAEvB,MAAMI,IAAI,GAAGJ,KAAK,CAACK,GAANL,EAAb;MAGA,IAAIM,YAAY,GAAG,KAAnB;;MACA,IAAI,KAAKC,WAAL,CAAiBH,IAAjB,EAAuBtB,UAAvB,CAAJ,EAAwC;QACtC,KAAK0B,gBAAL,CAAsBJ,IAAtB,EAA4BtB,UAA5B;QACAwB,YAAY,GAAG,KAAKG,qBAAL,CACbL,IADa,EAEbtB,UAFa,EAGbkB,KAHa,EAIbI,IAAI,CAACM,gBAALN,GAAwBA,IAAI,CAACH,eAALG,GAAuB,CAA/CA,GAAmDA,IAAI,CAACH,eAJ3C,CAAfK;MAMD;;MAMD,MAAMK,MAAM,GAAGP,IAAI,CAACO,MAApB;MACA,MAAMC,aAAa,GAAGC,OAAO,CAAC,CAACF,MAAD,IAAWA,MAAM,CAACG,aAAnB,CAA7B;MACA,MAAMC,eAAe,GAAG,CAACT,YAAzB;;MAEA,IAAI,CAACF,IAAI,CAACM,gBAAV,EAA4B;QAC1B,KAAKhB,UAAL,CAAgBU,IAAI,CAACY,EAArB,IAA2BZ,IAA3B;QACA,KAAKa,QAAL,CAAcb,IAAd,EAAoBtB,UAApB;;QACA,IAAIiC,eAAJ,EAAqB;UACnB,KAAKG,UAAL,CAAgBd,IAAhB,EAAsBtB,UAAtB;QACD;MALH,OAOO,IAAIsB,IAAI,CAACe,MAALf,KAAgBjC,eAAe,CAACiD,GAApC,EAAyC;QAE9C,KAAKH,QAAL,CAAcb,IAAd,EAAoBtB,UAApB;QACA,KAAKoC,UAAL,CAAgBd,IAAhB,EAAsBtB,UAAtB;MAHK,OAMA,IAAIsB,IAAI,CAACe,MAALf,KAAgBjC,eAAe,CAACkD,OAApC,EAA6C;QAGlD,KAAKJ,QAAL,CAAcb,IAAd,EAAoBtB,UAApB;;QACA,IAAIiC,eAAJ,EAAqB;UACnB,KAAKG,UAAL,CAAgBd,IAAhB,EAAsBtB,UAAtB;QACD;MACF;;MAGD,KAAKwC,SAAL,CAAelB,IAAf,EAAqBtB,UAArB;MAGAsB,IAAI,CAACU,aAALV,GAAqBE,YAAY,IAAIM,aAArCR;IACD;;IAED,MAAMmB,OAAO,GAAG,IAAIrC,IAAJ,GAAWC,OAAX,EAAhB;;IACA,IAAI,KAAKN,iBAAL,CAAuBC,UAAvB,KAAsCyC,OAAO,GAAG,KAAKC,UAAfD,GAA4B,KAAKE,kBAA3E,EAA+F;MAC7F,KAAKD,UAAL,GAAkBD,OAAlB;MACA,KAAKvC,OAAL,CAAaP,cAAb,CAA4BK,UAA5B;IACD;EACF;;EAED0B,gBAAgB,CAACJ,IAAD,EAAOtB,UAAP,EAAmB;IACjC,MAAM4C,QAAQ,GAAGtB,IAAI,CAACsB,QAAtB;;IACA,KAAK,MAAMC,KAAX,IAAoBD,QAApB,EAA8B;MAC5B,KAAK7B,UAAL,CAAgB8B,KAAhB,EAAuB7C,UAAvB;IACD;;IACD,OAAO,IAAP;EACD;;EAGD2B,qBAAqB,CAACL,IAAD,EAAOtB,UAAP,EAAmBkB,KAAnB,EAA0B4B,KAA1B,EAAiC;IACpD,MAAM;MAACvD,YAAD;MAAeC;IAAf,IAAoC,KAAKU,OAA/C;IAEA,MAAM0C,QAAQ,GAAGtB,IAAI,CAACsB,QAAtB;IAGAA,QAAQ,CAACG,IAATH,CAAc,KAAKI,uBAAL,CAA6BC,IAA7B,CAAkC,IAAlC,CAAdL;IAIA,MAAMM,YAAY,GAChB5B,IAAI,CAACe,MAALf,KAAgBjC,eAAe,CAACkD,OAAhCjB,IAA2CA,IAAI,CAACM,gBAAhDN,IAAoE,CAAC9B,iBADvE;IAGA,IAAI2D,eAAe,GAAG,KAAtB;IACA,IAAIC,OAAO,GAAG,IAAd;;IAEA,KAAK,MAAMP,KAAX,IAAoBD,QAApB,EAA8B;MAC5BC,KAAK,CAAC1B,eAAN0B,GAAwBC,KAAxBD;;MACA,IAAIA,KAAK,CAACQ,2BAAV,EAAuC;QACrC,IAAInC,KAAK,CAACoC,IAANpC,CAAW2B,KAAX3B,CAAJ,EAAuB;UACrBA,KAAK,CAACqC,MAANrC,CAAa2B,KAAb3B;QACD;;QACDA,KAAK,CAACE,IAANF,CAAW2B,KAAX3B;QACAiC,eAAe,GAAG,IAAlBA;MALF,OAMO,IAAID,YAAY,IAAI3D,YAApB,EAAkC;QAGvC,KAAK4C,QAAL,CAAcU,KAAd,EAAqB7C,UAArB;QACA,KAAKwC,SAAL,CAAeK,KAAf,EAAsB7C,UAAtB;MACD;;MAED,IAAIkD,YAAJ,EAAkB;QAChB,IAAIM,YAAJ;;QACA,IAAI,CAACX,KAAK,CAACY,gBAAX,EAA6B;UAC3BD,YAAY,GAAG,KAAfA;QADF,OAEO,IAAI,CAACX,KAAK,CAACjB,gBAAX,EAA6B;UAClC4B,YAAY,GAAG,KAAKE,qBAAL,CAA2Bb,KAA3B,EAAkC7C,UAAlC,CAAfwD;QADK,OAEA;UACLA,YAAY,GAAGX,KAAK,CAACc,gBAArBH;QACD;;QACDJ,OAAO,GAAGA,OAAO,IAAII,YAArBJ;;QAEA,IAAI,CAACA,OAAL,EAAc;UACZ,OAAO,KAAP;QACD;MACF;IACF;;IAED,IAAI,CAACD,eAAL,EAAsB;MACpBC,OAAO,GAAG,KAAVA;IACD;;IACD,OAAOA,OAAP;EACD;;EAGDrC,UAAU,CAACO,IAAD,EAAOtB,UAAP,EAAmB;IAC3B,KAAK4D,oBAAL,CAA0BtC,IAA1B,EAAgCtB,UAAhC;EACD;;EAGDoC,UAAU,CAACd,IAAD,EAAOtB,UAAP,EAAmB;IAC3B,IAAI,KAAK6D,gBAAL,CAAsBvC,IAAtB,CAAJ,EAAiC;MAE/BA,IAAI,CAACwC,cAALxC,GAAsBtB,UAAU,CAACgB,WAAjCM;MACA,KAAKZ,aAAL,CAAmBY,IAAI,CAACY,EAAxB,IAA8BZ,IAA9B;IACD;EACF;;EAGDa,QAAQ,CAACb,IAAD,EAAOtB,UAAP,EAAmB;IACzB,IAAI,KAAK+D,cAAL,CAAoBzC,IAApB,CAAJ,EAA+B;MAC7BA,IAAI,CAAC0C,eAAL1C,GAAuBtB,UAAU,CAACgB,WAAlCM;MACAA,IAAI,CAAC2C,SAAL3C,GAAiBA,IAAI,CAAC4C,YAAL5C,EAAjBA;MACA,KAAKX,cAAL,CAAoBW,IAAI,CAACY,EAAzB,IAA+BZ,IAA/B;IACD;EACF;;EAGDkB,SAAS,CAAClB,IAAD,EAAOtB,UAAP,EAAmB;IAC1BsB,IAAI,CAAC6C,OAAL7C,CAAa8C,MAAb9C,CAAoB+C,KAApB/C,CAA0BA,IAA1BA;;IACAA,IAAI,CAACgD,aAALhD,GAAqBtB,UAAU,CAACgB,WAAhCM;EACD;;EAKDG,WAAW,CAACH,IAAD,EAAOtB,UAAP,EAAsE;IAAA,IAAnDuE,eAAmD,uEAAjC,KAAiC;IAAA,IAA1BC,gBAA0B,uEAAP,KAAO;;IAC/E,IAAI,CAAClD,IAAI,CAACmD,WAAV,EAAuB;MACrB,OAAO,KAAP;IACD;;IAGD,IAAInD,IAAI,CAACoD,iBAAT,EAA4B;MAG1B,OAAO,CAACpD,IAAI,CAACqD,cAAb;IACD;;IAED,IAAI,CAACH,gBAAD,IAAqB,CAAClD,IAAI,CAAC+B,2BAA/B,EAA4D;MAC1D,OAAO,KAAP;IACD;;IAED,OAAO,KAAK7B,YAAL,CAAkBF,IAAlB,EAAwBtB,UAAxB,EAAoCuE,eAApC,CAAP;EACD;;EAEDR,cAAc,CAACzC,IAAD,EAAO;IAGnB,OAAOA,IAAI,CAACsD,kBAALtD,IAA2BA,IAAI,CAACqD,cAAvC;EACD;;EAEDd,gBAAgB,CAACvC,IAAD,EAAO;IAGrB,OAAOA,IAAI,CAACqC,gBAALrC,IAAyB,CAAC,KAAKpB,OAAL,CAAaV,iBAA9C;EACD;;EAGDgC,YAAY,CAACF,IAAD,EAAOtB,UAAP,EAAmBuE,eAAnB,EAAoC;IAC9C,IAAIM,gBAAgB,GAAGvD,IAAI,CAACwD,iBAA5B;;IACA,IAAIP,eAAJ,EAAqB;MACnBM,gBAAgB,GAAGvD,IAAI,CAACyD,mBAALzD,CAAyBtB,UAAzBsB,EAAqC,IAArCA,CAAnBuD;IACD;;IAED,OAAOA,gBAAgB,GAAG,KAAK3E,OAAL,CAAaT,uBAAvC;EACD;;EAEDmE,oBAAoB,CAACtC,IAAD,EAAOtB,UAAP,EAAmB;IACrC,MAAMgF,WAAqB,GAAG,EAA9B;;IACA,IAAI,KAAK9E,OAAL,CAAaN,qBAAjB,EAAwC;MACtC,KAAK,MAAMqF,GAAX,IAAkB,KAAK/E,OAAL,CAAaN,qBAA/B,EAAsD;QACpD,MAAMsF,KAAK,GAAG,KAAKhF,OAAL,CAAaN,qBAAb,CAAmCqF,GAAnC,CAAd;;QACA,IAAIC,KAAK,KAAKlF,UAAU,CAACmF,QAAXnF,CAAoBkC,EAAlC,EAAsC;UACpC8C,WAAW,CAAC5D,IAAZ4D,CAAiBC,GAAjBD;QACD;MACF;IANH,OAOO;MACLA,WAAW,CAAC5D,IAAZ4D,CAAiBhF,UAAU,CAACmF,QAAXnF,CAAoBkC,EAArC8C;IACD;;IACD1D,IAAI,CAAC8D,gBAAL9D,CAAsBtB,UAAtBsB,EAAkC0D,WAAlC1D;EACD;;EAID0B,uBAAuB,CAACqC,CAAD,EAAIC,CAAJ,EAAO;IAC5B,OAAOD,CAAC,CAACE,iBAAFF,GAAsBC,CAAC,CAACC,iBAA/B;EACD;;EAEDC,kBAAkB,CAAClE,IAAD,EAAOtB,UAAP,EAAmB;IACnC,IAAIyF,UAAU,GAAG,KAAjB;;IACA,KAAK,MAAM5C,KAAX,IAAoBvB,IAAI,CAACsB,QAAzB,EAAmC;MACjCC,KAAK,CAACuC,gBAANvC,CAAuB7C,UAAvB6C;MACA4C,UAAU,GAAGA,UAAU,IAAI5C,KAAK,CAACQ,2BAAjCoC;IACD;;IACD,OAAOA,UAAP;EACD;;EAID/B,qBAAqB,CAACjD,IAAD,EAAOT,UAAP,EAAmB;IACtC,IAAI0F,oBAAoB,GAAG,IAA3B;IACA,MAAMxE,KAAK,GAAG,KAAKX,oBAAnB;IAEAW,KAAK,CAACE,IAANF,CAAWT,IAAXS;;IAEA,OAAOA,KAAK,CAACG,MAANH,GAAe,CAAfA,IAAoBwE,oBAA3B,EAAiD;MAC/C,MAAMpE,IAAI,GAAGJ,KAAK,CAACK,GAANL,EAAb;MAEA,KAAKH,UAAL,CAAgBO,IAAhB,EAAsBtB,UAAtB;;MAEA,IAAI,CAACsB,IAAI,CAAC+B,2BAAV,EAAuC;QAErC,KAAKlB,QAAL,CAAcb,IAAd,EAAoBtB,UAApB;MACD;;MAED,KAAKwC,SAAL,CAAelB,IAAf,EAAqBtB,UAArB;MAGA,MAAMa,QAAQ,GAAG,CAACS,IAAI,CAACM,gBAAN,IAA0B,KAAKH,WAAL,CAAiBH,IAAjB,EAAuBtB,UAAvB,EAAmC,KAAnC,EAA0C,IAA1C,CAA3C;;MAEA,IAAIa,QAAJ,EAAc;QACZ,MAAM+B,QAAQ,GAAGtB,IAAI,CAACsB,QAAtB;;QACA,KAAK,MAAMC,KAAX,IAAoBD,QAApB,EAA8B;UAE5B,IAAI1B,KAAK,CAACoC,IAANpC,CAAW2B,KAAX3B,CAAJ,EAAuB;YACrBA,KAAK,CAACqC,MAANrC,CAAa2B,KAAb3B;UACD;;UACDA,KAAK,CAACE,IAANF,CAAW2B,KAAX3B;QACD;MARH,OASO,IAAI,CAACI,IAAI,CAACqC,gBAAV,EAA4B;QACjC+B,oBAAoB,GAAG,KAAvBA;MACD;IACF;;IAED,OAAOA,oBAAP;EACD;;AAvVmC","names":["ManagedArray","TILE_REFINEMENT","DEFAULT_PROPS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","updateTransforms","onTraversalEnd","viewportTraversersMap","basePath","TilesetTraverser","traversalFinished","frameState","constructor","options","_defineProperty","Date","getTime","_traversalStack","_emptyTraversalStack","_frameNumber","root","selectedTiles","requestedTiles","emptyTiles","traverse","reset","updateTile","frameNumber","executeTraversal","stack","_selectionDepth","push","length","tile","pop","shouldRefine","canTraverse","updateChildTiles","updateAndPushChildren","hasRenderContent","parent","parentRefines","Boolean","_shouldRefine","stoppedRefining","id","loadTile","selectTile","refine","ADD","REPLACE","touchTile","newTime","lastUpdate","updateDebounceTime","children","child","depth","sort","compareDistanceToCamera","bind","checkRefines","hasVisibleChild","refines","isVisibleAndInRequestVolume","find","delete","childRefines","_inRequestVolume","executeEmptyTraversal","contentAvailable","updateTileVisibility","shouldSelectTile","_selectedFrame","shouldLoadTile","_requestedFrame","_priority","_getPriority","tileset","_cache","touch","_touchedFrame","useParentMetric","ignoreVisibility","hasChildren","hasTilesetContent","contentExpired","hasUnloadedContent","screenSpaceError","_screenSpaceError","getScreenSpaceError","viewportIds","key","value","viewport","updateVisibility","b","a","_distanceToCamera","anyChildrenVisible","anyVisible","allDescendantsLoaded"],"sources":["C:\\Users\\user\\OneDrive\\Desktop\\Internship\\react-internship-22\\Exercices\\earthquakes\\node_modules\\@loaders.gl\\tiles\\src\\tileset\\traversers\\tileset-traverser.ts"],"sourcesContent":["import ManagedArray from '../../utils/managed-array';\nimport {TILE_REFINEMENT} from '../../constants';\nimport {FrameState} from '../helpers/frame-state';\n\nexport type TilesetTraverserProps = {\n  loadSiblings?: boolean;\n  skipLevelOfDetail?: boolean;\n  maximumScreenSpaceError?: number;\n  onTraversalEnd?: (frameState) => any;\n  viewportTraversersMap?: {[key: string]: any};\n  basePath?: string;\n};\n\nexport type Props = {\n  loadSiblings: boolean;\n  skipLevelOfDetail: boolean;\n  updateTransforms: boolean;\n  maximumScreenSpaceError: number;\n  onTraversalEnd: (frameState) => any;\n  viewportTraversersMap: {[key: string]: any};\n  basePath: string;\n};\n\nexport const DEFAULT_PROPS: Props = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\n\nexport default class TilesetTraverser {\n  options: Props;\n\n  root: any;\n  requestedTiles: object;\n  selectedTiles: object;\n  emptyTiles: object;\n\n  protected lastUpdate: number = new Date().getTime();\n  protected readonly updateDebounceTime = 1000;\n  protected _traversalStack: ManagedArray;\n  protected _emptyTraversalStack: ManagedArray;\n  protected _frameNumber: number | null;\n\n  protected traversalFinished(frameState: FrameState): boolean {\n    return true;\n  }\n\n  // TODO nested props\n  constructor(options: TilesetTraverserProps) {\n    this.options = {...DEFAULT_PROPS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState: FrameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(\n          tile,\n          frameState,\n          stack,\n          tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth\n        );\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    const newTime = new Date().getTime();\n    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n      this.lastUpdate = newTime;\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds: string[] = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"]},"metadata":{},"sourceType":"module"}