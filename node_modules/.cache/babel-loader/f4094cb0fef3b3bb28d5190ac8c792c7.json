{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Tile2DHeader from './tile-2d-header';\nimport { getTileIndices, tileToBoundingBox, getCullBounds } from './utils';\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4, equals } from '@math.gl/core';\nimport { _memoize as memoize } from '@deck.gl/core';\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\nconst DEFAULT_CACHE_SCALE = 5;\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\nexport default class Tileset2D {\n  constructor(opts) {\n    _defineProperty(this, \"opts\", void 0);\n\n    _defineProperty(this, \"_requestScheduler\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    _defineProperty(this, \"_dirty\", void 0);\n\n    _defineProperty(this, \"_tiles\", void 0);\n\n    _defineProperty(this, \"_cacheByteSize\", void 0);\n\n    _defineProperty(this, \"_viewport\", void 0);\n\n    _defineProperty(this, \"_zRange\", void 0);\n\n    _defineProperty(this, \"_selectedTiles\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    _defineProperty(this, \"_modelMatrix\", void 0);\n\n    _defineProperty(this, \"_modelMatrixInverse\", void 0);\n\n    _defineProperty(this, \"_maxZoom\", void 0);\n\n    _defineProperty(this, \"_minZoom\", void 0);\n\n    _defineProperty(this, \"onTileLoad\", void 0);\n\n    _defineProperty(this, \"_getCullBounds\", memoize(getCullBounds));\n\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n    this.setOptions(opts);\n  }\n\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload() {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n\n    this._cache.clear();\n\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id);\n\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  update(viewport) {\n    let {\n      zRange,\n      modelMatrix\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n\n    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        this._rebuildTree();\n      }\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile => this._getTile(tile.index, true));\n    }\n\n    const changed = this.updateTileStates();\n\n    this._pruneRequests();\n\n    if (this._dirty) {\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  isTileVisible(tile, cullRect) {\n    if (!tile.isVisible) {\n      return false;\n    }\n\n    if (cullRect && this._viewport) {\n      const [minX, minY, maxX, maxY] = getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n      const {\n        bbox\n      } = tile;\n\n      if ('west' in bbox) {\n        return bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n      }\n\n      const y0 = Math.min(bbox.top, bbox.bottom);\n      const y1 = Math.max(bbox.top, bbox.bottom);\n      return bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n    }\n\n    return true;\n  }\n\n  getTileIndices(_ref) {\n    let {\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      modelMatrix,\n      modelMatrixInverse\n    } = _ref;\n    const {\n      tileSize,\n      extent,\n      zoomOffset\n    } = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  getTileId(index) {\n    return \"\".concat(index.x, \"-\").concat(index.y, \"-\").concat(index.z);\n  }\n\n  getTileZoom(index) {\n    return index.z;\n  }\n\n  getTileMetadata(index) {\n    const {\n      tileSize\n    } = this.opts;\n    return {\n      bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)\n    };\n  }\n\n  getParentIndex(index) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {\n      x,\n      y,\n      z\n    };\n  }\n\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n\n    for (const tile of this._cache.values()) {\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n    i = 0;\n\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _pruneRequests() {\n    const {\n      maxRequests\n    } = this.opts;\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  _rebuildTree() {\n    const {\n      _cache\n    } = this;\n\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n\n      tile.parent = parent;\n\n      if (parent !== null && parent !== void 0 && parent.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  _resizeCache() {\n    const {\n      _cache,\n      opts\n    } = this;\n    const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible) {\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n\n          _cache.delete(id);\n\n          this.opts.onTileUnload(tile);\n        }\n\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n\n      this._rebuildTree();\n\n      this._dirty = true;\n    }\n\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n      this._dirty = false;\n    }\n  }\n\n  _getTile(index, create) {\n    const id = this.getTileId(index);\n\n    let tile = this._cache.get(id);\n\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {\n        id,\n        zoom: this.getTileZoom(tile.index)\n      });\n      needsReload = true;\n\n      this._cache.set(id, tile);\n\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n\n    if (tile && needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(tile) {\n    const {\n      _minZoom = 0\n    } = this;\n    let index = tile.index;\n\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n\n      const parent = this._getTile(index);\n\n      if (parent) {\n        return parent;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\n\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n\n    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\nfunction getPlaceholderInAncestors(startTile) {\n  let tile = startTile;\n\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n\n    tile = tile.parent;\n  }\n\n  return false;\n}\n\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Tile2DHeader","getTileIndices","tileToBoundingBox","getCullBounds","RequestScheduler","Matrix4","equals","_memoize","memoize","TILE_STATE_VISITED","TILE_STATE_VISIBLE","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","STRATEGIES","updateTileStateDefault","updateTileStateReplace","Tileset2D","constructor","opts","_defineProperty","onTileLoad","tile","maxCacheByteSize","_cacheByteSize","byteLength","_resizeCache","_requestScheduler","maxRequests","throttleRequests","_cache","Map","_tiles","_dirty","_viewport","_selectedTiles","_frameNumber","_modelMatrix","_modelMatrixInverse","setOptions","tiles","selectedTiles","isLoaded","every","needsReload","some","Object","assign","Number","isFinite","maxZoom","_maxZoom","Math","floor","minZoom","_minZoom","ceil","finalize","values","isLoading","abort","clear","reloadAll","id","keys","get","includes","delete","setNeedsReload","update","viewport","zRange","modelMatrix","modelMatrixAsMatrix4","isModelMatrixNew","_zRange","clone","invert","tileIndices","modelMatrixInverse","map","index","_getTile","_rebuildTree","changed","updateTileStates","_pruneRequests","isTileVisible","cullRect","isVisible","minX","minY","maxX","maxY","z","bbox","west","east","south","north","y0","min","top","bottom","y1","max","left","right","tileSize","extent","zoomOffset","getTileId","x","y","getTileZoom","getTileMetadata","getParentIndex","refinementStrategy","visibilities","Array","size","i","isSelected","from","abortCandidates","ongoingRequestCount","push","length","shift","parent","children","_getNearestAncestor","maxCacheSize","Infinity","overflown","onTileUnload","sort","t1","t2","zoom","create","set","loadData","getData","getTileData","requestScheduler","onLoad","onError","onTileError","allTiles","state","getPlaceholderInAncestors","getPlaceholderInChildren","Boolean","sortedTiles","child","startTile","content"],"sources":["C:\\Users\\deeag\\OneDrive\\Desktop\\Aplicații\\earthquakes\\node_modules\\@deck.gl\\geo-layers\\src\\tile-layer\\tileset-2d.ts"],"sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox, getCullBounds} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4, equals} from '@math.gl/core';\nimport {Viewport} from '@deck.gl/core';\nimport {Bounds, TileIndex, ZRange} from './types';\nimport {TileLayerProps} from './tile-layer';\nimport {_memoize as memoize} from '@deck.gl/core';\n\n// bit masks\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nexport type RefinementStrategyFunction = (tiles: Tile2DHeader[]) => void;\nexport type RefinementStrategy =\n  | typeof STRATEGY_NEVER\n  | typeof STRATEGY_REPLACE\n  | typeof STRATEGY_DEFAULT\n  | RefinementStrategyFunction;\n\nconst DEFAULT_CACHE_SCALE = 5;\n\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\n\nexport type Tileset2DProps = Pick<\n  Required<TileLayerProps>,\n  | 'tileSize'\n  | 'maxCacheSize'\n  | 'maxCacheByteSize'\n  | 'refinementStrategy'\n  | 'extent'\n  | 'maxZoom'\n  | 'minZoom'\n  | 'maxRequests'\n  | 'zoomOffset'\n> & {\n  getTileData: NonNullable<TileLayerProps['getTileData']>;\n  onTileLoad: (tile: Tile2DHeader) => void;\n  onTileUnload: (tile: Tile2DHeader) => void;\n  onTileError: (error: any, tile: Tile2DHeader) => void;\n};\n\n/**\n * Manages loading and purging of tile data. This class caches recently visited tiles\n * and only creates new tiles if they are present.\n */\nexport default class Tileset2D {\n  private opts: Tileset2DProps;\n  private _requestScheduler: RequestScheduler;\n  private _cache: Map<string, Tile2DHeader>;\n  private _dirty: boolean;\n  private _tiles: Tile2DHeader[];\n\n  private _cacheByteSize: number;\n  private _viewport: Viewport | null;\n  private _zRange?: ZRange;\n  private _selectedTiles: Tile2DHeader[] | null;\n  private _frameNumber: number;\n  private _modelMatrix: Matrix4;\n  private _modelMatrixInverse: Matrix4;\n\n  private _maxZoom?: number;\n  private _minZoom?: number;\n\n  private onTileLoad: (tile: Tile2DHeader) => void;\n\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts: Tileset2DProps) {\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles(): Tile2DHeader[] | null {\n    return this._selectedTiles;\n  }\n\n  get isLoaded(): boolean {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload(): boolean {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts: Tileset2DProps): void {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom as number);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom as number);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize(): void {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll(): void {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id) as Tile2DHeader;\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   */\n  update(\n    viewport: Viewport,\n    {zRange, modelMatrix}: {zRange?: ZRange; modelMatrix?: Matrix4} = {}\n  ): number {\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (\n      !this._viewport ||\n      !viewport.equals(this._viewport) ||\n      !equals(this._zRange, zRange) ||\n      isModelMatrixNew\n    ) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n      // Check for needed reloads explicitly even if the view/matrix has not changed.\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles!.map(tile => this._getTile(tile.index, true));\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  isTileVisible(\n    tile: Tile2DHeader,\n    cullRect?: {x: number; y: number; width: number; height: number}\n  ): boolean {\n    if (!tile.isVisible) {\n      return false;\n    }\n\n    if (cullRect && this._viewport) {\n      const [minX, minY, maxX, maxY] = getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n      const {bbox} = tile;\n      if ('west' in bbox) {\n        return bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n      }\n      // top/bottom could be swapped depending on the indexing system\n      const y0 = Math.min(bbox.top, bbox.bottom);\n      const y1 = Math.max(bbox.top, bbox.bottom);\n      return bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n    }\n    return true;\n  }\n\n  /* Public interface for subclassing */\n\n  /** Returns array of tile indices in the current viewport */\n  getTileIndices({\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    modelMatrix,\n    modelMatrixInverse\n  }: {\n    viewport: Viewport;\n    maxZoom?: number;\n    minZoom?: number;\n    zRange: ZRange | undefined;\n    tileSize?: number;\n    modelMatrix?: Matrix4;\n    modelMatrixInverse?: Matrix4;\n    zoomOffset?: number;\n  }): TileIndex[] {\n    const {tileSize, extent, zoomOffset} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent as Bounds | undefined,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  /** Returns unique string key for a tile index */\n  getTileId(index: TileIndex) {\n    return `${index.x}-${index.y}-${index.z}`;\n  }\n\n  /** Returns a zoom level for a tile index */\n  getTileZoom(index: TileIndex) {\n    return index.z;\n  }\n\n  /** Returns additional metadata to add to tile, bbox by default */\n  getTileMetadata(index: TileIndex): Record<string, any> {\n    const {tileSize} = this.opts;\n    // @ts-expect-error\n    return {bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)};\n  }\n\n  /** Returns index of the parent tile */\n  getParentIndex(index: TileIndex) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {x, y, z};\n  }\n\n  // Returns true if any tile's visibility changed\n  private updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    // Reset state\n    for (const tile of this._cache.values()) {\n      // save previous state\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    // @ts-expect-error called only when _selectedTiles is already defined\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    // Strategy-specific state logic\n    (typeof refinementStrategy === 'function'\n      ? refinementStrategy\n      : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n\n    i = 0;\n    // Check if any visibility has changed\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /* Private methods */\n\n  private _getCullBounds = memoize(getCullBounds);\n\n  private _pruneRequests(): void {\n    const {maxRequests} = this.opts;\n\n    const abortCandidates: Tile2DHeader[] = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      // There are too many ongoing requests, so abort some that are unselected\n      const tile = abortCandidates.shift()!;\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  private _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n      tile.parent = parent;\n      if (parent?.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  private _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      // @ts-expect-error called only when selectedTiles is initialized\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(id);\n          this.opts.onTileUnload(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      // sort by zoom level so that smaller tiles are displayed on top\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  private _getTile(index: TileIndex, create: true): Tile2DHeader;\n  private _getTile(index: TileIndex, create?: false): Tile2DHeader | undefined;\n  private _getTile(index: TileIndex, create?: boolean): Tile2DHeader | undefined {\n    const id = this.getTileId(index);\n    let tile = this._cache.get(id);\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {id, zoom: this.getTileZoom(tile.index)});\n      needsReload = true;\n      this._cache.set(id, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (tile && needsReload) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(tile: Tile2DHeader): Tile2DHeader | null {\n    const {_minZoom = 0} = this;\n\n    let index = tile.index;\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n/* -- Refinement strategies --*/\n/* eslint-disable max-depth */\n\n// For all the selected && pending tiles:\n// - pick the closest ancestor as placeholder\n// - if no ancestor is visible, pick the closest children as placeholder\nfunction updateTileStateDefault(allTiles: Tile2DHeader[]) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state! & TILE_STATE_VISIBLE);\n  }\n}\n\n// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder\nfunction updateTileStateReplace(allTiles: Tile2DHeader[]) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  // Always process parents first\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state! & TILE_STATE_VISIBLE);\n\n    if (tile.children && (tile.isVisible || tile.state! & TILE_STATE_VISITED)) {\n      // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\n// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.\nfunction getPlaceholderInAncestors(startTile: Tile2DHeader) {\n  let tile: Tile2DHeader | null = startTile;\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state! |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}